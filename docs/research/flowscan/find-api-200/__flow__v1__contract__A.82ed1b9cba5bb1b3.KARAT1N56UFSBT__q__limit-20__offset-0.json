{
  "data": [
    {
      "name": "KARAT1N56UFSBT",
      "address": "0x82ed1b9cba5bb1b3",
      "parent_contract_id": null,
      "id": "A.82ed1b9cba5bb1b3.KARAT1N56UFSBT/141205184",
      "identifier": "A.82ed1b9cba5bb1b3.KARAT1N56UFSBT",
      "transaction_hash": "456d50108d975236607eb163efdf1cef65298457a877e461fcf496e687d8aa1e",
      "status": "ok",
      "diff": "",
      "body": "import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport ViewResolver from 0x1d7e57aa55817448\n\n\naccess(all) contract KARAT1N56UFSBT: NonFungibleToken {\n\n    access(all) let CollectionStoragePath: StoragePath\n    access(all) let CollectionPublicPath: PublicPath\n    access(all) let AdminStoragePath: StoragePath\n\n    access(all) var totalSupply: UInt64\n\n    access(all) event ContractInitialized()\n    access(all) event Withdraw(id: UInt64, from: Address?)\n    access(all) event Deposit(id: UInt64, to: Address?)\n    access(all) event Minted(id: UInt64, metadata: Metadata)\n\n    access(all) resource NFT: NonFungibleToken.NFT {\n        access(all) let id: UInt64\n        access(all) let metadata: Metadata\n\n        init(initID: UInt64, initMetadata: Metadata) {\n            self.id = initID\n            self.metadata = initMetadata\n        }\n\n        access(all) view fun getMetadata(): Metadata {\n            return self.metadata\n        }\n\n        /// createEmptyCollection creates an empty Collection\n        /// and returns it to the caller so that they can own NFTs\n        /// @{NonFungibleToken.Collection}\n        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {\n            return <-KARAT1N56UFSBT.createEmptyCollection(nftType: Type<@KARAT1N56UFSBT.NFT>())\n        }\n\n        access(all) view fun getViews(): [Type] {\n            return [\n                Type<MetadataViews.Display>(),\n                Type<MetadataViews.Royalties>(),\n                Type<MetadataViews.Editions>(),\n                Type<MetadataViews.ExternalURL>(),\n                Type<MetadataViews.NFTCollectionData>(),\n                Type<MetadataViews.NFTCollectionDisplay>(),\n                Type<MetadataViews.Serial>(),\n                Type<MetadataViews.Traits>(),\n                Type<MetadataViews.EVMBridgedMetadata>()\n            ]\n        }\n\n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: self.metadata.name,\n                        description: self.metadata.description,\n                        thumbnail: MetadataViews.HTTPFile(\n                            url: \"https://apps.24karat.io/collections/KARAT1N56UFSBT/nfts/\".concat(self.id.toString()).concat(\"/thumbnail.png\")\n                        )\n                    )\n                case Type<MetadataViews.Editions>():\n                    // There is no max number of NFTs that can be minted from this contract\n                    // so the max edition field value is set to nil\n                    let editionInfo = MetadataViews.Edition(name: \"「らずめいと自販機でデジタルグッズを販売しよう！with アドインテ」 Edition\", number: self.id, max: nil)\n                    let editionList: [MetadataViews.Edition] = [editionInfo]\n                    return MetadataViews.Editions(\n                        editionList\n                    )\n                case Type<MetadataViews.Serial>():\n                    return MetadataViews.Serial(\n                        self.id\n                    )\n                case Type<MetadataViews.Royalties>():\n                    return MetadataViews.Royalties(\n                        [MetadataViews.Royalty(\n                            receiver: getAccount(self.metadata.artistAddress).capabilities.get<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())!,\n                            cut: self.metadata.royalty,\n                            description: \"The Royalty of 「らずめいと自販機でデジタルグッズを販売しよう！with アドインテ」\"\n                        )]\n                    )\n                case Type<MetadataViews.ExternalURL>():\n                    return MetadataViews.ExternalURL(\"https://24karat.io\")\n                case Type<MetadataViews.NFTCollectionData>():\n                    return MetadataViews.NFTCollectionData(\n                        storagePath: KARAT1N56UFSBT.CollectionStoragePath,\n                        publicPath: KARAT1N56UFSBT.CollectionPublicPath,\n                        publicCollection: Type<&KARAT1N56UFSBT.Collection>(),\n                        publicLinkedType: Type<&KARAT1N56UFSBT.Collection>(),\n                        createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {\n                            return <-KARAT1N56UFSBT.createEmptyCollection(nftType: Type<@KARAT1N56UFSBT.NFT>())\n                        })\n                    )\n                case Type<MetadataViews.NFTCollectionDisplay>():\n                    let media = MetadataViews.Media(\n                        file: MetadataViews.HTTPFile(\n                            url: \"https://apps.24karat.io/collections/KARAT1N56UFSBT/thumbnail.png\"\n                        ),\n                        mediaType: \"image/png\"\n                    )\n                    return MetadataViews.NFTCollectionDisplay(\n                        name: \"「らずめいと自販機でデジタルグッズを販売しよう！with アドインテ」\",\n                        description: \"\",\n                        externalURL: MetadataViews.ExternalURL(\"https://24karat.io\"),\n                        squareImage: media,\n                        bannerImage: media,\n                        socials: {}\n                    )\n                case Type<MetadataViews.Traits>():\n                    let excludedTraits: [String] = []\n                    let traitsView = MetadataViews.dictToTraits(dict: {}, excludedNames: excludedTraits)\n                    return traitsView\n\t\t\t\tcase Type<MetadataViews.EVMBridgedMetadata>():\n                    // Project-defined ERC721 EVM contract stores baseURI, name, and symbol in its own contract storage\n                    return MetadataViews.EVMBridgedMetadata(\n                        name: \"「らずめいと自販機でデジタルグッズを販売しよう！with アドインテ」\",\n                        symbol: \"KARAT1N56UFSBT\",\n                        uri: MetadataViews.URI(\n                            baseURI: \"\",\n                            value: \"https://apps.24karat.io/collections/KARAT1N56UFSBT/nfts/\".concat(self.id.toString()).concat(\"/metadata\")\n                        )\n                    )\n\n            }\n            return nil\n        }\n    }\n\n    access(all) struct Metadata {\n        access(all) let name: String\n        access(all) let artist: String\n        access(all) let artistAddress: Address\n        access(all) let description: String\n        access(all) let type: String\n        access(all) let serialId: UInt64\n        access(all) let royalty: UFix64\n\n        init(\n            name: String,\n            artist: String,\n            artistAddress: Address,\n            description: String,\n            type: String,\n            serialId: UInt64,\n            royalty: UFix64\n        ) {\n            self.name = name\n            self.artist = artist\n            self.artistAddress = artistAddress\n            self.description = description\n            self.type = type\n            self.serialId = serialId\n            self.royalty = royalty\n        }\n    }\n\n    // Deprecated: Only here for backward compatibility.\n    access(all) resource interface KARAT1N56UFSBTCollectionPublic {}\n\n    access(all) resource Collection: NonFungibleToken.Collection, KARAT1N56UFSBTCollectionPublic {\n        access(all) var ownedNFTs: @{UInt64: {NonFungibleToken.NFT}}\n\n        init () {\n            self.ownedNFTs <- {}\n        }\n\n        /// getSupportedNFTTypes returns a list of NFT types that this receiver accepts\n        access(all) view fun getSupportedNFTTypes(): {Type: Bool} {\n            let supportedTypes: {Type: Bool} = {}\n            supportedTypes[Type<@KARAT1N56UFSBT.NFT>()] = true\n            return supportedTypes\n        }\n\n        /// Returns whether or not the given type is accepted by the collection\n        /// A collection that can accept any type should just return true by default\n        access(all) view fun isSupportedNFTType(type: Type): Bool {\n            return type == Type<@KARAT1N56UFSBT.NFT>()\n        }\n\n        /// withdraw removes an NFT from the collection and moves it to the caller\n        access(NonFungibleToken.Withdraw) fun withdraw(withdrawID: UInt64): @{NonFungibleToken.NFT} {\n            let token <- self.ownedNFTs.remove(key: withdrawID)\n                ?? panic(\"Could not withdraw an NFT with the provided ID from the collection\")\n\n            return <-token\n        }\n\n        access(all) fun deposit(token: @{NonFungibleToken.NFT}) {\n            let id: UInt64 = token.id\n            let oldToken <- self.ownedNFTs[id] <- token\n            emit Deposit(id: id, to: self.owner?.address)\n            destroy oldToken\n        }\n\n        access(all) view fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        /// Gets the amount of NFTs stored in the collection\n        access(all) view fun getLength(): Int {\n            return self.ownedNFTs.keys.length\n        }\n\n        access(all) view fun borrowNFT(_ id: UInt64): &{NonFungibleToken.NFT}? {\n            return (&self.ownedNFTs[id] as &{NonFungibleToken.NFT}?)\n        }\n\n        /// Borrow the view resolver for the specified NFT ID\n        access(all) view fun borrowViewResolver(id: UInt64): &{ViewResolver.Resolver}? {\n            if let nft = &self.ownedNFTs[id] as &{NonFungibleToken.NFT}? {\n                return nft as &{ViewResolver.Resolver}\n            }\n            return nil\n        }\n\n        /// createEmptyCollection creates an empty Collection of the same type\n        /// and returns it to the caller\n        /// @return A an empty collection of the same type\n        access(all) fun createEmptyCollection(): @{NonFungibleToken.Collection} {\n            return <-KARAT1N56UFSBT.createEmptyCollection(nftType: Type<@KARAT1N56UFSBT.NFT>())\n        }\n    }\n\n    access(all) fun createEmptyCollection(nftType: Type): @{NonFungibleToken.Collection} {\n        return <- create Collection()\n    }\n\n    access(all) view fun getContractViews(resourceType: Type?): [Type] {\n        return [\n            Type<MetadataViews.NFTCollectionData>(),\n            Type<MetadataViews.NFTCollectionDisplay>()\n        ]\n    }\n\n    /// Function that resolves a metadata view for this contract.\n    ///\n    /// @param view: The Type of the desired view.\n    /// @return A structure representing the requested view.\n    ///\n    access(all) fun resolveContractView(resourceType: Type?, viewType: Type): AnyStruct? {\n        switch viewType {\n            case Type<MetadataViews.NFTCollectionData>():\n                let collectionData = MetadataViews.NFTCollectionData(\n                    storagePath: self.CollectionStoragePath,\n                    publicPath: self.CollectionPublicPath,\n                    publicCollection: Type<&KARAT1N56UFSBT.Collection>(),\n                    publicLinkedType: Type<&KARAT1N56UFSBT.Collection>(),\n                    createEmptyCollectionFunction: (fun(): @{NonFungibleToken.Collection} {\n                        return <-KARAT1N56UFSBT.createEmptyCollection(nftType: Type<@KARAT1N56UFSBT.NFT>())\n                    })\n                )\n                return collectionData\n            case Type<MetadataViews.NFTCollectionDisplay>():\n                let media = MetadataViews.Media(\n                    file: MetadataViews.HTTPFile(\n                        url: \"https://apps.24karat.io/collections/KARAT1N56UFSBT/thumbnail.png\"\n                    ),\n                    mediaType: \"image/png\"\n                )\n                return MetadataViews.NFTCollectionDisplay(\n                    name: \"「らずめいと自販機でデジタルグッズを販売しよう！with アドインテ」\",\n                    description: \"\",\n                    externalURL: MetadataViews.ExternalURL(\"https://24karat.io\"),\n                    squareImage: media,\n                    bannerImage: media,\n                    socials: {\n                        \"twitter\": MetadataViews.ExternalURL(\"https://twitter.com/24karat_io\")\n                    }\n                )\n        }\n        return nil\n    }\n\n    access(all) resource NFTMinter {\n        access(all) fun mintNFT(recipient: &{NonFungibleToken.Receiver}, metadata: KARAT1N56UFSBT.Metadata) {\n            pre {\n                metadata.royalty <= 0.1: \"royalty must lower than 0.1\"\n            }\n\n            let tokenId = KARAT1N56UFSBT.totalSupply + (1 as UInt64)\n            var newNFT <- create NFT(initID: tokenId, initMetadata: metadata)\n            recipient.deposit(token: <-newNFT)\n            emit Minted(id: tokenId, metadata: metadata)\n            KARAT1N56UFSBT.totalSupply = tokenId\n        }\n    }\n\n    init() {\n        self.CollectionStoragePath = /storage/KARAT1N56UFSBTCollection\n        self.CollectionPublicPath = /public/KARAT1N56UFSBTCollection\n        self.AdminStoragePath = /storage/KARAT1N56UFSBTAdmin\n\n        self.totalSupply = 0\n\n        let minter: @KARAT1N56UFSBT.NFTMinter <- create NFTMinter()\n        self.account.storage.save(<-minter, to: self.AdminStoragePath)\n\n        emit ContractInitialized()\n    }\n}",
      "valid_from": 141205184,
      "valid_to": null,
      "created_at": "2026-02-05T09:17:34.027Z",
      "deployments": 1,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 4,
      "tags": null
    }
  ],
  "_links": {
    "self": "/flow/v1/contract/A.82ed1b9cba5bb1b3.KARAT1N56UFSBT?limit=20&valid_from=141205184"
  }
}