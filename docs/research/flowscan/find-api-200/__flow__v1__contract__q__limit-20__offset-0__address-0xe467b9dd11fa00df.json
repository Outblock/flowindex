{
  "data": [
    {
      "name": "FlowTransactionSchedulerUtils",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils/135783129",
      "id": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils/138787575",
      "identifier": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils",
      "transaction_hash": "98994e4285e8bed7b5dd7c40bcc2af9d052c9875e409d5d4e99feaed650df7db",
      "status": "ok",
      "diff": "--- 7cf9f5ef3137886663ced7aef98c96d3a37b14d7fb09664e3b7810457aba461d.135783129\n+++ 98994e4285e8bed7b5dd7c40bcc2af9d052c9875e409d5d4e99feaed650df7db.138787575\n@@ -1,8 +1,11 @@\n import FlowTransactionScheduler from 0xe467b9dd11fa00df\n+import FungibleToken from 0xf233dcee88fe0abe\n import FlowToken from 0x1654653399040a61\n+import EVM from 0xe467b9dd11fa00df\n+import MetadataViews from 0x1d7e57aa55817448\n \n /// FlowTransactionSchedulerUtils provides utility functionality for working with scheduled transactions\n-/// on the Flow blockchain. Currently, it only includes a Manager resource for managing scheduled transactions.\n+/// on the Flow blockchain.\n ///\n /// In the future, this contract will be updated to include more functionality \n /// to make it more convenient for working with scheduled transactions for various use cases.\n@@ -231,16 +231,15 @@\n             self.handlerUUIDsByTransactionID[id] = handlerUUID\n \n             // Store the handler capability in the handlers dictionary for later retrieval\n-            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n+            if self.handlerInfos[handlerTypeIdentifier] != nil {\n+                let handlers = &self.handlerInfos[handlerTypeIdentifier]! as auth(Mutate) &{UInt64: HandlerInfo}\n                 if let handlerInfo = handlers[handlerUUID] {\n                     handlerInfo.addTransactionID(id: id)\n-                    handlers[handlerUUID] = handlerInfo\n                 } else {\n                     let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                     handlerInfo.addTransactionID(id: id)\n                     handlers[handlerUUID] = handlerInfo\n                 }\n-                self.handlerInfos[handlerTypeIdentifier] = handlers\n             } else {\n                 let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                 handlerInfo.addTransactionID(id: id)\n@@ -255,9 +247,9 @@\n             self.sortedTimestamps.add(timestamp: actualTimestamp)\n \n             // Store the transaction in the ids by timestamp dictionary\n-            if let ids = self.idsByTimestamp[actualTimestamp] {\n+            if self.idsByTimestamp[actualTimestamp] != nil {\n+                let ids = &self.idsByTimestamp[actualTimestamp]! as auth(Mutate) &[UInt64]\n                 ids.append(id)\n-                self.idsByTimestamp[actualTimestamp] = ids\n             } else {\n                 self.idsByTimestamp[actualTimestamp] = [id]\n             }\n@@ -579,6 +570,269 @@\n         return getAccount(at).capabilities.borrow<&{Manager}>(self.managerPublicPath)\n     }\n \n+    /*********************************************\n+    \n+    COA Handler Utils\n+\n+    **********************************************/\n+\n+    access(all) event COAHandlerExecutionError(id: UInt64, owner: Address?, coaAddress: String?, errorMessage: String)\n+\n+    access(all) view fun coaHandlerStoragePath(): StoragePath {\n+        return /storage/coaScheduledTransactionHandler\n+    }\n+\n+    access(all) view fun coaHandlerPublicPath(): PublicPath {\n+        return /public/coaScheduledTransactionHandler\n+    }\n+\n+    /// COATransactionHandler is a resource that wraps a capability to a COA (Cadence Owned Account)\n+    /// and implements the TransactionHandler interface to allow scheduling transactions for COAs.\n+    /// This handler enables users to schedule transactions that will be executed on behalf of their COA.\n+    access(all) resource COATransactionHandler: FlowTransactionScheduler.TransactionHandler {\n+        /// The capability to the COA resource\n+        access(self) let coaCapability: Capability<auth(EVM.Owner) &EVM.CadenceOwnedAccount>\n+\n+        /// The capability to the FlowToken vault\n+        access(self) let flowTokenVaultCapability: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>\n+\n+        init(coaCapability: Capability<auth(EVM.Owner) &EVM.CadenceOwnedAccount>,\n+             flowTokenVaultCapability: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>,\n+        )\n+        {\n+            pre {\n+                coaCapability.check(): \"COA capability is invalid or expired\"\n+                flowTokenVaultCapability.check(): \"FlowToken vault capability is invalid or expired\"\n+            }\n+            self.coaCapability = coaCapability\n+            self.flowTokenVaultCapability = flowTokenVaultCapability\n+        }\n+\n+        access(self) fun emitError(id: UInt64, errorMessage: String) {\n+            let coa = self.coaCapability.borrow()!\n+            emit COAHandlerExecutionError(id: id, owner: self.owner?.address, coaAddress: coa.address().toString(),\n+                                          errorMessage: errorMessage)\n+        }\n+\n+        /// Execute the scheduled transaction using the COA\n+        /// @param id: The ID of the scheduled transaction\n+        /// @param data: Optional data passed to the transaction execution. In this case, the data must be a COAHandlerParams struct with valid values.\n+        access(FlowTransactionScheduler.Execute) fun executeTransaction(id: UInt64, data: AnyStruct?) {\n+\n+            // Borrow the COA capability\n+            let coa = self.coaCapability.borrow()\n+            if coa == nil {\n+                emit COAHandlerExecutionError(id: id, owner: self.owner?.address ?? Address(0x0), coaAddress: nil,\n+                                              errorMessage: \"COA capability is invalid or expired for scheduled transaction with ID \\(id)\")\n+                return\n+            }\n+\n+            // Parse the data into a list of COAHandlerParams\n+            // If the data is a single COAHandlerParams struct, wrap it in a list\n+            var params: [COAHandlerParams]? = data as? [COAHandlerParams]\n+            if params == nil {\n+                if let param = data as? COAHandlerParams {\n+                    params = [param]\n+                }\n+            }\n+\n+            // Iterate through all the COA transactions and execute them all\n+            // If revertOnFailure is true for a transaction and any part of it fails, the entire scheduled transaction will be reverted\n+            // If not but a part of the transaction fails, an error event will be emitted but the scheduled transaction will continue to execute the next transaction\n+            //\n+            if let transactions = params {\n+                for index, txParams in transactions {\n+                    switch txParams.txType {\n+                        case COAHandlerTxType.DepositFLOW:\n+                            let vault = self.flowTokenVaultCapability.borrow()\n+                            if vault == nil {\n+                                if !txParams.revertOnFailure {\n+                                    self.emitError(id: id, errorMessage: \"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n+                                    continue\n+                                } else {\n+                                    panic(\"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n+                                }\n+                            }\n+\n+                            if txParams.amount! > vault!.balance && !txParams.revertOnFailure {\n+                                self.emitError(id: id, errorMessage: \"Insufficient FLOW in FlowToken vault for deposit into COA for scheduled transaction with ID \\(id) and index \\(index)\")\n+                                continue\n+                            }\n+\n+                            // Deposit the FLOW into the COA vault. If there isn't enough FLOW in the vault,\n+                            //the transaction will be reverted because we know revertOnFailure is true\n+                            coa!.deposit(from: <-vault!.withdraw(amount: txParams.amount!) as! @FlowToken.Vault)\n+                        case COAHandlerTxType.WithdrawFLOW:\n+                            let vault = self.flowTokenVaultCapability.borrow()\n+                            if vault == nil {\n+                                if !txParams.revertOnFailure {\n+                                    self.emitError(id: id, errorMessage: \"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n+                                    continue\n+                                } else {\n+                                    panic(\"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n+                                }\n+                            }\n+\n+                            let amount = EVM.Balance(attoflow: 0)\n+                            amount.setFLOW(flow: txParams.amount!)\n+\n+                            if amount.attoflow > coa!.balance().attoflow && !txParams.revertOnFailure {\n+                                self.emitError(id: id, errorMessage: \"Insufficient FLOW in COA vault for withdrawal from COA for scheduled transaction with ID \\(id) and index \\(index)\")\n+                                continue\n+                            }\n+\n+                            // Withdraw the FLOW from the COA vault. If there isn't enough FLOW in the COA,\n+                            // the transaction will be reverted because we know revertOnFailure is true\n+                            vault!.deposit(from: <-coa!.withdraw(balance: amount))\n+                        case COAHandlerTxType.Call:\n+                            let result = coa!.call(to: txParams.callToEVMAddress!, data: txParams.data!, gasLimit: txParams.gasLimit!, value: txParams.value!)\n+\n+                            if result.status != EVM.Status.successful {\n+                                if !txParams.revertOnFailure {\n+                                    self.emitError(id: id, errorMessage: \"EVM call failed for scheduled transaction with ID \\(id) and index \\(index) with error: \\(result.errorCode):\\(result.errorMessage)\")\n+                                    continue\n+                                } else {\n+                                    panic(\"EVM call failed for scheduled transaction with ID \\(id) and index \\(index) with error: \\(result.errorCode):\\(result.errorMessage)\")\n+                                }\n+                            }\n+                    }\n+                }\n+            } else {\n+                self.emitError(id: id, errorMessage: \"Invalid scheduled transaction data type for COA handler execution for tx with ID \\(id)! Expected [FlowTransactionSchedulerUtils.COAHandlerParams] but got \\(data.getType().identifier)\")\n+                return\n+            }\n+        }\n+\n+        /// Get the views supported by this handler\n+        /// @return: Array of view types\n+        access(all) view fun getViews(): [Type] {\n+            return [\n+                Type<COAHandlerView>(),\n+                Type<StoragePath>(),\n+                Type<PublicPath>(),\n+                Type<MetadataViews.Display>()\n+            ]\n+        }\n+\n+        /// Resolve a view for this handler\n+        /// @param viewType: The type of view to resolve\n+        /// @return: The resolved view data, or nil if not supported\n+        access(all) fun resolveView(_ viewType: Type): AnyStruct? {\n+            if viewType == Type<COAHandlerView>() {\n+                return COAHandlerView(\n+                    coaOwner: self.coaCapability.borrow()?.owner?.address,\n+                    coaEVMAddress: self.coaCapability.borrow()?.address(),\n+                    coaBalance: self.coaCapability.borrow()?.balance(),\n+                )\n+            }\n+            if viewType == Type<StoragePath>() {\n+                return FlowTransactionSchedulerUtils.coaHandlerStoragePath()\n+            } else if viewType == Type<PublicPath>() {\n+                return FlowTransactionSchedulerUtils.coaHandlerPublicPath()\n+            } else if viewType == Type<MetadataViews.Display>() {\n+                return MetadataViews.Display(\n+                    name: \"COA Scheduled Transaction Handler\",\n+                    description: \"Scheduled Transaction Handler that can execute transactions on behalf of a COA\",\n+                    thumbnail: MetadataViews.HTTPFile(\n+                        url: \"\"\n+                    )\n+                )\n+            }\n+            return nil\n+        }\n+    }\n+\n+    /// Enum for COA handler execution type\n+    access(all) enum COAHandlerTxType: UInt8 {\n+        access(all) case DepositFLOW\n+        access(all) case WithdrawFLOW\n+        access(all) case Call\n+\n+        // TODO: Should we have other transaction types??\n+    }\n+\n+    access(all) struct COAHandlerParams {\n+\n+        /// The type of transaction to execute\n+        access(all) let txType: COAHandlerTxType\n+\n+        /// Indicates if the whole set of scheduled transactions should be reverted\n+        /// if this one transaction fails to execute in EVM\n+        access(all) let revertOnFailure: Bool\n+\n+        /// The amount of FLOW to deposit or withdraw\n+        /// Not required for the Call transaction type\n+        access(all) let amount: UFix64?\n+\n+        /// The following fields are only required for the Call transaction type\n+        access(all) let callToEVMAddress: EVM.EVMAddress?\n+        access(all) let data: [UInt8]?\n+        access(all) let gasLimit: UInt64?\n+        access(all) let value: EVM.Balance?\n+\n+        init(txType: UInt8, revertOnFailure: Bool, amount: UFix64?, callToEVMAddress: String?, data: [UInt8]?, gasLimit: UInt64?, value: UInt?) {\n+            self.txType = COAHandlerTxType(rawValue: txType)\n+                ?? panic(\"Invalid COA transaction type enum\")\n+            self.revertOnFailure = revertOnFailure\n+            if self.txType == COAHandlerTxType.DepositFLOW {\n+                assert(amount != nil, message: \"Amount is required for deposit but was not provided\")\n+            }\n+            if self.txType == COAHandlerTxType.WithdrawFLOW {\n+                assert(amount != nil, message: \"Amount is required for withdrawal but was not provided\")\n+            }\n+            if self.txType == COAHandlerTxType.Call {\n+                assert(callToEVMAddress != nil, message: \"Call to EVM address is required for EVM call but was not provided\")\n+                assert((data != nil && value != nil) || (data == nil ? value != nil : true), message: \"Data and/or value are required for EVM call but neither were provided\")\n+                assert(gasLimit != nil, message: \"Gas limit is required for EVM call but was not provided\")\n+            }\n+            self.amount = amount\n+            if callToEVMAddress != nil {\n+                self.callToEVMAddress = EVM.addressFromString(callToEVMAddress!)\n+            } else {\n+                self.callToEVMAddress = nil\n+            }\n+            if data != nil {\n+                self.data = data\n+            } else {\n+                self.data = []\n+            }\n+            self.gasLimit = gasLimit\n+            if let unwrappedValue = value {\n+                self.value = EVM.Balance(attoflow: unwrappedValue)\n+            } else {\n+                self.value = nil\n+            }\n+        }\n+    }\n+\n+    /// View struct for COA handler metadata\n+    access(all) struct COAHandlerView {\n+        access(all) let coaOwner: Address?\n+        access(all) let coaEVMAddress: EVM.EVMAddress?\n+\n+        access(all) let coaBalance: EVM.Balance?\n+\n+        init(coaOwner: Address?, coaEVMAddress: EVM.EVMAddress?, coaBalance: EVM.Balance?) {\n+            self.coaOwner = coaOwner\n+            self.coaEVMAddress = coaEVMAddress\n+            self.coaBalance = coaBalance\n+        }\n+    }\n+\n+    /// Create a COA transaction handler\n+    /// @param coaCapability: Capability to the COA resource\n+    /// @param flowTokenVaultCapability: Capability to the FlowToken vault\n+    /// @return: A new COATransactionHandler resource\n+    access(all) fun createCOATransactionHandler(\n+        coaCapability: Capability<auth(EVM.Owner) &EVM.CadenceOwnedAccount>,\n+        flowTokenVaultCapability: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>,\n+    ): @COATransactionHandler {\n+        return <-create COATransactionHandler(\n+            coaCapability: coaCapability,\n+            flowTokenVaultCapability: flowTokenVaultCapability,\n+        )\n+    }\n+\n     /********************************************\n     \n     Scheduled Transactions Metadata Views\n",
      "body": "import FlowTransactionScheduler from 0xe467b9dd11fa00df\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport EVM from 0xe467b9dd11fa00df\nimport MetadataViews from 0x1d7e57aa55817448\n\n/// FlowTransactionSchedulerUtils provides utility functionality for working with scheduled transactions\n/// on the Flow blockchain.\n///\n/// In the future, this contract will be updated to include more functionality \n/// to make it more convenient for working with scheduled transactions for various use cases.\n///\naccess(all) contract FlowTransactionSchedulerUtils {\n\n    /// Storage path for Manager resources\n    access(all) let managerStoragePath: StoragePath\n\n    /// Public path for Manager resources\n    access(all) let managerPublicPath: PublicPath\n\n    /// Entitlements\n    access(all) entitlement Owner\n\n    /// HandlerInfo is a struct that stores information about a single transaction handler\n    /// that has been used to schedule transactions.\n    /// It is stored in the manager's handlerInfos dictionary.\n    /// It stores the type identifier of the handler, the transaction IDs that have been scheduled for it,\n    /// and a capability to the handler.\n    /// The capability is used to borrow a reference to the handler when needed.\n    /// The transaction IDs are used to track the transactions that have been scheduled for the handler.\n    /// The type identifier is used to differentiate between handlers of the same type.\n    access(all) struct HandlerInfo {\n        /// The type identifier of the handler\n        access(all) let typeIdentifier: String\n\n        /// The transaction IDs that have been scheduled for the handler\n        access(all) let transactionIDs: [UInt64]\n\n        /// The capability to the handler\n        access(contract) let capability: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>\n\n        init(typeIdentifier: String, capability: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>) {\n            self.typeIdentifier = typeIdentifier\n            self.capability = capability\n            self.transactionIDs = []\n        }\n\n        /// Add a transaction ID to the handler's transaction IDs\n        /// @param id: The ID of the transaction to add\n        access(contract) fun addTransactionID(id: UInt64) {\n            self.transactionIDs.append(id)\n        }\n\n        /// Remove a transaction ID from the handler's transaction IDs\n        /// @param id: The ID of the transaction to remove\n        access(contract) fun removeTransactionID(id: UInt64) {\n            let index = self.transactionIDs.firstIndex(of: id)\n            if index != nil {\n                self.transactionIDs.remove(at: index!)\n            }\n        }\n\n        /// Borrow an un-entitled reference to the handler\n        /// @return: A reference to the handler, or nil if not found\n        access(contract) view fun borrow(): &{FlowTransactionScheduler.TransactionHandler}? {\n            return self.capability.borrow() as? &{FlowTransactionScheduler.TransactionHandler}\n        }\n    }\n\n    /// The Manager resource offers a convenient way for users and developers to\n    /// group, schedule, cancel, and query scheduled transactions through a single resource.\n    /// The Manager is defined as an interface to allow for multiple implementations of the manager\n    /// and to support upgrades that may be needed in the future to add additional storage fields and functionality.\n    /// \n    /// Key features:\n    /// - Organizes scheduled and executed transactions by handler type and timestamp\n    /// - Simplified scheduling interface that works with previously used transaction handlers\n    /// - Transaction tracking and querying capabilities by handler, timestamp, and ID\n    /// - Handler metadata and view resolution support\n    access(all) resource interface Manager {\n\n        /// Schedules a transaction by passing the arguments directly\n        /// to the FlowTransactionScheduler schedule function\n        /// This also should store the information about the transaction\n        /// and handler in the manager's fields\n        access(Owner) fun schedule(\n            handlerCap: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64\n\n        /// Schedules a transaction that uses a previously used handler\n        /// This should also store the information about the transaction\n        /// and handler in the manager's fields\n        access(Owner) fun scheduleByHandler(\n            handlerTypeIdentifier: String,\n            handlerUUID: UInt64?,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64\n\n        /// Cancels a scheduled transaction by its ID\n        /// This should also remove the information about the transaction from the manager's fields\n        access(Owner) fun cancel(id: UInt64): @FlowToken.Vault\n        \n        access(all) view fun getTransactionData(_ id: UInt64): FlowTransactionScheduler.TransactionData?\n        access(all) view fun borrowTransactionHandlerForID(_ id: UInt64): &{FlowTransactionScheduler.TransactionHandler}?\n        access(all) fun getHandlerTypeIdentifiers(): {String: [UInt64]}\n        access(all) view fun borrowHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): &{FlowTransactionScheduler.TransactionHandler}?\n        access(all) fun getHandlerViews(handlerTypeIdentifier: String, handlerUUID: UInt64?): [Type] \n        access(all) fun resolveHandlerView(handlerTypeIdentifier: String, handlerUUID: UInt64?, viewType: Type): AnyStruct?      \n        access(all) fun getHandlerViewsFromTransactionID(_ id: UInt64): [Type]\n        access(all) fun resolveHandlerViewFromTransactionID(_ id: UInt64, viewType: Type): AnyStruct? \n        access(all) view fun getTransactionIDs(): [UInt64]\n        access(all) view fun getTransactionIDsByHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): [UInt64]\n        access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64]\n        access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]}\n        access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status?\n        access(all) view fun getSortedTimestamps(): FlowTransactionScheduler.SortedTimestamps\n    }\n\n    /// Manager resource is meant to provide users and developers with a simple way\n    /// to group the scheduled transactions that they own into one place to make it more\n    /// convenient to schedule/cancel transactions and get information about the transactions\n    /// that are managed.\n    /// It stores ScheduledTransaction resources in a dictionary and has other fields\n    /// to track the scheduled transactions by timestamp and handler\n    ///\n    access(all) resource ManagerV1: Manager {\n        /// Dictionary storing scheduled transactions by their ID\n        access(self) var scheduledTransactions: @{UInt64: FlowTransactionScheduler.ScheduledTransaction}\n\n        /// Sorted array of timestamps that this manager has transactions scheduled at\n        access(self) var sortedTimestamps: FlowTransactionScheduler.SortedTimestamps\n\n        /// Dictionary storing the IDs of the transactions scheduled at a given timestamp\n        access(self) let idsByTimestamp: {UFix64: [UInt64]}\n\n        /// Dictionary storing the handler UUIDs for transaction IDs\n        access(self) let handlerUUIDsByTransactionID: {UInt64: UInt64}\n\n        /// Dictionary storing the handlers that this manager has scheduled transactions for at one point\n        /// The field differentiates between handlers of the same type by their UUID because there can be multiple handlers of the same type\n        /// that perform the same functionality but maybe do it for different purposes\n        /// so it is important to differentiate between them in case the user needs to retrieve a specific handler\n        /// The metadata for each handler that potentially includes information about the handler's purpose\n        /// can be retrieved from the handler's reference via the getViews() and resolveView() functions\n        access(self) let handlerInfos: {String: {UInt64: HandlerInfo}}\n\n        init() {\n            self.scheduledTransactions <- {}\n            self.sortedTimestamps = FlowTransactionScheduler.SortedTimestamps()\n            self.idsByTimestamp = {}\n            self.handlerUUIDsByTransactionID = {}\n            self.handlerInfos = {}\n        }\n\n        /// scheduleByHandler schedules a transaction by a given handler that has been used before\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param data: Optional data to pass to the transaction when executed\n        /// @param timestamp: The timestamp when the transaction should be executed\n        /// @param priority: The priority of the transaction (High, Medium, or Low)\n        /// @param executionEffort: The execution effort for the transaction\n        /// @param fees: A FlowToken vault containing sufficient fees\n        /// @return: The ID of the scheduled transaction\n        access(Owner) fun scheduleByHandler(\n            handlerTypeIdentifier: String,\n            handlerUUID: UInt64?,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64 {\n            pre {\n                self.handlerInfos.containsKey(handlerTypeIdentifier): \"Invalid handler type identifier: Handler with type identifier \\(handlerTypeIdentifier) not found in manager\"\n                handlerUUID == nil || self.handlerInfos[handlerTypeIdentifier]!.containsKey(handlerUUID!): \"Invalid handler UUID: Handler with type identifier \\(handlerTypeIdentifier) and UUID \\(handlerUUID!) not found in manager\"\n            }\n            let handlers = self.handlerInfos[handlerTypeIdentifier]!\n            var id = handlerUUID\n            if handlerUUID == nil {\n                assert (\n                    handlers.keys.length == 1,\n                    message: \"Invalid handler UUID: Handler with type identifier \\(handlerTypeIdentifier) has more than one UUID, but no UUID was provided\"\n                )\n                id = handlers.keys[0]\n            }\n            return self.schedule(handlerCap: handlers[id!]!.capability, data: data, timestamp: timestamp, priority: priority, executionEffort: executionEffort, fees: <-fees)\n        }\n\n        /// Schedule a transaction and store it in the manager's dictionary\n        /// @param handlerCap: A capability to a resource that implements the TransactionHandler interface\n        /// @param data: Optional data to pass to the transaction when executed\n        /// @param timestamp: The timestamp when the transaction should be executed\n        /// @param priority: The priority of the transaction (High, Medium, or Low)\n        /// @param executionEffort: The execution effort for the transaction\n        /// @param fees: A FlowToken vault containing sufficient fees\n        /// @return: The ID of the scheduled transaction\n        access(Owner) fun schedule(\n            handlerCap: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64 {\n            // Clean up any stale transactions before scheduling a new one\n            self.cleanup()\n\n            // Route to the main FlowTransactionScheduler\n            let scheduledTransaction <- FlowTransactionScheduler.schedule(\n                handlerCap: handlerCap,\n                data: data,\n                timestamp: timestamp,\n                priority: priority,\n                executionEffort: executionEffort,\n                fees: <-fees\n            )\n\n            // Store the handler capability in our dictionary for later retrieval\n            let id = scheduledTransaction.id\n            let actualTimestamp = scheduledTransaction.timestamp\n            let handlerRef = handlerCap.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n            let handlerTypeIdentifier = handlerRef.getType().identifier\n            let handlerUUID = handlerRef.uuid\n\n            self.handlerUUIDsByTransactionID[id] = handlerUUID\n\n            // Store the handler capability in the handlers dictionary for later retrieval\n            if self.handlerInfos[handlerTypeIdentifier] != nil {\n                let handlers = &self.handlerInfos[handlerTypeIdentifier]! as auth(Mutate) &{UInt64: HandlerInfo}\n                if let handlerInfo = handlers[handlerUUID] {\n                    handlerInfo.addTransactionID(id: id)\n                } else {\n                    let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                    handlerInfo.addTransactionID(id: id)\n                    handlers[handlerUUID] = handlerInfo\n                }\n            } else {\n                let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                handlerInfo.addTransactionID(id: id)\n                let uuidDictionary: {UInt64: HandlerInfo} = {handlerUUID: handlerInfo}\n                self.handlerInfos[handlerTypeIdentifier] = uuidDictionary\n            }\n\n            // Store the transaction in the transactions dictionary\n            self.scheduledTransactions[scheduledTransaction.id] <-! scheduledTransaction\n\n            // Add the transaction to the sorted timestamps array\n            self.sortedTimestamps.add(timestamp: actualTimestamp)\n\n            // Store the transaction in the ids by timestamp dictionary\n            if self.idsByTimestamp[actualTimestamp] != nil {\n                let ids = &self.idsByTimestamp[actualTimestamp]! as auth(Mutate) &[UInt64]\n                ids.append(id)\n            } else {\n                self.idsByTimestamp[actualTimestamp] = [id]\n            }\n\n            return id\n        }\n\n        /// Cancel a scheduled transaction by its ID\n        /// @param id: The ID of the transaction to cancel\n        /// @return: A FlowToken vault containing the refunded fees\n        access(Owner) fun cancel(id: UInt64): @FlowToken.Vault {\n            // Remove the transaction from the transactions dictionary\n            let tx <- self.scheduledTransactions.remove(key: id)\n                ?? panic(\"Invalid ID: Transaction with ID \\(id) not found in manager\")\n\n            self.removeID(id: id, timestamp: tx.timestamp, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n\n            // Cancel the transaction through the main scheduler\n            let refundedFees <- FlowTransactionScheduler.cancel(scheduledTx: <-tx!)\n\n            return <-refundedFees\n        }\n\n        /// Remove an ID from the manager's fields\n        /// @param id: The ID of the transaction to remove\n        /// @param timestamp: The timestamp of the transaction to remove\n        /// @param handlerTypeIdentifier: The type identifier of the handler of the transaction to remove\n        access(self) fun removeID(id: UInt64, timestamp: UFix64, handlerTypeIdentifier: String) {\n            pre {\n                self.handlerInfos.containsKey(handlerTypeIdentifier): \"Invalid handler type identifier: Handler with type identifier \\(handlerTypeIdentifier) not found in manager\"\n            }\n\n            if self.idsByTimestamp.containsKey(timestamp) {\n                let ids = &self.idsByTimestamp[timestamp]! as auth(Mutate) &[UInt64]\n                let index = ids.firstIndex(of: id)\n                ids.remove(at: index!)\n                if ids.length == 0 {\n                    self.idsByTimestamp.remove(key: timestamp)\n                    self.sortedTimestamps.remove(timestamp: timestamp)\n                }\n            }\n\n            if let handlerUUID = self.handlerUUIDsByTransactionID.remove(key: id) {\n                // Remove the transaction ID from the handler info array\n                let handlers = &self.handlerInfos[handlerTypeIdentifier]! as auth(Mutate) &{UInt64: HandlerInfo}\n                if let handlerInfo = handlers[handlerUUID] {\n                    handlerInfo.removeTransactionID(id: id)\n                }\n            }\n        }\n\n        /// Clean up transactions that are no longer valid (return nil or Unknown status)\n        /// This removes and destroys transactions that have been executed, canceled, or are otherwise invalid\n        /// @return: The transactions that were cleaned up (removed from the manager)\n        access(Owner) fun cleanup(): [UInt64] {\n            let currentTimestamp = getCurrentBlock().timestamp\n            var transactionsToRemove: {UInt64: UFix64} = {}\n\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n            for timestamp in pastTimestamps {\n                let ids = self.idsByTimestamp[timestamp] ?? []\n                if ids.length == 0 {\n                    self.sortedTimestamps.remove(timestamp: timestamp)\n                    continue\n                }\n                for id in ids {\n                    let status = FlowTransactionScheduler.getStatus(id: id)\n                    if status == nil || status! != FlowTransactionScheduler.Status.Scheduled {\n                        transactionsToRemove[id] = timestamp\n                        // Need to temporarily limit the number of transactions to remove\n                        // because some managers on mainnet have already hit the limit and we need to batch them\n                        // to make sure they get cleaned up properly\n                        // This will be removed eventually\n                        if transactionsToRemove.length > 50 {\n                            break\n                        }\n                    }\n                }\n            }\n\n            // Then remove and destroy the identified transactions\n            for id in transactionsToRemove.keys {\n                if let tx <- self.scheduledTransactions.remove(key: id) {\n                    self.removeID(id: id, timestamp: transactionsToRemove[id]!, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n                    destroy tx\n                }\n            }\n\n            return transactionsToRemove.keys\n        }\n\n        /// Remove a handler capability from the manager\n        /// The specified handler must not have any transactions scheduled for it\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler\n        access(Owner) fun removeHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?) {\n            // Make sure the handler exists\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                var id = handlerUUID\n                // If no UUID is provided, there must be only one handler of the type\n                if handlerUUID == nil {\n                    if handlers.keys.length > 1 {\n                        // No-op if we don't know which UUID to remove\n                        return\n                    } else if handlers.keys.length == 0 {\n                        self.handlerInfos.remove(key: handlerTypeIdentifier)\n                        return\n                    }\n                    id = handlers.keys[0]\n                }\n                // Make sure the handler has no transactions scheduled for it\n                if let handlerInfo = handlers[id!] {\n                    if handlerInfo.transactionIDs.length > 0 {\n                        return\n                    }\n                }\n                // Remove the handler uuid from the handlers dictionary\n                handlers.remove(key: id!)\n\n                // If there are no more handlers of the type, remove the type from the handlers dictionary\n                if handlers.keys.length == 0 {\n                    self.handlerInfos.remove(key: handlerTypeIdentifier)\n                } else {\n                    self.handlerInfos[handlerTypeIdentifier] = handlers\n                }\n            }\n        }\n\n        /// Get transaction data by its ID\n        /// @param id: The ID of the transaction to retrieve\n        /// @return: The transaction data from FlowTransactionScheduler, or nil if not found\n        access(all) view fun getTransactionData(_ id: UInt64): FlowTransactionScheduler.TransactionData? {\n            if self.scheduledTransactions.containsKey(id) {\n                return FlowTransactionScheduler.getTransactionData(id: id)\n            }\n            return nil\n        }\n\n        /// Get an un-entitled reference to a transaction handler of a given ID\n        /// @param id: The ID of the transaction to retrieve\n        /// @return: A reference to the transaction handler, or nil if not found\n        access(all) view fun borrowTransactionHandlerForID(_ id: UInt64): &{FlowTransactionScheduler.TransactionHandler}? {\n            let txData = self.getTransactionData(id)\n            return txData?.borrowHandler()\n        }\n\n        /// Get all the handler type identifiers that the manager has scheduled transactions for\n        /// @return: A dictionary of all handler type identifiers and their UUIDs\n        access(all) fun getHandlerTypeIdentifiers(): {String: [UInt64]} {\n            var handlerTypeIdentifiers: {String: [UInt64]} = {}\n            for handlerTypeIdentifier in self.handlerInfos.keys {\n                let handlerUUIDs: [UInt64] = []\n                let handlerTypes = self.handlerInfos[handlerTypeIdentifier]!\n                for uuid in handlerTypes.keys {\n                    let handlerInfo = handlerTypes[uuid]!\n                    if !handlerInfo.capability.check() {\n                        continue\n                    }\n                    handlerUUIDs.append(uuid)\n                }\n                handlerTypeIdentifiers[handlerTypeIdentifier] = handlerUUIDs\n            }\n            return handlerTypeIdentifiers\n        }\n\n        /// Get an un-entitled reference to a handler by a given type identifier\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @return: An un-entitled reference to the handler, or nil if not found\n        access(all) view fun borrowHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): &{FlowTransactionScheduler.TransactionHandler}? {\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if handlerUUID != nil {\n                    if let handlerInfo = handlers[handlerUUID!] {\n                        return handlerInfo.borrow()\n                    } \n                } else if handlers.keys.length == 1 {\n                    // If no uuid is provided, we can just default to the only handler uuid\n                    return handlers[handlers.keys[0]]!.borrow()\n                }\n            }\n            return nil\n        }\n\n        /// Get all the views that a handler implements\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @return: An array of all views\n        access(all) fun getHandlerViews(handlerTypeIdentifier: String, handlerUUID: UInt64?): [Type] {\n            if let handler = self.borrowHandler(handlerTypeIdentifier: handlerTypeIdentifier, handlerUUID: handlerUUID) {\n                return handler.getViews()\n            }\n            return []\n        }\n\n        /// Resolve a view for a handler by a given type identifier\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @param viewType: The type of the view to resolve\n        /// @return: The resolved view, or nil if not found\n        access(all) fun resolveHandlerView(handlerTypeIdentifier: String, handlerUUID: UInt64?, viewType: Type): AnyStruct? {\n            if let handler = self.borrowHandler(handlerTypeIdentifier: handlerTypeIdentifier, handlerUUID: handlerUUID) {\n                return handler.resolveView(viewType)\n            }\n            return nil\n        }\n\n        /// Get all the views that a handler implements from a given transaction ID\n        /// @param transactionId: The ID of the transaction\n        /// @return: An array of all views\n        access(all) fun getHandlerViewsFromTransactionID(_ id: UInt64): [Type] {\n            if let handler = self.borrowTransactionHandlerForID(id) {\n                return handler.getViews()\n            }\n            return []\n        }\n\n        /// Resolve a view for a handler from a given transaction ID\n        /// @param transactionId: The ID of the transaction\n        /// @param viewType: The type of the view to resolve\n        /// @return: The resolved view, or nil if not found\n        access(all) fun resolveHandlerViewFromTransactionID(_ id: UInt64, viewType: Type): AnyStruct? {\n            if let handler = self.borrowTransactionHandlerForID(id) {\n                return handler.resolveView(viewType)\n            }\n            return nil\n        }\n\n        /// Get all transaction IDs stored in the manager\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDs(): [UInt64] {\n            return self.scheduledTransactions.keys\n        }\n\n        /// Get all transaction IDs stored in the manager by a given handler\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDsByHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): [UInt64] {\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if handlerUUID != nil {\n                    if let handlerInfo = handlers[handlerUUID!] {\n                        return handlerInfo.transactionIDs\n                    } \n                } else if handlers.keys.length == 1 {\n                    // If no uuid is provided, we can just default to the only handler uuid\n                    return handlers[handlers.keys[0]]!.transactionIDs\n                }\n            }\n            return []\n        }\n\n        /// Get all transaction IDs stored in the manager by a given timestamp\n        /// @param timestamp: The timestamp\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64] {\n            return self.idsByTimestamp[timestamp] ?? []\n        }\n\n        /// Get all the timestamps and IDs from a given range of timestamps\n        /// @param startTimestamp: The start timestamp\n        /// @param endTimestamp: The end timestamp\n        /// @return: A dictionary of timestamps and IDs\n        access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]} {\n            var transactionsInTimeframe: {UFix64: [UInt64]} = {}\n            \n            // Validate input parameters\n            if startTimestamp > endTimestamp {\n                return transactionsInTimeframe\n            }\n            \n            // Get all timestamps that fall within the specified range\n            let allTimestampsBeforeEnd = self.sortedTimestamps.getBefore(current: endTimestamp)\n            \n            for timestamp in allTimestampsBeforeEnd {\n                // Check if this timestamp falls within our range\n                if timestamp < startTimestamp { continue }\n                \n                var timestampTransactions: [UInt64] = self.idsByTimestamp[timestamp] ?? []\n                \n                if timestampTransactions.length > 0 {\n                    transactionsInTimeframe[timestamp] = timestampTransactions\n                }\n            }\n            \n            return transactionsInTimeframe\n        }\n\n        /// Get the status of a transaction by its ID\n        /// @param id: The ID of the transaction\n        /// @return: The status of the transaction, or Status.Unknown if not found in manager\n        access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status? {\n            if self.scheduledTransactions.containsKey(id) {\n                return FlowTransactionScheduler.getStatus(id: id)\n            }\n            return FlowTransactionScheduler.Status.Unknown\n        }\n\n        /// Gets the sorted timestamps struct\n        /// @return: The sorted timestamps struct\n        access(all) view fun getSortedTimestamps(): FlowTransactionScheduler.SortedTimestamps {\n            return self.sortedTimestamps\n        }\n    }\n\n    /// Create a new Manager instance\n    /// @return: A new Manager resource\n    access(all) fun createManager(): @{Manager} {\n        return <-create ManagerV1()\n    }\n\n    access(all) init() {\n        self.managerStoragePath = /storage/flowTransactionSchedulerManager\n        self.managerPublicPath = /public/flowTransactionSchedulerManager\n    }\n\n    /// Get a public reference to a manager at the given address\n    /// @param address: The address of the manager\n    /// @return: A public reference to the manager\n    access(all) view fun borrowManager(at: Address): &{Manager}? {\n        return getAccount(at).capabilities.borrow<&{Manager}>(self.managerPublicPath)\n    }\n\n    /*********************************************\n    \n    COA Handler Utils\n\n    **********************************************/\n\n    access(all) event COAHandlerExecutionError(id: UInt64, owner: Address?, coaAddress: String?, errorMessage: String)\n\n    access(all) view fun coaHandlerStoragePath(): StoragePath {\n        return /storage/coaScheduledTransactionHandler\n    }\n\n    access(all) view fun coaHandlerPublicPath(): PublicPath {\n        return /public/coaScheduledTransactionHandler\n    }\n\n    /// COATransactionHandler is a resource that wraps a capability to a COA (Cadence Owned Account)\n    /// and implements the TransactionHandler interface to allow scheduling transactions for COAs.\n    /// This handler enables users to schedule transactions that will be executed on behalf of their COA.\n    access(all) resource COATransactionHandler: FlowTransactionScheduler.TransactionHandler {\n        /// The capability to the COA resource\n        access(self) let coaCapability: Capability<auth(EVM.Owner) &EVM.CadenceOwnedAccount>\n\n        /// The capability to the FlowToken vault\n        access(self) let flowTokenVaultCapability: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>\n\n        init(coaCapability: Capability<auth(EVM.Owner) &EVM.CadenceOwnedAccount>,\n             flowTokenVaultCapability: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>,\n        )\n        {\n            pre {\n                coaCapability.check(): \"COA capability is invalid or expired\"\n                flowTokenVaultCapability.check(): \"FlowToken vault capability is invalid or expired\"\n            }\n            self.coaCapability = coaCapability\n            self.flowTokenVaultCapability = flowTokenVaultCapability\n        }\n\n        access(self) fun emitError(id: UInt64, errorMessage: String) {\n            let coa = self.coaCapability.borrow()!\n            emit COAHandlerExecutionError(id: id, owner: self.owner?.address, coaAddress: coa.address().toString(),\n                                          errorMessage: errorMessage)\n        }\n\n        /// Execute the scheduled transaction using the COA\n        /// @param id: The ID of the scheduled transaction\n        /// @param data: Optional data passed to the transaction execution. In this case, the data must be a COAHandlerParams struct with valid values.\n        access(FlowTransactionScheduler.Execute) fun executeTransaction(id: UInt64, data: AnyStruct?) {\n\n            // Borrow the COA capability\n            let coa = self.coaCapability.borrow()\n            if coa == nil {\n                emit COAHandlerExecutionError(id: id, owner: self.owner?.address ?? Address(0x0), coaAddress: nil,\n                                              errorMessage: \"COA capability is invalid or expired for scheduled transaction with ID \\(id)\")\n                return\n            }\n\n            // Parse the data into a list of COAHandlerParams\n            // If the data is a single COAHandlerParams struct, wrap it in a list\n            var params: [COAHandlerParams]? = data as? [COAHandlerParams]\n            if params == nil {\n                if let param = data as? COAHandlerParams {\n                    params = [param]\n                }\n            }\n\n            // Iterate through all the COA transactions and execute them all\n            // If revertOnFailure is true for a transaction and any part of it fails, the entire scheduled transaction will be reverted\n            // If not but a part of the transaction fails, an error event will be emitted but the scheduled transaction will continue to execute the next transaction\n            //\n            if let transactions = params {\n                for index, txParams in transactions {\n                    switch txParams.txType {\n                        case COAHandlerTxType.DepositFLOW:\n                            let vault = self.flowTokenVaultCapability.borrow()\n                            if vault == nil {\n                                if !txParams.revertOnFailure {\n                                    self.emitError(id: id, errorMessage: \"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n                                    continue\n                                } else {\n                                    panic(\"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n                                }\n                            }\n\n                            if txParams.amount! > vault!.balance && !txParams.revertOnFailure {\n                                self.emitError(id: id, errorMessage: \"Insufficient FLOW in FlowToken vault for deposit into COA for scheduled transaction with ID \\(id) and index \\(index)\")\n                                continue\n                            }\n\n                            // Deposit the FLOW into the COA vault. If there isn't enough FLOW in the vault,\n                            //the transaction will be reverted because we know revertOnFailure is true\n                            coa!.deposit(from: <-vault!.withdraw(amount: txParams.amount!) as! @FlowToken.Vault)\n                        case COAHandlerTxType.WithdrawFLOW:\n                            let vault = self.flowTokenVaultCapability.borrow()\n                            if vault == nil {\n                                if !txParams.revertOnFailure {\n                                    self.emitError(id: id, errorMessage: \"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n                                    continue\n                                } else {\n                                    panic(\"FlowToken vault capability is invalid or expired for scheduled transaction with ID \\(id) and index \\(index)\")\n                                }\n                            }\n\n                            let amount = EVM.Balance(attoflow: 0)\n                            amount.setFLOW(flow: txParams.amount!)\n\n                            if amount.attoflow > coa!.balance().attoflow && !txParams.revertOnFailure {\n                                self.emitError(id: id, errorMessage: \"Insufficient FLOW in COA vault for withdrawal from COA for scheduled transaction with ID \\(id) and index \\(index)\")\n                                continue\n                            }\n\n                            // Withdraw the FLOW from the COA vault. If there isn't enough FLOW in the COA,\n                            // the transaction will be reverted because we know revertOnFailure is true\n                            vault!.deposit(from: <-coa!.withdraw(balance: amount))\n                        case COAHandlerTxType.Call:\n                            let result = coa!.call(to: txParams.callToEVMAddress!, data: txParams.data!, gasLimit: txParams.gasLimit!, value: txParams.value!)\n\n                            if result.status != EVM.Status.successful {\n                                if !txParams.revertOnFailure {\n                                    self.emitError(id: id, errorMessage: \"EVM call failed for scheduled transaction with ID \\(id) and index \\(index) with error: \\(result.errorCode):\\(result.errorMessage)\")\n                                    continue\n                                } else {\n                                    panic(\"EVM call failed for scheduled transaction with ID \\(id) and index \\(index) with error: \\(result.errorCode):\\(result.errorMessage)\")\n                                }\n                            }\n                    }\n                }\n            } else {\n                self.emitError(id: id, errorMessage: \"Invalid scheduled transaction data type for COA handler execution for tx with ID \\(id)! Expected [FlowTransactionSchedulerUtils.COAHandlerParams] but got \\(data.getType().identifier)\")\n                return\n            }\n        }\n\n        /// Get the views supported by this handler\n        /// @return: Array of view types\n        access(all) view fun getViews(): [Type] {\n            return [\n                Type<COAHandlerView>(),\n                Type<StoragePath>(),\n                Type<PublicPath>(),\n                Type<MetadataViews.Display>()\n            ]\n        }\n\n        /// Resolve a view for this handler\n        /// @param viewType: The type of view to resolve\n        /// @return: The resolved view data, or nil if not supported\n        access(all) fun resolveView(_ viewType: Type): AnyStruct? {\n            if viewType == Type<COAHandlerView>() {\n                return COAHandlerView(\n                    coaOwner: self.coaCapability.borrow()?.owner?.address,\n                    coaEVMAddress: self.coaCapability.borrow()?.address(),\n                    coaBalance: self.coaCapability.borrow()?.balance(),\n                )\n            }\n            if viewType == Type<StoragePath>() {\n                return FlowTransactionSchedulerUtils.coaHandlerStoragePath()\n            } else if viewType == Type<PublicPath>() {\n                return FlowTransactionSchedulerUtils.coaHandlerPublicPath()\n            } else if viewType == Type<MetadataViews.Display>() {\n                return MetadataViews.Display(\n                    name: \"COA Scheduled Transaction Handler\",\n                    description: \"Scheduled Transaction Handler that can execute transactions on behalf of a COA\",\n                    thumbnail: MetadataViews.HTTPFile(\n                        url: \"\"\n                    )\n                )\n            }\n            return nil\n        }\n    }\n\n    /// Enum for COA handler execution type\n    access(all) enum COAHandlerTxType: UInt8 {\n        access(all) case DepositFLOW\n        access(all) case WithdrawFLOW\n        access(all) case Call\n\n        // TODO: Should we have other transaction types??\n    }\n\n    access(all) struct COAHandlerParams {\n\n        /// The type of transaction to execute\n        access(all) let txType: COAHandlerTxType\n\n        /// Indicates if the whole set of scheduled transactions should be reverted\n        /// if this one transaction fails to execute in EVM\n        access(all) let revertOnFailure: Bool\n\n        /// The amount of FLOW to deposit or withdraw\n        /// Not required for the Call transaction type\n        access(all) let amount: UFix64?\n\n        /// The following fields are only required for the Call transaction type\n        access(all) let callToEVMAddress: EVM.EVMAddress?\n        access(all) let data: [UInt8]?\n        access(all) let gasLimit: UInt64?\n        access(all) let value: EVM.Balance?\n\n        init(txType: UInt8, revertOnFailure: Bool, amount: UFix64?, callToEVMAddress: String?, data: [UInt8]?, gasLimit: UInt64?, value: UInt?) {\n            self.txType = COAHandlerTxType(rawValue: txType)\n                ?? panic(\"Invalid COA transaction type enum\")\n            self.revertOnFailure = revertOnFailure\n            if self.txType == COAHandlerTxType.DepositFLOW {\n                assert(amount != nil, message: \"Amount is required for deposit but was not provided\")\n            }\n            if self.txType == COAHandlerTxType.WithdrawFLOW {\n                assert(amount != nil, message: \"Amount is required for withdrawal but was not provided\")\n            }\n            if self.txType == COAHandlerTxType.Call {\n                assert(callToEVMAddress != nil, message: \"Call to EVM address is required for EVM call but was not provided\")\n                assert((data != nil && value != nil) || (data == nil ? value != nil : true), message: \"Data and/or value are required for EVM call but neither were provided\")\n                assert(gasLimit != nil, message: \"Gas limit is required for EVM call but was not provided\")\n            }\n            self.amount = amount\n            if callToEVMAddress != nil {\n                self.callToEVMAddress = EVM.addressFromString(callToEVMAddress!)\n            } else {\n                self.callToEVMAddress = nil\n            }\n            if data != nil {\n                self.data = data\n            } else {\n                self.data = []\n            }\n            self.gasLimit = gasLimit\n            if let unwrappedValue = value {\n                self.value = EVM.Balance(attoflow: unwrappedValue)\n            } else {\n                self.value = nil\n            }\n        }\n    }\n\n    /// View struct for COA handler metadata\n    access(all) struct COAHandlerView {\n        access(all) let coaOwner: Address?\n        access(all) let coaEVMAddress: EVM.EVMAddress?\n\n        access(all) let coaBalance: EVM.Balance?\n\n        init(coaOwner: Address?, coaEVMAddress: EVM.EVMAddress?, coaBalance: EVM.Balance?) {\n            self.coaOwner = coaOwner\n            self.coaEVMAddress = coaEVMAddress\n            self.coaBalance = coaBalance\n        }\n    }\n\n    /// Create a COA transaction handler\n    /// @param coaCapability: Capability to the COA resource\n    /// @param flowTokenVaultCapability: Capability to the FlowToken vault\n    /// @return: A new COATransactionHandler resource\n    access(all) fun createCOATransactionHandler(\n        coaCapability: Capability<auth(EVM.Owner) &EVM.CadenceOwnedAccount>,\n        flowTokenVaultCapability: Capability<auth(FungibleToken.Withdraw) &FlowToken.Vault>,\n    ): @COATransactionHandler {\n        return <-create COATransactionHandler(\n            coaCapability: coaCapability,\n            flowTokenVaultCapability: flowTokenVaultCapability,\n        )\n    }\n\n    /********************************************\n    \n    Scheduled Transactions Metadata Views\n    \n    ***********************************************/\n\n}",
      "valid_from": 138787575,
      "valid_to": null,
      "created_at": "2026-01-13T23:09:53.113Z",
      "deployments": 3,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 5,
      "tags": null
    },
    {
      "name": "FlowTransactionScheduler",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowTransactionScheduler/131028293",
      "id": "A.e467b9dd11fa00df.FlowTransactionScheduler/138786558",
      "identifier": "A.e467b9dd11fa00df.FlowTransactionScheduler",
      "transaction_hash": "bf50d8b9e89658f420d7398623c5369115b542505d7a0c97c37775c27ff36d95",
      "status": "ok",
      "diff": "--- 077522dd3aabe1fe9f98960a9c66433fce0aef2cb0a253b2841ae3df4b256b2a.131028293\n+++ bf50d8b9e89658f420d7398623c5369115b542505d7a0c97c37775c27ff36d95.138786558\n@@ -217,6 +217,8 @@\n         access(all) let handlerAddress: Address\n \n         /// Optional data that can be passed to the handler\n+        /// This data is publicly accessible, so make sure it does not contain\n+        /// any privileged information or functionality\n         access(contract) let data: AnyStruct?\n \n         access(contract) init(\n@@ -289,7 +291,7 @@\n         }\n \n         /// getData copies and returns the data field\n-        access(contract) view fun getData(): AnyStruct? {\n+        access(all) view fun getData(): AnyStruct? {\n             return self.data\n         }\n \n@@ -458,28 +460,41 @@\n             self.timestamps = []\n         }\n \n+        /// bisect is a function that finds the index to insert a new timestamp in the sorted array.\n+        /// taken from bisect_right in pthon https://stackoverflow.com/questions/2945017/javas-equivalent-to-bisect-in-python\n+        /// @param new: The new timestamp to insert\n+        /// @return: The index to insert the new timestamp at or nil if the timestamp is already in the array\n+\t\taccess(all) fun bisect(new: UFix64): Int? {\n+\t\t\tvar high = self.timestamps.length\n+\t\t\tvar low = 0\n+\t\t\twhile low < high {\n+\t\t\t\tlet mid = (low+high)/2\n+\t\t\t\tlet midTimestamp = self.timestamps[mid]\n+\n+\t\t\t\tif midTimestamp == new {\n+                    return nil\n+                } else if midTimestamp > new {\n+\t\t\t\t\thigh = mid\n+\t\t\t\t} else {\n+\t\t\t\t\tlow = mid + 1\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn low\n+\t\t}\n+\n         /// Add a timestamp to the sorted array maintaining sorted order\n         access(all) fun add(timestamp: UFix64) {\n-\n-            var insertIndex = 0\n-            for i, ts in self.timestamps {\n-                if timestamp < ts {\n-                    insertIndex = i\n-                    break\n-                } else if timestamp == ts {\n-                    return\n-                }\n-                insertIndex = i + 1\n+            // Only insert if the timestamp is not already in the array\n+            if let insertIndex = self.bisect(new: timestamp) {\n+                self.timestamps.insert(at: insertIndex, timestamp)\n             }\n-            self.timestamps.insert(at: insertIndex, timestamp)\n         }\n \n         /// Remove a timestamp from the sorted array\n         access(all) fun remove(timestamp: UFix64) {\n-\n-            let index = self.timestamps.firstIndex(of: timestamp)\n-            if index != nil {\n-                self.timestamps.remove(at: index!)\n+            // Only remove if the timestamp is in the array\n+            if let index = self.timestamps.firstIndex(of: timestamp) {\n+                self.timestamps.remove(at: index)\n             }\n         }\n \n@@ -690,8 +698,11 @@\n \n             // Calculate the FLOW required to pay for storage of the transaction data\n             let storageFee = FlowStorageFees.storageCapacityToFlow(dataSizeMB)\n-            \n-            return scaledExecutionFee + storageFee\n+\n+            // Add inclusion Flow fee for scheduled transactions\n+            let inclusionFee = 0.00001\n+\n+            return scaledExecutionFee + storageFee + inclusionFee\n         }\n \n         /// getNextIDAndIncrement returns the next ID and increments the ID counter\n@@ -927,39 +938,43 @@\n             executionEffort: UInt64\n         ): UFix64? {\n \n-            let used = self.slotUsedEffort[timestamp]\n-            // if nothing is scheduled at this timestamp, we can schedule at provided timestamp\n-            if used == nil { \n-                return timestamp\n+            var timestampToSearch = timestamp\n+\n+            // If no available timestamps are found, this will eventually reach the gas limit and fail\n+            // This is extremely unlikely\n+            while true {\n+\n+                let used = self.slotUsedEffort[timestampToSearch]\n+                // if nothing is scheduled at this timestamp, we can schedule at provided timestamp\n+                if used == nil { \n+                    return timestampToSearch\n+                }\n+                \n+                let available = self.getSlotAvailableEffort(sanitizedTimestamp: timestampToSearch, priority: priority)\n+                // if theres enough space, we can tentatively schedule at provided timestamp\n+                if executionEffort <= available {\n+                    return timestampToSearch\n+                }\n+                \n+                if priority == Priority.High {\n+                    // high priority demands scheduling at exact timestamp or failing\n+                    return nil\n+                }\n+\n+                timestampToSearch = timestampToSearch + 1.0\n             }\n-            \n-            let available = self.getSlotAvailableEffort(timestamp: timestamp, priority: priority)\n-            // if theres enough space, we can tentatively schedule at provided timestamp\n-            if executionEffort <= available {\n-                return timestamp\n-            }\n-            \n-            if priority == Priority.High {\n-                // high priority demands scheduling at exact timestamp or failing\n-                return nil\n-            }\n \n-            // if there is no space left for medium or low priority we search for next available timestamp\n-            // todo: check how big the callstack can grow and if we should avoid recursion\n-            // todo: we should refactor this into loops, because we could need to recurse 100s of times\n-            return self.calculateScheduledTimestamp(\n-                timestamp: timestamp + 1.0, \n-                priority: priority, \n-                executionEffort: executionEffort\n-            )\n+            // should never happen\n+            return nil\n         }\n \n         /// slot available effort returns the amount of effort that is available for a given timestamp and priority.\n-        access(contract) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n+        /// @param sanitizedTimestamp: The timestamp to get the available effort for. It should already have been sanitized\n+        ///                            in the calling function\n+        /// @param priority: The priority to get the available effort for\n+        /// @return UInt64: The amount of effort that is available for the given timestamp and priority\n+        access(contract) view fun getSlotAvailableEffort(sanitizedTimestamp: UFix64, priority: Priority): UInt64 {\n \n-            // Remove fractional values from the timestamp\n-            let sanitizedTimestamp = UFix64(UInt64(timestamp))\n-\n             // Get the theoretical maximum allowed for the priority including shared\n             let priorityLimit = self.config.priorityEffortLimit[priority]!\n             \n@@ -971,12 +980,8 @@\n \n             // Get the mapping of how much effort has been used\n             // for each priority for the timestamp\n-            let slotPriorityEffortsUsed = self.slotUsedEffort[sanitizedTimestamp]!\n+            let slotPriorityEffortsUsed = &self.slotUsedEffort[sanitizedTimestamp]! as &{Priority: UInt64}\n \n-            // Get the exclusive reserves for each priority\n-            let highReserve = self.config.priorityEffortReserve[Priority.High]!\n-            let mediumReserve = self.config.priorityEffortReserve[Priority.Medium]!\n-\n             // Get how much effort has been used for each priority\n             let highUsed = slotPriorityEffortsUsed[Priority.High] ?? 0\n             let mediumUsed = slotPriorityEffortsUsed[Priority.Medium] ?? 0\n@@ -990,6 +994,10 @@\n                 let lowUsed = slotPriorityEffortsUsed[Priority.Low] ?? 0\n                 return lowEffortRemaining.saturatingSubtract(lowUsed)\n             }\n+\n+            // Get the exclusive reserves for each priority\n+            let highReserve = self.config.priorityEffortReserve[Priority.High]!\n+            let mediumReserve = self.config.priorityEffortReserve[Priority.Medium]!\n             \n             // Get how much shared effort has been used for each priority\n             // Ensure the results are always zero or positive\n@@ -1032,33 +1040,34 @@\n             }\n \n             // Add this transaction id to the slot\n-            let slotQueue = self.slotQueue[slot]!\n-            if let priorityQueue = slotQueue[txData.priority] {\n+            let transactionsForSlot = self.slotQueue[slot]!\n+            if let priorityQueue = transactionsForSlot[txData.priority] {\n                 priorityQueue[txData.id] = txData.executionEffort\n-                slotQueue[txData.priority] = priorityQueue\n+                transactionsForSlot[txData.priority] = priorityQueue\n             } else {\n-                slotQueue[txData.priority] = {\n+                transactionsForSlot[txData.priority] = {\n                     txData.id: txData.executionEffort\n                 }\n             }\n+            self.slotQueue[slot] = transactionsForSlot\n \n-            self.slotQueue[slot] = slotQueue\n-\n             // Add the execution effort for this transaction to the total for the slot's priority\n-            let slotEfforts = self.slotUsedEffort[slot]!\n+            let slotEfforts = &self.slotUsedEffort[slot]! as auth(Mutate) &{Priority: UInt64}\n             var newPriorityEffort = slotEfforts[txData.priority]! + txData.executionEffort\n             slotEfforts[txData.priority] = newPriorityEffort\n             var newTotalEffort: UInt64 = 0\n             for priority in slotEfforts.keys {\n                 newTotalEffort = newTotalEffort.saturatingAdd(slotEfforts[priority]!)\n             }\n-            self.slotUsedEffort[slot] = slotEfforts\n+\n+            // Store the transaction in the transactions map\n+            self.transactions[txData.id] = txData\n             \n             // Need to potentially reschedule low priority transactions to make room for the new transaction\n             // Iterate through them and record which ones to reschedule until the total effort is less than the limit\n             let lowTransactionsToReschedule: [UInt64] = []\n             if newTotalEffort > self.config.slotTotalEffortLimit {\n-                let lowPriorityTransactions = slotQueue[Priority.Low]!\n+                let lowPriorityTransactions = transactionsForSlot[Priority.Low]!\n                 for id in lowPriorityTransactions.keys {\n                     if newTotalEffort <= self.config.slotTotalEffortLimit {\n                         break\n@@ -1068,9 +1059,6 @@\n                 }\n             }\n \n-            // Store the transaction in the transactions map\n-            self.transactions[txData.id] = txData\n-\n             // Reschedule low priority transactions if needed\n             self.rescheduleLowPriorityTransactions(slot: slot, transactions: lowTransactionsToReschedule)\n         }\n@@ -1106,9 +1094,8 @@\n                 let transactionData = self.removeTransaction(txData: tx!)\n \n                 // Subtract the execution effort for this transaction from the slot's priority\n-                let slotEfforts = self.slotUsedEffort[slot]!\n+                let slotEfforts = &self.slotUsedEffort[slot]! as auth(Mutate) &{Priority: UInt64}\n                 slotEfforts[Priority.Low] = slotEfforts[Priority.Low]!.saturatingSubtract(effort)\n-                self.slotUsedEffort[slot] = slotEfforts\n \n                 // Update the transaction's scheduled timestamp and add it back to the slot queue\n                 transactionData.setScheduledTimestamp(newTimestamp: newTimestamp)\n@@ -1127,26 +1113,24 @@\n             let transactionObject = self.transactions.remove(key: transactionID)!\n             \n             // garbage collect slots \n-            if let transactionQueue = self.slotQueue[slot] {\n+            let transactionQueue = self.slotQueue[slot]!\n \n-                if let priorityQueue = transactionQueue[transactionPriority] {\n-                    priorityQueue[transactionID] = nil\n-                    if priorityQueue.keys.length == 0 {\n-                        transactionQueue.remove(key: transactionPriority)\n-                    } else {\n-                        transactionQueue[transactionPriority] = priorityQueue\n-                    }\n-\n-                    self.slotQueue[slot] = transactionQueue\n+            if let priorityQueue = transactionQueue[transactionPriority] {\n+                priorityQueue[transactionID] = nil\n+                if priorityQueue.keys.length == 0 {\n+                    transactionQueue.remove(key: transactionPriority)\n+                } else {\n+                    transactionQueue[transactionPriority] = priorityQueue\n                 }\n+            }\n+            self.slotQueue[slot] = transactionQueue\n \n-                // if the slot is now empty remove it from the maps\n-                if transactionQueue.keys.length == 0 {\n-                    self.slotQueue.remove(key: slot)\n-                    self.slotUsedEffort.remove(key: slot)\n+            // if the slot is now empty remove it from the maps\n+            if transactionQueue.keys.length == 0 {\n+                self.slotQueue.remove(key: slot)\n+                self.slotUsedEffort.remove(key: slot)\n \n-                    self.sortedTimestamps.remove(timestamp: slot)\n-                }\n+                self.sortedTimestamps.remove(timestamp: slot)\n             }\n \n             return transactionObject\n@@ -1328,15 +1308,21 @@\n \n             // if the transaction was canceled, add it to the canceled transactions array\n             // maintain sorted order by inserting at the correct position\n-            var insertIndex = 0\n-            for i, canceledID in self.canceledTransactions {\n-                if id < canceledID {\n-                    insertIndex = i\n-                    break\n-                }\n-                insertIndex = i + 1\n-            }\n-            self.canceledTransactions.insert(at: insertIndex, id)\n+\t\t\tvar high = self.canceledTransactions.length\n+\t\t\tvar low = 0\n+\t\t\twhile low < high {\n+\t\t\t\tlet mid = (low+high)/2\n+\t\t\t\tlet midCanceledID = self.canceledTransactions[mid]\n+\n+\t\t\t\tif midCanceledID == id {\n+                    emit CriticalIssue(message: \"Invalid ID: \\(id) transaction already in canceled transactions array\")\n+                } else if midCanceledID > id {\n+\t\t\t\t\thigh = mid\n+\t\t\t\t} else {\n+\t\t\t\t\tlow = mid + 1\n+\t\t\t\t}\n+\t\t\t}\n+            self.canceledTransactions.insert(at: low, id)\n             \n             // keep the array under the limit\n             if UInt(self.canceledTransactions.length) > self.config.canceledTransactionsLimit {\n@@ -1439,6 +1425,17 @@\n             )\n     }\n \n+    /// Allows users to calculate the fee for a scheduled transaction without having to call the expensive estimate function\n+    /// @param executionEffort: The execution effort of the transaction\n+    /// @param priority: The priority of the transaction\n+    /// @param dataSizeMB: The size of the data to be stored with the scheduled transaction\n+    ///                    The user must calculate this data size themselves before calling this function\n+    ///                    But should be done in a separate script or transaction to avoid the expensive getSizeOfData function\n+    /// @return UFix64: The fee in Flow tokens that is required to pay for the transaction\n+    access(all) fun calculateFee(executionEffort: UInt64, priority: Priority, dataSizeMB: UFix64): UFix64 {\n+        return self.sharedScheduler.borrow()!.calculateFee(executionEffort: executionEffort, priority: priority, dataSizeMB: dataSizeMB)\n+    }\n+\n     access(all) fun cancel(scheduledTx: @ScheduledTransaction): @FlowToken.Vault {\n         let id = scheduledTx.id\n         destroy scheduledTx\n@@ -1482,7 +1479,9 @@\n     }\n \n     access(all) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n-        return self.sharedScheduler.borrow()!.getSlotAvailableEffort(timestamp: timestamp, priority: priority)\n+        // Remove fractional values from the timestamp\n+        let sanitizedTimestamp = UFix64(UInt64(timestamp))\n+        return self.sharedScheduler.borrow()!.getSlotAvailableEffort(sanitizedTimestamp: sanitizedTimestamp, priority: priority)\n     }\n \n     access(all) fun getConfig(): {SchedulerConfig} {\n",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowFees from 0xf919ee77447b7497\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport ViewResolver from 0x1d7e57aa55817448\n\n/// FlowTransactionScheduler enables smart contracts to schedule autonomous execution in the future.\n///\n/// This contract implements FLIP 330's scheduled transaction system, allowing contracts to \"wake up\" and execute\n/// logic at predefined times without external triggers. \n///\n/// Scheduled transactions are prioritized (High/Medium/Low) with different execution guarantees and fee multipliers: \n///   - High priority guarantees first-block execution,\n///   - Medium priority provides best-effort scheduling,\n///   - Low priority executes opportunistically when capacity allows after the time it was scheduled. \n///\n/// The system uses time slots with execution effort limits to manage network resources,\n/// ensuring predictable performance while enabling novel autonomous blockchain patterns like recurring\n/// payments, automated arbitrage, and time-based contract logic.\naccess(all) contract FlowTransactionScheduler {\n\n    /// singleton instance used to store all scheduled transaction data\n    /// and route all scheduled transaction functionality\n    access(self) var sharedScheduler: Capability<auth(Cancel) &SharedScheduler>\n\n    /// storage path for the singleton scheduler resource\n    access(all) let storagePath: StoragePath\n\n    /// Enums\n\n    /// Priority\n    access(all) enum Priority: UInt8 {\n        access(all) case High\n        access(all) case Medium\n        access(all) case Low\n    }\n\n    /// Status\n    access(all) enum Status: UInt8 {\n        /// unknown statuses are used for handling historic scheduled transactions with null statuses\n        access(all) case Unknown\n        /// mutable status\n        access(all) case Scheduled\n        /// finalized statuses\n        access(all) case Executed\n        access(all) case Canceled\n    }\n\n    /// Events\n\n    /// Emitted when a transaction is scheduled\n    access(all) event Scheduled(\n        id: UInt64,\n        priority: UInt8,\n        timestamp: UFix64,\n        executionEffort: UInt64,\n        fees: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String,\n        transactionHandlerUUID: UInt64,\n        \n        // The public path of the transaction handler that can be used to resolve views\n        // DISCLAIMER: There is no guarantee that the public path is accurate\n        transactionHandlerPublicPath: PublicPath?\n    )\n\n    /// Emitted when a scheduled transaction's scheduled timestamp is reached and it is ready for execution\n    access(all) event PendingExecution(\n        id: UInt64,\n        priority: UInt8,\n        executionEffort: UInt64,\n        fees: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String\n    )\n\n    /// Emitted when a scheduled transaction is executed by the FVM\n    access(all) event Executed(\n        id: UInt64,\n        priority: UInt8,\n        executionEffort: UInt64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String,\n        transactionHandlerUUID: UInt64,\n\n        // The public path of the transaction handler that can be used to resolve views\n        // DISCLAIMER: There is no guarantee that the public path is accurate\n        transactionHandlerPublicPath: PublicPath?\n    )\n\n    /// Emitted when a scheduled transaction is canceled by the creator of the transaction\n    access(all) event Canceled(\n        id: UInt64,\n        priority: UInt8,\n        feesReturned: UFix64,\n        feesDeducted: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String\n    )\n\n    /// Emitted when a collection limit is reached\n    /// The limit that was reached is non-nil and is the limit that was reached\n    /// The other limit that was not reached is nil\n    access(all) event CollectionLimitReached(\n        collectionEffortLimit: UInt64?,\n        collectionTransactionsLimit: Int?\n    )\n\n    /// Emitted when the limit on the number of transactions that can be removed in process() is reached\n    access(all) event RemovalLimitReached()\n\n    // Emitted when one or more of the configuration details fields are updated\n    // Event listeners can listen to this and query the new configuration\n    // if they need to\n    access(all) event ConfigUpdated()\n\n    // Emitted when a critical issue is encountered\n    access(all) event CriticalIssue(message: String)\n\n    /// Entitlements\n    access(all) entitlement Execute\n    access(all) entitlement Process\n    access(all) entitlement Cancel\n    access(all) entitlement UpdateConfig\n\n    /// Interfaces\n\n    /// TransactionHandler is an interface that defines a single method executeTransaction that \n    /// must be implemented by the resource that contains the logic to be executed by the scheduled transaction.\n    /// An authorized capability to this resource is provided when scheduling a transaction.\n    /// The transaction scheduler uses this capability to execute the transaction when its scheduled timestamp arrives.\n    access(all) resource interface TransactionHandler: ViewResolver.Resolver {\n\n        access(all) view fun getViews(): [Type] {\n            return []\n        }\n\n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            return nil\n        }\n\n        /// Executes the implemented transaction logic\n        ///\n        /// @param id: The id of the scheduled transaction (this can be useful for any internal tracking)\n        /// @param data: The data that was passed when the transaction was originally scheduled\n        /// that may be useful for the execution of the transaction logic\n        access(Execute) fun executeTransaction(id: UInt64, data: AnyStruct?)\n    }\n\n    /// Structs\n\n    /// ScheduledTransaction is the resource that the user receives after scheduling a transaction.\n    /// It allows them to get the status of their transaction and can be passed back\n    /// to the scheduler contract to cancel the transaction if it has not yet been executed. \n    access(all) resource ScheduledTransaction {\n        access(all) let id: UInt64\n        access(all) let timestamp: UFix64\n        access(all) let handlerTypeIdentifier: String\n\n        access(all) view fun status(): Status? {\n            return FlowTransactionScheduler.sharedScheduler.borrow()!.getStatus(id: self.id)\n        }\n\n        init(\n            id: UInt64, \n            timestamp: UFix64,\n            handlerTypeIdentifier: String\n        ) {\n            self.id = id\n            self.timestamp = timestamp\n            self.handlerTypeIdentifier = handlerTypeIdentifier\n        }\n\n        // event emitted when the resource is destroyed\n        access(all) event ResourceDestroyed(id: UInt64 = self.id, timestamp: UFix64 = self.timestamp, handlerTypeIdentifier: String = self.handlerTypeIdentifier)\n    }\n\n    /// EstimatedScheduledTransaction contains data for estimating transaction scheduling.\n    access(all) struct EstimatedScheduledTransaction {\n        /// flowFee is the estimated fee in Flow for the transaction to be scheduled\n        access(all) let flowFee: UFix64?\n        /// timestamp is estimated timestamp that the transaction will be executed at\n        access(all) let timestamp: UFix64?\n        /// error is an optional error message if the transaction cannot be scheduled\n        access(all) let error: String?\n\n        access(contract) view init(flowFee: UFix64?, timestamp: UFix64?, error: String?) {\n            self.flowFee = flowFee\n            self.timestamp = timestamp\n            self.error = error\n        }\n    }\n\n    /// Transaction data is a representation of a scheduled transaction\n    /// It is the source of truth for an individual transaction and stores the\n    /// capability to the handler that contains the logic that will be executed by the transaction.\n    access(all) struct TransactionData {\n        access(all) let id: UInt64\n        access(all) let priority: Priority\n        access(all) let executionEffort: UInt64\n        access(all) var status: Status\n\n        /// Fee amount to pay for the transaction\n        access(all) let fees: UFix64\n\n        /// The timestamp that the transaction is scheduled for\n        /// For medium priority transactions, it may be different than the requested timestamp\n        /// For low priority transactions, it is the requested timestamp,\n        /// but the timestamp where the transaction is actually executed may be different\n        access(all) var scheduledTimestamp: UFix64\n\n        /// Capability to the logic that the transaction will execute\n        access(contract) let handler: Capability<auth(Execute) &{TransactionHandler}>\n\n        /// Type identifier of the transaction handler\n        access(all) let handlerTypeIdentifier: String\n        access(all) let handlerAddress: Address\n\n        /// Optional data that can be passed to the handler\n        /// This data is publicly accessible, so make sure it does not contain\n        /// any privileged information or functionality\n        access(contract) let data: AnyStruct?\n\n        access(contract) init(\n            id: UInt64,\n            handler: Capability<auth(Execute) &{TransactionHandler}>,\n            scheduledTimestamp: UFix64,\n            data: AnyStruct?,\n            priority: Priority,\n            executionEffort: UInt64,\n            fees: UFix64,\n        ) {\n            self.id = id\n            self.handler = handler\n            self.data = data\n            self.priority = priority\n            self.executionEffort = executionEffort\n            self.fees = fees\n            self.status = Status.Scheduled\n            let handlerRef = handler.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n            self.handlerAddress = handler.address\n            self.handlerTypeIdentifier = handlerRef.getType().identifier\n            self.scheduledTimestamp = scheduledTimestamp\n        }\n\n        /// setStatus updates the status of the transaction.\n        /// It panics if the transaction status is already finalized.\n        access(contract) fun setStatus(newStatus: Status) {\n            pre {\n                newStatus != Status.Unknown: \"Invalid status: New status cannot be Unknown\"\n                self.status != Status.Executed && self.status != Status.Canceled:\n                    \"Invalid status: Transaction with id \\(self.id) is already finalized\"\n                newStatus == Status.Executed ? self.status == Status.Scheduled : true:\n                    \"Invalid status: Transaction with id \\(self.id) can only be set as Executed if it is Scheduled\"\n                newStatus == Status.Canceled ? self.status == Status.Scheduled : true:\n                    \"Invalid status: Transaction with id \\(self.id) can only be set as Canceled if it is Scheduled\"\n            }\n\n            self.status = newStatus\n        }\n\n        /// setScheduledTimestamp updates the scheduled timestamp of the transaction.\n        /// It panics if the transaction status is already finalized.\n        access(contract) fun setScheduledTimestamp(newTimestamp: UFix64) {\n            pre {\n                self.status != Status.Executed && self.status != Status.Canceled:\n                    \"Invalid status: Transaction with id \\(self.id) is already finalized\"\n            }\n            self.scheduledTimestamp = newTimestamp\n        }\n\n        /// payAndRefundFees withdraws fees from the transaction based on the refund multiplier.\n        /// It deposits any leftover fees to the FlowFees vault to be used to pay node operator rewards\n        /// like any other transaction on the Flow network.\n        access(contract) fun payAndRefundFees(refundMultiplier: UFix64): @FlowToken.Vault {\n            pre {\n                refundMultiplier >= 0.0 && refundMultiplier <= 1.0:\n                    \"Invalid refund multiplier: The multiplier must be between 0.0 and 1.0 but got \\(refundMultiplier)\"\n            }\n            if refundMultiplier == 0.0 {\n                FlowFees.deposit(from: <-FlowTransactionScheduler.withdrawFees(amount: self.fees))\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            } else {\n                let amountToReturn = self.fees * refundMultiplier\n                let amountToKeep = self.fees - amountToReturn\n                let feesToReturn <- FlowTransactionScheduler.withdrawFees(amount: amountToReturn)\n                FlowFees.deposit(from: <-FlowTransactionScheduler.withdrawFees(amount: amountToKeep))\n                return <-feesToReturn\n            }\n        }\n\n        /// getData copies and returns the data field\n        access(all) view fun getData(): AnyStruct? {\n            return self.data\n        }\n\n        /// borrowHandler returns an un-entitled reference to the transaction handler\n        /// This allows users to query metadata views about the handler\n        /// @return: An un-entitled reference to the transaction handler\n        access(all) view fun borrowHandler(): &{TransactionHandler} {\n            return self.handler.borrow() as? &{TransactionHandler}\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n        }\n    }\n\n    /// Struct interface representing all the base configuration details in the Scheduler contract\n    /// that is used for governing the protocol\n    /// This is an interface to allow for the configuration details to be updated in the future\n    access(all) struct interface SchedulerConfig {\n\n        /// maximum effort that can be used for any transaction\n        access(all) var maximumIndividualEffort: UInt64\n\n        /// minimum execution effort is the minimum effort that can be \n        /// used for any transaction\n        access(all) var minimumExecutionEffort: UInt64\n\n        /// slot total effort limit is the maximum effort that can be \n        /// cumulatively allocated to one timeslot by all priorities\n        access(all) var slotTotalEffortLimit: UInt64\n\n        /// slot shared effort limit is the maximum effort \n        /// that can be allocated to high and medium priority \n        /// transactions combined after their exclusive effort reserves have been filled\n        access(all) var slotSharedEffortLimit: UInt64\n\n        /// priority effort reserve is the amount of effort that is \n        /// reserved exclusively for each priority\n        access(all) var priorityEffortReserve: {Priority: UInt64}\n\n        /// priority effort limit is the maximum cumulative effort per priority in a timeslot\n        access(all) var priorityEffortLimit: {Priority: UInt64}\n\n        /// max data size is the maximum data size that can be stored for a transaction\n        access(all) var maxDataSizeMB: UFix64\n\n        /// priority fee multipliers are values we use to calculate the added \n        /// processing fee for each priority\n        access(all) var priorityFeeMultipliers: {Priority: UFix64}\n\n        /// refund multiplier is the portion of the fees that are refunded when any transaction is cancelled\n        access(all) var refundMultiplier: UFix64\n\n        /// canceledTransactionsLimit is the maximum number of canceled transactions\n        /// to keep in the canceledTransactions array\n        access(all) var canceledTransactionsLimit: UInt\n\n        /// collectionEffortLimit is the maximum effort that can be used for all transactions in a collection\n        access(all) var collectionEffortLimit: UInt64\n\n        /// collectionTransactionsLimit is the maximum number of transactions that can be processed in a collection\n        access(all) var collectionTransactionsLimit: Int\n\n        access(all) init(\n            maximumIndividualEffort: UInt64,\n            minimumExecutionEffort: UInt64,\n            slotSharedEffortLimit: UInt64,\n            priorityEffortReserve: {Priority: UInt64},\n            lowPriorityEffortLimit: UInt64,\n            maxDataSizeMB: UFix64,\n            priorityFeeMultipliers: {Priority: UFix64},\n            refundMultiplier: UFix64,\n            canceledTransactionsLimit: UInt,\n            collectionEffortLimit: UInt64,\n            collectionTransactionsLimit: Int,\n            txRemovalLimit: UInt\n        ) {\n            post {\n                self.refundMultiplier >= 0.0 && self.refundMultiplier <= 1.0:\n                    \"Invalid refund multiplier: The multiplier must be between 0.0 and 1.0 but got \\(refundMultiplier)\"\n                self.priorityFeeMultipliers[Priority.Low]! >= 1.0:\n                    \"Invalid priority fee multiplier: Low priority multiplier must be greater than or equal to 1.0 but got \\(self.priorityFeeMultipliers[Priority.Low]!)\"\n                self.priorityFeeMultipliers[Priority.Medium]! > self.priorityFeeMultipliers[Priority.Low]!:\n                    \"Invalid priority fee multiplier: Medium priority multiplier must be greater than or equal to \\(priorityFeeMultipliers[Priority.Low]!) but got \\(priorityFeeMultipliers[Priority.Medium]!)\"\n                self.priorityFeeMultipliers[Priority.High]! > self.priorityFeeMultipliers[Priority.Medium]!:\n                    \"Invalid priority fee multiplier: High priority multiplier must be greater than or equal to \\(priorityFeeMultipliers[Priority.Medium]!) but got \\(priorityFeeMultipliers[Priority.High]!)\"\n                self.priorityEffortLimit[Priority.High]! >= self.priorityEffortReserve[Priority.High]!:\n                    \"Invalid priority effort limit: High priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.High]!)\"\n                self.priorityEffortLimit[Priority.Medium]! >= self.priorityEffortReserve[Priority.Medium]!:\n                    \"Invalid priority effort limit: Medium priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.Medium]!)\"\n                self.priorityEffortLimit[Priority.Low]! >= self.priorityEffortReserve[Priority.Low]!:\n                    \"Invalid priority effort limit: Low priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.Low]!)\"\n                self.priorityEffortReserve[Priority.Low]! == 0:\n                    \"Invalid priority effort reserve: Low priority effort reserve must be 0\"\n                self.collectionTransactionsLimit >= 0:\n                    \"Invalid collection transactions limit: Collection transactions limit must be greater than or equal to 0 but got \\(collectionTransactionsLimit)\"\n                self.canceledTransactionsLimit >= 1:\n                    \"Invalid canceled transactions limit: Canceled transactions limit must be greater than or equal to 1 but got \\(canceledTransactionsLimit)\"\n                self.collectionEffortLimit > self.slotTotalEffortLimit:\n                    \"Invalid collection effort limit: Collection effort limit must be greater than \\(self.slotTotalEffortLimit) but got \\(self.collectionEffortLimit)\"\n            }\n        }\n\n        access(all) view fun getTxRemovalLimit(): UInt\n    }\n\n    /// Concrete implementation of the SchedulerConfig interface\n    /// This struct is used to store the configuration details in the Scheduler contract\n    access(all) struct Config: SchedulerConfig {\n        access(all) var maximumIndividualEffort: UInt64\n        access(all) var minimumExecutionEffort: UInt64\n        access(all) var slotTotalEffortLimit: UInt64\n        access(all) var slotSharedEffortLimit: UInt64\n        access(all) var priorityEffortReserve: {Priority: UInt64}\n        access(all) var priorityEffortLimit: {Priority: UInt64}\n        access(all) var maxDataSizeMB: UFix64\n        access(all) var priorityFeeMultipliers: {Priority: UFix64}\n        access(all) var refundMultiplier: UFix64\n        access(all) var canceledTransactionsLimit: UInt\n        access(all) var collectionEffortLimit: UInt64\n        access(all) var collectionTransactionsLimit: Int\n\n        access(all) init(   \n            maximumIndividualEffort: UInt64,\n            minimumExecutionEffort: UInt64,\n            slotSharedEffortLimit: UInt64,\n            priorityEffortReserve: {Priority: UInt64},\n            lowPriorityEffortLimit: UInt64,\n            maxDataSizeMB: UFix64,\n            priorityFeeMultipliers: {Priority: UFix64},\n            refundMultiplier: UFix64,\n            canceledTransactionsLimit: UInt,\n            collectionEffortLimit: UInt64,\n            collectionTransactionsLimit: Int,\n            txRemovalLimit: UInt\n        ) {\n            self.maximumIndividualEffort = maximumIndividualEffort\n            self.minimumExecutionEffort = minimumExecutionEffort\n            self.slotTotalEffortLimit = slotSharedEffortLimit + priorityEffortReserve[Priority.High]! + priorityEffortReserve[Priority.Medium]!\n            self.slotSharedEffortLimit = slotSharedEffortLimit\n            self.priorityEffortReserve = priorityEffortReserve\n            self.priorityEffortLimit = {\n                Priority.High: priorityEffortReserve[Priority.High]! + slotSharedEffortLimit,\n                Priority.Medium: priorityEffortReserve[Priority.Medium]! + slotSharedEffortLimit,\n                Priority.Low: lowPriorityEffortLimit\n            }\n            self.maxDataSizeMB = maxDataSizeMB\n            self.priorityFeeMultipliers = priorityFeeMultipliers\n            self.refundMultiplier = refundMultiplier\n            self.canceledTransactionsLimit = canceledTransactionsLimit\n            self.collectionEffortLimit = collectionEffortLimit\n            self.collectionTransactionsLimit = collectionTransactionsLimit\n        }\n\n        access(all) view fun getTxRemovalLimit(): UInt {\n            return FlowTransactionScheduler.account.storage.copy<UInt>(from: /storage/txRemovalLimit)\n                ?? 200\n        }\n    }\n\n\n    /// SortedTimestamps maintains timestamps sorted in ascending order for efficient processing\n    /// It encapsulates all operations related to maintaining and querying sorted timestamps\n    access(all) struct SortedTimestamps {\n        /// Internal sorted array of timestamps\n        access(self) var timestamps: [UFix64]\n\n        access(all) init() {\n            self.timestamps = []\n        }\n\n        /// bisect is a function that finds the index to insert a new timestamp in the sorted array.\n        /// taken from bisect_right in pthon https://stackoverflow.com/questions/2945017/javas-equivalent-to-bisect-in-python\n        /// @param new: The new timestamp to insert\n        /// @return: The index to insert the new timestamp at or nil if the timestamp is already in the array\n\t\taccess(all) fun bisect(new: UFix64): Int? {\n\t\t\tvar high = self.timestamps.length\n\t\t\tvar low = 0\n\t\t\twhile low < high {\n\t\t\t\tlet mid = (low+high)/2\n\t\t\t\tlet midTimestamp = self.timestamps[mid]\n\n\t\t\t\tif midTimestamp == new {\n                    return nil\n                } else if midTimestamp > new {\n\t\t\t\t\thigh = mid\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn low\n\t\t}\n\n        /// Add a timestamp to the sorted array maintaining sorted order\n        access(all) fun add(timestamp: UFix64) {\n            // Only insert if the timestamp is not already in the array\n            if let insertIndex = self.bisect(new: timestamp) {\n                self.timestamps.insert(at: insertIndex, timestamp)\n            }\n        }\n\n        /// Remove a timestamp from the sorted array\n        access(all) fun remove(timestamp: UFix64) {\n            // Only remove if the timestamp is in the array\n            if let index = self.timestamps.firstIndex(of: timestamp) {\n                self.timestamps.remove(at: index)\n            }\n        }\n\n        /// Get all timestamps that are in the past (less than or equal to current timestamp)\n        access(all) fun getBefore(current: UFix64): [UFix64] {\n            let pastTimestamps: [UFix64] = []\n            for timestamp in self.timestamps {\n                if timestamp <= current {\n                    pastTimestamps.append(timestamp)\n                } else {\n                    break  // No need to check further since array is sorted\n                }\n            }\n            return pastTimestamps\n        }\n\n        /// Check if there are any timestamps that need processing\n        /// Returns true if processing is needed, false for early exit\n        access(all) fun hasBefore(current: UFix64): Bool {\n            return self.timestamps.length > 0 && self.timestamps[0] <= current\n        }\n\n        /// Get the whole array of timestamps\n        access(all) fun getAll(): [UFix64] {\n            return self.timestamps\n        }\n    }\n\n    /// Resources\n\n    /// Shared scheduler is a resource that is used as a singleton in the scheduler contract and contains \n    /// all the functionality to schedule, process and execute transactions as well as the internal state. \n    access(all) resource SharedScheduler {\n        /// nextID contains the next transaction ID to be assigned\n        /// This the ID is monotonically increasing and is used to identify each transaction\n        access(contract) var nextID: UInt64\n\n        /// transactions is a map of transaction IDs to TransactionData structs\n        access(contract) var transactions: {UInt64: TransactionData}\n\n        /// slot queue is a map of timestamps to Priorities to transaction IDs and their execution efforts\n        access(contract) var slotQueue: {UFix64: {Priority: {UInt64: UInt64}}}\n\n        /// slot used effort is a map of timestamps map of priorities and \n        /// efforts that has been used for the timeslot\n        access(contract) var slotUsedEffort: {UFix64: {Priority: UInt64}}\n\n        /// sorted timestamps manager for efficient processing\n        access(contract) var sortedTimestamps: SortedTimestamps\n    \n        /// canceled transactions keeps a record of canceled transaction IDs up to a canceledTransactionsLimit\n        access(contract) var canceledTransactions: [UInt64]\n\n        /// Struct that contains all the configuration details for the transaction scheduler protocol\n        /// Can be updated by the owner of the contract\n        access(contract) var config: {SchedulerConfig}\n\n        access(all) init() {\n            self.nextID = 1\n            self.canceledTransactions = [0 as UInt64]\n            \n            self.transactions = {}\n            self.slotUsedEffort = {}\n            self.slotQueue = {}\n            self.sortedTimestamps = SortedTimestamps()\n            \n            /* Default slot efforts and limits look like this:\n\n                Timestamp Slot (17.5kee)\n                \n                           \n                  High Only             High: 15kee max\n                    10kee               (10 exclusive + 5 shared)\n                          \n                |        |\n                 |  Shared Pool         |\n                |  (High+Medium)        |\n                |      5kee            |\n                |        |\n                           Medium: 7.5kee max  \n                  Medium Only           (2.5 exclusive + 5 shared)\n                    2.5kee               \n                          \n                   Low: 2.5kee max\n                  Low (if space left)   (execution time only)\n                        2.5kee           \n                  \n                \n            */\n\n            let sharedEffortLimit: UInt64 = 5_000\n            let highPriorityEffortReserve: UInt64 = 10_000\n            let mediumPriorityEffortReserve: UInt64 = 2_500\n\n            self.config = Config(\n                maximumIndividualEffort: 9999,\n                minimumExecutionEffort: 100,\n                slotSharedEffortLimit: sharedEffortLimit,\n                priorityEffortReserve: {\n                    Priority.High: highPriorityEffortReserve,\n                    Priority.Medium: mediumPriorityEffortReserve,\n                    Priority.Low: 0\n                },\n                lowPriorityEffortLimit: 2_500,\n                maxDataSizeMB: 0.001,\n                priorityFeeMultipliers: {\n                    Priority.High: 10.0,\n                    Priority.Medium: 5.0,\n                    Priority.Low: 2.0\n                },\n                refundMultiplier: 0.5,\n                canceledTransactionsLimit: 1000,\n                collectionEffortLimit: 500_000, // Maximum effort for all transactions in a collection\n                collectionTransactionsLimit: 150, // Maximum number of transactions in a collection\n                txRemovalLimit: 200\n            )\n        }\n\n        /// Gets a copy of the struct containing all the configuration details\n        /// of the Scheduler resource\n        access(contract) view fun getConfig(): {SchedulerConfig} {\n            return self.config\n        }\n\n        /// sets all the configuration details for the Scheduler resource\n        access(UpdateConfig) fun setConfig(newConfig: {SchedulerConfig}, txRemovalLimit: UInt) {\n            self.config = newConfig\n            FlowTransactionScheduler.account.storage.load<UInt>(from: /storage/txRemovalLimit)\n            FlowTransactionScheduler.account.storage.save(txRemovalLimit, to: /storage/txRemovalLimit)\n            emit ConfigUpdated()\n        }\n\n        /// getTransaction returns a copy of the specified transaction\n        access(contract) view fun getTransaction(id: UInt64): TransactionData? {\n            return self.transactions[id]\n        }\n\n        /// borrowTransaction borrows a reference to the specified transaction\n        access(contract) view fun borrowTransaction(id: UInt64): &TransactionData? {\n            return &self.transactions[id]\n        }\n\n        /// getCanceledTransactions returns a copy of the canceled transactions array\n        access(contract) view fun getCanceledTransactions(): [UInt64] {\n            return self.canceledTransactions\n        }\n\n        /// getTransactionsForTimeframe returns a dictionary of transactions scheduled within a specified time range,\n        /// organized by timestamp and priority with arrays of transaction IDs.\n        /// WARNING: If you provide a time range that is too large, the function will likely fail to complete\n        /// because the function will run out of gas. Keep the time range small.\n        ///\n        /// @param startTimestamp: The start timestamp (inclusive) for the time range\n        /// @param endTimestamp: The end timestamp (inclusive) for the time range\n        /// @return {UFix64: {Priority: [UInt64]}}: A dictionary mapping timestamps to priorities to arrays of transaction IDs\n        access(contract) fun getTransactionsForTimeframe(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: {UInt8: [UInt64]}} {\n            var transactionsInTimeframe: {UFix64: {UInt8: [UInt64]}} = {}\n            \n            // Validate input parameters\n            if startTimestamp > endTimestamp {\n                return transactionsInTimeframe\n            }\n            \n            // Get all timestamps that fall within the specified range\n            let allTimestampsBeforeEnd = self.sortedTimestamps.getBefore(current: endTimestamp)\n            \n            for timestamp in allTimestampsBeforeEnd {\n                // Check if this timestamp falls within our range\n                if timestamp < startTimestamp { continue }\n                \n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                \n                var timestampTransactions: {UInt8: [UInt64]} = {}\n                \n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    var priorityTransactions: [UInt64] = []\n                        \n                    for id in transactionIDs.keys {\n                        priorityTransactions.append(id)\n                    }\n                        \n                    if priorityTransactions.length > 0 {\n                        timestampTransactions[priority.rawValue] = priorityTransactions\n                    }\n                }\n                \n                if timestampTransactions.keys.length > 0 {\n                    transactionsInTimeframe[timestamp] = timestampTransactions\n                }\n                \n            }\n            \n            return transactionsInTimeframe\n        }\n\n        /// calculate fee by converting execution effort to a fee in Flow tokens.\n        /// @param executionEffort: The execution effort of the transaction\n        /// @param priority: The priority of the transaction\n        /// @param dataSizeMB: The size of the data that was passed when the transaction was originally scheduled\n        /// @return UFix64: The fee in Flow tokens that is required to pay for the transaction\n        access(contract) fun calculateFee(executionEffort: UInt64, priority: Priority, dataSizeMB: UFix64): UFix64 {\n            // Use the official FlowFees calculation\n            let baseFee = FlowFees.computeFees(inclusionEffort: 1.0, executionEffort: UFix64(executionEffort)/100000000.0)\n            \n            // Scale the execution fee by the multiplier for the priority\n            let scaledExecutionFee = baseFee * self.config.priorityFeeMultipliers[priority]!\n\n            // Calculate the FLOW required to pay for storage of the transaction data\n            let storageFee = FlowStorageFees.storageCapacityToFlow(dataSizeMB)\n\n            // Add inclusion Flow fee for scheduled transactions\n            let inclusionFee = 0.00001\n\n            return scaledExecutionFee + storageFee + inclusionFee\n        }\n\n        /// getNextIDAndIncrement returns the next ID and increments the ID counter\n        access(self) fun getNextIDAndIncrement(): UInt64 {\n            let nextID = self.nextID\n            self.nextID = self.nextID + 1\n            return nextID\n        }\n\n        /// get status of the scheduled transaction\n        /// @param id: The ID of the transaction to get the status of\n        /// @return Status: The status of the transaction, if the transaction is not found Unknown is returned.\n        access(contract) view fun getStatus(id: UInt64): Status? {\n            // if the transaction ID is greater than the next ID, it is not scheduled yet and has never existed\n            if id == 0 as UInt64 || id >= self.nextID {\n                return nil\n            }\n\n            // This should always return Scheduled or Executed\n            if let tx = self.borrowTransaction(id: id) {\n                return tx.status\n            }\n\n            // if the transaction was canceled and it is still not pruned from \n            // list return canceled status\n            if self.canceledTransactions.contains(id) {\n                return Status.Canceled\n            }\n\n            // if transaction ID is after first canceled ID it must be executed \n            // otherwise it would have been canceled and part of this list\n            let firstCanceledID = self.canceledTransactions[0]\n            if id > firstCanceledID {\n                return Status.Executed\n            }\n\n            // the transaction list was pruned and the transaction status might be \n            // either canceled or execute so we return unknown\n            return Status.Unknown\n        }\n\n        /// schedule is the primary entry point for scheduling a new transaction within the scheduler contract. \n        /// If scheduling the transaction is not possible either due to invalid arguments or due to \n        /// unavailable slots, the function panics. \n        //\n        /// The schedule function accepts the following arguments:\n        /// @param: transaction: A capability to a resource in storage that implements the transaction handler \n        ///    interface. This handler will be invoked at execution time and will receive the specified data payload.\n        /// @param: timestamp: Specifies the earliest block timestamp at which the transaction is eligible for execution \n        ///    (Unix timestamp so fractional seconds values are ignored). It must be set in the future.\n        /// @param: priority: An enum value (`High`, `Medium`, or `Low`) that influences the scheduling behavior and determines \n        ///    how soon after the timestamp the transaction will be executed.\n        /// @param: executionEffort: Defines the maximum computational resources allocated to the transaction. This also determines \n        ///    the fee charged. Unused execution effort is not refunded.\n        /// @param: fees: A Vault resource containing sufficient funds to cover the required execution effort.\n        access(contract) fun schedule(\n            handlerCap: Capability<auth(Execute) &{TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): @ScheduledTransaction {\n\n            // Use the estimate function to validate inputs\n            let estimate = self.estimate(\n                data: data,\n                timestamp: timestamp,\n                priority: priority,\n                executionEffort: executionEffort\n            )\n\n            // Estimate returns an error for low priority transactions\n            // so need to check that the error is fine\n            // because low priority transactions are allowed in schedule\n            if estimate.error != nil && estimate.timestamp == nil {\n                panic(estimate.error!)\n            }\n\n            assert (\n                fees.balance >= estimate.flowFee!,\n                message: \"Insufficient fees: The Fee balance of \\(fees.balance) is not sufficient to pay the required amount of \\(estimate.flowFee!) for execution of the transaction.\"\n            )\n\n            let transactionID = self.getNextIDAndIncrement()\n            let transactionData = TransactionData(\n                id: transactionID,\n                handler: handlerCap,\n                scheduledTimestamp: estimate.timestamp!,\n                data: data,\n                priority: priority,\n                executionEffort: executionEffort,\n                fees: fees.balance,\n            )\n\n            // Deposit the fees to the service account's vault\n            FlowTransactionScheduler.depositFees(from: <-fees)\n\n            let handlerRef = handlerCap.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n\n            let handlerPublicPath = handlerRef.resolveView(Type<PublicPath>()) as? PublicPath\n\n            emit Scheduled(\n                id: transactionData.id,\n                priority: transactionData.priority.rawValue,\n                timestamp: transactionData.scheduledTimestamp,\n                executionEffort: transactionData.executionEffort,\n                fees: transactionData.fees,\n                transactionHandlerOwner: transactionData.handler.address,\n                transactionHandlerTypeIdentifier: transactionData.handlerTypeIdentifier,\n                transactionHandlerUUID: handlerRef.uuid,\n                transactionHandlerPublicPath: handlerPublicPath\n            )\n\n            // Add the transaction to the slot queue and update the internal state\n            self.addTransaction(slot: estimate.timestamp!, txData: transactionData)\n            \n            return <-create ScheduledTransaction(\n                id: transactionID, \n                timestamp: estimate.timestamp!,\n                handlerTypeIdentifier: transactionData.handlerTypeIdentifier\n            )\n        }\n\n        /// The estimate function calculates the required fee in Flow and expected execution timestamp for \n        /// a transaction based on the requested timestamp, priority, and execution effort. \n        //\n        /// If the provided arguments are invalid or the transaction cannot be scheduled (e.g., due to \n        /// insufficient computation effort or unavailable time slots) the estimate function\n        /// returns an EstimatedScheduledTransaction struct with a non-nil error message.\n        ///        \n        /// This helps developers ensure sufficient funding and preview the expected scheduling window, \n        /// reducing the risk of unnecessary cancellations.\n        ///\n        /// @param data: The data that was passed when the transaction was originally scheduled\n        /// @param timestamp: The requested timestamp for the transaction\n        /// @param priority: The priority of the transaction\n        /// @param executionEffort: The execution effort of the transaction\n        /// @return EstimatedScheduledTransaction: A struct containing the estimated fee, timestamp, and error message\n        access(contract) fun estimate(\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: Priority,\n            executionEffort: UInt64\n        ): EstimatedScheduledTransaction {\n            // Remove fractional values from the timestamp\n            let sanitizedTimestamp = UFix64(UInt64(timestamp))\n\n            if sanitizedTimestamp <= getCurrentBlock().timestamp {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid timestamp: \\(sanitizedTimestamp) is in the past, current timestamp: \\(getCurrentBlock().timestamp)\"\n                        )\n            }\n\n            if executionEffort > self.config.maximumIndividualEffort {\n                return EstimatedScheduledTransaction(\n                    flowFee: nil,\n                    timestamp: nil,\n                    error: \"Invalid execution effort: \\(executionEffort) is greater than the maximum transaction effort of \\(self.config.maximumIndividualEffort)\"\n                )\n            }\n\n            if executionEffort > self.config.priorityEffortLimit[priority]! {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is greater than the priority's max effort of \\(self.config.priorityEffortLimit[priority]!)\"\n                        )\n            }\n\n            if executionEffort < self.config.minimumExecutionEffort {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is less than the minimum execution effort of \\(self.config.minimumExecutionEffort)\"\n                        )\n            }\n\n            let dataSizeMB = FlowTransactionScheduler.getSizeOfData(data)\n            if dataSizeMB > self.config.maxDataSizeMB {\n                return EstimatedScheduledTransaction(\n                    flowFee: nil,\n                    timestamp: nil,\n                    error: \"Invalid data size: \\(dataSizeMB) is greater than the maximum data size of \\(self.config.maxDataSizeMB)MB\"\n                )\n            }\n\n            let fee = self.calculateFee(executionEffort: executionEffort, priority: priority, dataSizeMB: dataSizeMB)\n\n            let scheduledTimestamp = self.calculateScheduledTimestamp(\n                timestamp: sanitizedTimestamp, \n                priority: priority, \n                executionEffort: executionEffort\n            )\n\n            if scheduledTimestamp == nil {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is greater than the priority's available effort for the requested timestamp.\"\n                        )\n            }\n\n            if priority == Priority.Low {\n                return EstimatedScheduledTransaction(\n                            flowFee: fee,\n                            timestamp: scheduledTimestamp,\n                            error: \"Invalid Priority: Cannot estimate for Low Priority transactions. They will be included in the first block with available space after their requested timestamp.\"\n                        )\n            }\n\n            return EstimatedScheduledTransaction(flowFee: fee, timestamp: scheduledTimestamp, error: nil)\n        }\n\n        /// calculateScheduledTimestamp calculates the timestamp at which a transaction \n        /// can be scheduled. It takes into account the priority of the transaction and \n        /// the execution effort.\n        /// - If the transaction is high priority, it returns the timestamp if there is enough \n        ///    space or nil if there is no space left.\n        /// - If the transaction is medium or low priority and there is space left in the requested timestamp,\n        ///   it returns the requested timestamp. If there is not enough space, it finds the next timestamp with space.\n        ///\n        /// @param timestamp: The requested timestamp for the transaction\n        /// @param priority: The priority of the transaction\n        /// @param executionEffort: The execution effort of the transaction\n        /// @return UFix64?: The timestamp at which the transaction can be scheduled, or nil if there is no space left for a high priority transaction\n        access(contract) view fun calculateScheduledTimestamp(\n            timestamp: UFix64, \n            priority: Priority, \n            executionEffort: UInt64\n        ): UFix64? {\n\n            var timestampToSearch = timestamp\n\n            // If no available timestamps are found, this will eventually reach the gas limit and fail\n            // This is extremely unlikely\n            while true {\n\n                let used = self.slotUsedEffort[timestampToSearch]\n                // if nothing is scheduled at this timestamp, we can schedule at provided timestamp\n                if used == nil { \n                    return timestampToSearch\n                }\n                \n                let available = self.getSlotAvailableEffort(sanitizedTimestamp: timestampToSearch, priority: priority)\n                // if theres enough space, we can tentatively schedule at provided timestamp\n                if executionEffort <= available {\n                    return timestampToSearch\n                }\n                \n                if priority == Priority.High {\n                    // high priority demands scheduling at exact timestamp or failing\n                    return nil\n                }\n\n                timestampToSearch = timestampToSearch + 1.0\n            }\n\n            // should never happen\n            return nil\n        }\n\n        /// slot available effort returns the amount of effort that is available for a given timestamp and priority.\n        /// @param sanitizedTimestamp: The timestamp to get the available effort for. It should already have been sanitized\n        ///                            in the calling function\n        /// @param priority: The priority to get the available effort for\n        /// @return UInt64: The amount of effort that is available for the given timestamp and priority\n        access(contract) view fun getSlotAvailableEffort(sanitizedTimestamp: UFix64, priority: Priority): UInt64 {\n\n            // Get the theoretical maximum allowed for the priority including shared\n            let priorityLimit = self.config.priorityEffortLimit[priority]!\n            \n            // If nothing has been claimed for the requested timestamp,\n            // return the full amount\n            if !self.slotUsedEffort.containsKey(sanitizedTimestamp) {\n                return priorityLimit\n            }\n\n            // Get the mapping of how much effort has been used\n            // for each priority for the timestamp\n            let slotPriorityEffortsUsed = &self.slotUsedEffort[sanitizedTimestamp]! as &{Priority: UInt64}\n\n            // Get how much effort has been used for each priority\n            let highUsed = slotPriorityEffortsUsed[Priority.High] ?? 0\n            let mediumUsed = slotPriorityEffortsUsed[Priority.Medium] ?? 0\n\n            // If it is low priority, return whatever effort is remaining\n            // under the low priority effort limit, subtracting the currently used effort for low priority\n            if priority == Priority.Low {\n                let highPlusMediumUsed = highUsed + mediumUsed\n                let totalEffortRemaining = self.config.slotTotalEffortLimit.saturatingSubtract(highPlusMediumUsed)\n                let lowEffortRemaining = totalEffortRemaining < priorityLimit ? totalEffortRemaining : priorityLimit\n                let lowUsed = slotPriorityEffortsUsed[Priority.Low] ?? 0\n                return lowEffortRemaining.saturatingSubtract(lowUsed)\n            }\n\n            // Get the exclusive reserves for each priority\n            let highReserve = self.config.priorityEffortReserve[Priority.High]!\n            let mediumReserve = self.config.priorityEffortReserve[Priority.Medium]!\n            \n            // Get how much shared effort has been used for each priority\n            // Ensure the results are always zero or positive\n            let highSharedUsed: UInt64 = highUsed.saturatingSubtract(highReserve)\n            let mediumSharedUsed: UInt64 = mediumUsed.saturatingSubtract(mediumReserve)\n\n            // Get the theoretical total shared amount between priorities\n            let totalShared = (self.config.slotTotalEffortLimit.saturatingSubtract(highReserve)).saturatingSubtract(mediumReserve)\n\n            // Get the amount of shared effort currently available\n            let highPlusMediumSharedUsed = highSharedUsed + mediumSharedUsed\n            // prevent underflow\n            let sharedAvailable = totalShared.saturatingSubtract(highPlusMediumSharedUsed)\n\n            // we calculate available by calculating available shared effort and \n            // adding any unused reserves for that priority\n            let reserve = self.config.priorityEffortReserve[priority]!\n            let used = slotPriorityEffortsUsed[priority] ?? 0\n            let unusedReserve: UInt64 = reserve.saturatingSubtract(used)\n            let available = sharedAvailable + unusedReserve\n            \n            return available\n        }\n\n         /// add transaction to the queue and updates all the internal state as well as emit an event\n        access(self) fun addTransaction(slot: UFix64, txData: TransactionData) {\n\n            // If nothing is in the queue for this slot, initialize the slot\n            if self.slotQueue[slot] == nil {\n                self.slotQueue[slot] = {}\n\n                // This also means that the used effort record for this slot has not been initialized\n                self.slotUsedEffort[slot] = {\n                    Priority.High: 0,\n                    Priority.Medium: 0,\n                    Priority.Low: 0\n                }\n\n                self.sortedTimestamps.add(timestamp: slot)\n            }\n\n            // Add this transaction id to the slot\n            let transactionsForSlot = self.slotQueue[slot]!\n            if let priorityQueue = transactionsForSlot[txData.priority] {\n                priorityQueue[txData.id] = txData.executionEffort\n                transactionsForSlot[txData.priority] = priorityQueue\n            } else {\n                transactionsForSlot[txData.priority] = {\n                    txData.id: txData.executionEffort\n                }\n            }\n            self.slotQueue[slot] = transactionsForSlot\n\n            // Add the execution effort for this transaction to the total for the slot's priority\n            let slotEfforts = &self.slotUsedEffort[slot]! as auth(Mutate) &{Priority: UInt64}\n            var newPriorityEffort = slotEfforts[txData.priority]! + txData.executionEffort\n            slotEfforts[txData.priority] = newPriorityEffort\n            var newTotalEffort: UInt64 = 0\n            for priority in slotEfforts.keys {\n                newTotalEffort = newTotalEffort.saturatingAdd(slotEfforts[priority]!)\n            }\n\n            // Store the transaction in the transactions map\n            self.transactions[txData.id] = txData\n            \n            // Need to potentially reschedule low priority transactions to make room for the new transaction\n            // Iterate through them and record which ones to reschedule until the total effort is less than the limit\n            let lowTransactionsToReschedule: [UInt64] = []\n            if newTotalEffort > self.config.slotTotalEffortLimit {\n                let lowPriorityTransactions = transactionsForSlot[Priority.Low]!\n                for id in lowPriorityTransactions.keys {\n                    if newTotalEffort <= self.config.slotTotalEffortLimit {\n                        break\n                    }\n                    lowTransactionsToReschedule.append(id)\n                    newTotalEffort = newTotalEffort.saturatingSubtract(lowPriorityTransactions[id]!)\n                }\n            }\n\n            // Reschedule low priority transactions if needed\n            self.rescheduleLowPriorityTransactions(slot: slot, transactions: lowTransactionsToReschedule)\n        }\n\n        /// rescheduleLowPriorityTransactions reschedules low priority transactions to make room for a new transaction\n        /// @param slot: The slot that the transactions are currently scheduled at\n        /// @param transactions: The transactions to reschedule\n        access(self) fun rescheduleLowPriorityTransactions(slot: UFix64, transactions: [UInt64]) {\n            for id in transactions {\n                let tx = self.borrowTransaction(id: id)\n                if tx == nil {\n                    emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while rescheduling low priority transactions\")\n                    continue\n                }\n\n                if tx!.priority != Priority.Low {\n                    emit CriticalIssue(message: \"Invalid Priority: Cannot reschedule transaction with id \\(id) because it is not low priority\")\n                    continue\n                }\n                \n                if tx!.scheduledTimestamp != slot {\n                    emit CriticalIssue(message: \"Invalid Timestamp: Cannot reschedule transaction with id \\(id) because it is not scheduled at the same slot as the new transaction\")\n                    continue\n                }\n\n                let newTimestamp = self.calculateScheduledTimestamp(\n                    timestamp: slot + 1.0,\n                    priority: Priority.Low,\n                    executionEffort: tx!.executionEffort\n                )!\n\n                let effort = tx!.executionEffort\n                let transactionData = self.removeTransaction(txData: tx!)\n\n                // Subtract the execution effort for this transaction from the slot's priority\n                let slotEfforts = &self.slotUsedEffort[slot]! as auth(Mutate) &{Priority: UInt64}\n                slotEfforts[Priority.Low] = slotEfforts[Priority.Low]!.saturatingSubtract(effort)\n\n                // Update the transaction's scheduled timestamp and add it back to the slot queue\n                transactionData.setScheduledTimestamp(newTimestamp: newTimestamp)\n                self.addTransaction(slot: newTimestamp, txData: transactionData)\n            }\n        }\n\n        /// remove the transaction from the slot queue.\n        access(self) fun removeTransaction(txData: &TransactionData): TransactionData {\n\n            let transactionID = txData.id\n            let slot = txData.scheduledTimestamp\n            let transactionPriority = txData.priority\n\n            // remove transaction object\n            let transactionObject = self.transactions.remove(key: transactionID)!\n            \n            // garbage collect slots \n            let transactionQueue = self.slotQueue[slot]!\n\n            if let priorityQueue = transactionQueue[transactionPriority] {\n                priorityQueue[transactionID] = nil\n                if priorityQueue.keys.length == 0 {\n                    transactionQueue.remove(key: transactionPriority)\n                } else {\n                    transactionQueue[transactionPriority] = priorityQueue\n                }\n            }\n            self.slotQueue[slot] = transactionQueue\n\n            // if the slot is now empty remove it from the maps\n            if transactionQueue.keys.length == 0 {\n                self.slotQueue.remove(key: slot)\n                self.slotUsedEffort.remove(key: slot)\n\n                self.sortedTimestamps.remove(timestamp: slot)\n            }\n\n            return transactionObject\n        }\n\n        /// pendingQueue creates a list of transactions that are ready for execution.\n        /// For transaction to be ready for execution it must be scheduled.\n        ///\n        /// The queue is sorted by timestamp and then by priority (high, medium, low).\n        /// The queue will contain transactions from all timestamps that are in the past.\n        /// Low priority transactions will only be added if there is effort available in the slot.  \n        /// The return value can be empty if there are no transactions ready for execution.\n        access(Process) fun pendingQueue(): [&TransactionData] {\n            let currentTimestamp = getCurrentBlock().timestamp\n            var pendingTransactions: [&TransactionData] = []\n\n            // total effort across different timestamps guards collection being over the effort limit\n            var collectionAvailableEffort = self.config.collectionEffortLimit\n            var transactionsAvailableCount = self.config.collectionTransactionsLimit\n\n            // Collect past timestamps efficiently from sorted array\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n\n            for timestamp in pastTimestamps {\n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                var high: [&TransactionData] = []\n                var medium: [&TransactionData] = []\n                var low: [&TransactionData] = []\n\n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    for id in transactionIDs.keys {\n                        let tx = self.borrowTransaction(id: id)\n                        if tx == nil {\n                            emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while preparing pending queue\")\n                            continue\n                        }\n                        \n                        // Only add scheduled transactions to the queue\n                        if tx!.status != Status.Scheduled {\n                            continue\n                        }\n\n                        // this is safeguard to prevent collection growing too large in case of block production slowdown\n                        if tx!.executionEffort >= collectionAvailableEffort || transactionsAvailableCount == 0 {\n                            emit CollectionLimitReached(\n                                collectionEffortLimit: transactionsAvailableCount == 0 ? nil : self.config.collectionEffortLimit,\n                                collectionTransactionsLimit: transactionsAvailableCount == 0 ? self.config.collectionTransactionsLimit : nil\n                            )\n                            break\n                        }\n\n                        collectionAvailableEffort = collectionAvailableEffort.saturatingSubtract(tx!.executionEffort)\n                        transactionsAvailableCount = transactionsAvailableCount - 1\n                    \n                        switch tx!.priority {\n                            case Priority.High:\n                                high.append(tx!)\n                            case Priority.Medium:\n                                medium.append(tx!)\n                            case Priority.Low:\n                                low.append(tx!)\n                        }\n                    }\n                }\n\n                pendingTransactions = pendingTransactions\n                    .concat(high)\n                    .concat(medium)\n                    .concat(low)\n            }\n\n            return pendingTransactions\n        }\n\n        /// removeExecutedTransactions removes all transactions that are marked as executed.\n        access(self) fun removeExecutedTransactions(_ currentTimestamp: UFix64) {\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n            var numRemoved = 0\n            let removalLimit = self.config.getTxRemovalLimit()\n\n            for timestamp in pastTimestamps {\n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                \n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    for id in transactionIDs.keys {\n\n                        numRemoved = numRemoved + 1\n\n                        if UInt(numRemoved) >= removalLimit {\n                            emit RemovalLimitReached()\n                            return\n                        }\n\n                        let tx = self.borrowTransaction(id: id)\n                        if tx == nil {\n                            emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while removing executed transactions\")\n                            continue\n                        }\n\n                        // Only remove executed transactions\n                        if tx!.status != Status.Executed {\n                            continue\n                        }\n\n                        // charge the full fee for transaction execution\n                        destroy tx!.payAndRefundFees(refundMultiplier: 0.0)\n\n                        self.removeTransaction(txData: tx!)\n                    }\n                }\n            }\n        }\n\n        /// process scheduled transactions and prepare them for execution. \n        ///\n        /// First, it removes transactions that have already been executed. \n        /// Then, it iterates over past timestamps in the queue and processes the transactions that are \n        /// eligible for execution. It also emits an event for each transaction that is processed.\n        ///\n        /// This function is only called by the FVM to process transactions.\n        access(Process) fun process() {\n            let currentTimestamp = getCurrentBlock().timestamp\n            // Early exit if no timestamps need processing\n            if !self.sortedTimestamps.hasBefore(current: currentTimestamp) {\n                return\n            }\n\n            self.removeExecutedTransactions(currentTimestamp)\n\n            let pendingTransactions = self.pendingQueue()\n\n            for tx in pendingTransactions {\n                // Only emit the pending execution event if the transaction handler capability is borrowable\n                // This is to prevent a situation where the transaction handler is not available\n                // In that case, the transaction is no longer valid because it cannot be executed\n                if let transactionHandler = tx.handler.borrow() {\n                    emit PendingExecution(\n                        id: tx.id,\n                        priority: tx.priority.rawValue,\n                        executionEffort: tx.executionEffort,\n                        fees: tx.fees,\n                        transactionHandlerOwner: tx.handler.address,\n                        transactionHandlerTypeIdentifier: transactionHandler.getType().identifier\n                    )\n                }\n\n                // after pending execution event is emitted we set the transaction as executed because we \n                // must rely on execution node to actually execute it. Execution of the transaction is \n                // done in a separate transaction that calls executeTransaction(id) function.\n                // Executing the transaction can not update the status of transaction or any other shared state,\n                // since that blocks concurrent transaction execution.\n                // Therefore an optimistic update to executed is made here to avoid race condition.\n                tx.setStatus(newStatus: Status.Executed)\n            }\n        }\n\n        /// cancel a scheduled transaction and return a portion of the fees that were paid.\n        ///\n        /// @param id: The ID of the transaction to cancel\n        /// @return: The fees to be returned to the caller\n        access(Cancel) fun cancel(id: UInt64): @FlowToken.Vault {\n            let tx = self.borrowTransaction(id: id) ?? \n                panic(\"Invalid ID: \\(id) transaction not found\")\n\n            assert(\n                tx.status == Status.Scheduled,\n                message: \"Transaction must be in a scheduled state in order to be canceled\"\n            )\n            \n            // Subtract the execution effort for this transaction from the slot's priority\n            let slotEfforts = self.slotUsedEffort[tx.scheduledTimestamp]!\n            slotEfforts[tx.priority] = slotEfforts[tx.priority]!.saturatingSubtract(tx.executionEffort)\n            self.slotUsedEffort[tx.scheduledTimestamp] = slotEfforts\n\n            let totalFees = tx.fees\n            let refundedFees <- tx.payAndRefundFees(refundMultiplier: self.config.refundMultiplier)\n\n            // if the transaction was canceled, add it to the canceled transactions array\n            // maintain sorted order by inserting at the correct position\n\t\t\tvar high = self.canceledTransactions.length\n\t\t\tvar low = 0\n\t\t\twhile low < high {\n\t\t\t\tlet mid = (low+high)/2\n\t\t\t\tlet midCanceledID = self.canceledTransactions[mid]\n\n\t\t\t\tif midCanceledID == id {\n                    emit CriticalIssue(message: \"Invalid ID: \\(id) transaction already in canceled transactions array\")\n                } else if midCanceledID > id {\n\t\t\t\t\thigh = mid\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1\n\t\t\t\t}\n\t\t\t}\n            self.canceledTransactions.insert(at: low, id)\n            \n            // keep the array under the limit\n            if UInt(self.canceledTransactions.length) > self.config.canceledTransactionsLimit {\n                self.canceledTransactions.remove(at: 0)\n            }\n\n            emit Canceled(\n                id: tx.id,\n                priority: tx.priority.rawValue,\n                feesReturned: refundedFees.balance,\n                feesDeducted: totalFees - refundedFees.balance,\n                transactionHandlerOwner: tx.handler.address,\n                transactionHandlerTypeIdentifier: tx.handlerTypeIdentifier\n            )\n\n            self.removeTransaction(txData: tx)\n            \n            return <-refundedFees\n        }\n\n        /// execute transaction is a system function that is called by FVM to execute a transaction by ID.\n        /// The transaction must be found and in correct state or the function panics and this is a fatal error\n        ///\n        /// This function is only called by the FVM to execute transactions.\n        /// WARNING: this function should not change any shared state, it will be run concurrently and it must not be blocking.\n        access(Execute) fun executeTransaction(id: UInt64) {\n            let tx = self.borrowTransaction(id: id) ?? \n                panic(\"Invalid ID: Transaction with id \\(id) not found\")\n\n            assert (\n                tx.status == Status.Executed,\n                message: \"Invalid ID: Cannot execute transaction with id \\(id) because it has incorrect status \\(tx.status.rawValue)\"\n            )\n\n            let transactionHandler = tx.handler.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n\n            let handlerPublicPath = transactionHandler.resolveView(Type<PublicPath>()) as? PublicPath\n\n            emit Executed(\n                id: tx.id,\n                priority: tx.priority.rawValue,\n                executionEffort: tx.executionEffort,\n                transactionHandlerOwner: tx.handler.address,\n                transactionHandlerTypeIdentifier: transactionHandler.getType().identifier,\n                transactionHandlerUUID: transactionHandler.uuid,\n                transactionHandlerPublicPath: handlerPublicPath\n\n            )\n            \n            transactionHandler.executeTransaction(id: id, data: tx.getData())\n        }\n    }\n    \n    /// Deposit fees to this contract's account's vault\n    access(contract) fun depositFees(from: @FlowToken.Vault) {\n        let vaultRef = self.account.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n        vaultRef.deposit(from: <-from)\n    }\n\n    /// Withdraw fees from this contract's account's vault\n    access(contract) fun withdrawFees(amount: UFix64): @FlowToken.Vault {\n        let vaultRef = self.account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n            \n        return <-vaultRef.withdraw(amount: amount) as! @FlowToken.Vault\n    }\n\n    access(all) fun schedule(\n        handlerCap: Capability<auth(Execute) &{TransactionHandler}>,\n        data: AnyStruct?,\n        timestamp: UFix64,\n        priority: Priority,\n        executionEffort: UInt64,\n        fees: @FlowToken.Vault\n    ): @ScheduledTransaction {\n        return <-self.sharedScheduler.borrow()!.schedule(\n            handlerCap: handlerCap, \n            data: data, \n            timestamp: timestamp, \n            priority: priority, \n            executionEffort: executionEffort, \n            fees: <-fees\n        )\n    }\n\n    access(all) fun estimate(\n        data: AnyStruct?,\n        timestamp: UFix64,\n        priority: Priority,\n        executionEffort: UInt64\n    ): EstimatedScheduledTransaction {\n        return self.sharedScheduler.borrow()!\n            .estimate(\n                data: data, \n                timestamp: timestamp, \n                priority: priority, \n                executionEffort: executionEffort,\n            )\n    }\n\n    /// Allows users to calculate the fee for a scheduled transaction without having to call the expensive estimate function\n    /// @param executionEffort: The execution effort of the transaction\n    /// @param priority: The priority of the transaction\n    /// @param dataSizeMB: The size of the data to be stored with the scheduled transaction\n    ///                    The user must calculate this data size themselves before calling this function\n    ///                    But should be done in a separate script or transaction to avoid the expensive getSizeOfData function\n    /// @return UFix64: The fee in Flow tokens that is required to pay for the transaction\n    access(all) fun calculateFee(executionEffort: UInt64, priority: Priority, dataSizeMB: UFix64): UFix64 {\n        return self.sharedScheduler.borrow()!.calculateFee(executionEffort: executionEffort, priority: priority, dataSizeMB: dataSizeMB)\n    }\n\n    access(all) fun cancel(scheduledTx: @ScheduledTransaction): @FlowToken.Vault {\n        let id = scheduledTx.id\n        destroy scheduledTx\n        return <-self.sharedScheduler.borrow()!.cancel(id: id)\n    }\n\n    /// getTransactionData returns the transaction data for a given ID\n    /// This function can only get the data for a transaction that is currently scheduled or pending execution\n    /// because finalized transaction metadata is not stored in the contract\n    /// @param id: The ID of the transaction to get the data for\n    /// @return: The transaction data for the given ID\n    access(all) view fun getTransactionData(id: UInt64): TransactionData? {\n        return self.sharedScheduler.borrow()!.getTransaction(id: id)\n    }\n\n    /// borrowHandlerForID returns an un-entitled reference to the transaction handler for a given ID\n    /// The handler reference can be used to resolve views to get info about the handler and see where it is stored\n    /// @param id: The ID of the transaction to get the handler for\n    /// @return: An un-entitled reference to the transaction handler for the given ID\n    access(all) view fun borrowHandlerForID(_ id: UInt64): &{TransactionHandler}? {\n        return self.getTransactionData(id: id)?.borrowHandler()\n    }\n\n    /// getCanceledTransactions returns the IDs of the transactions that have been canceled\n    /// @return: The IDs of the transactions that have been canceled\n    access(all) view fun getCanceledTransactions(): [UInt64] {\n        return self.sharedScheduler.borrow()!.getCanceledTransactions()\n    }\n\n\n    access(all) view fun getStatus(id: UInt64): Status? {\n        return self.sharedScheduler.borrow()!.getStatus(id: id)\n    }\n\n    /// getTransactionsForTimeframe returns the IDs of the transactions that are scheduled for a given timeframe\n    /// @param startTimestamp: The start timestamp to get the IDs for\n    /// @param endTimestamp: The end timestamp to get the IDs for\n    /// @return: The IDs of the transactions that are scheduled for the given timeframe\n    access(all) fun getTransactionsForTimeframe(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: {UInt8: [UInt64]}} {\n        return self.sharedScheduler.borrow()!.getTransactionsForTimeframe(startTimestamp: startTimestamp, endTimestamp: endTimestamp)\n    }\n\n    access(all) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n        // Remove fractional values from the timestamp\n        let sanitizedTimestamp = UFix64(UInt64(timestamp))\n        return self.sharedScheduler.borrow()!.getSlotAvailableEffort(sanitizedTimestamp: sanitizedTimestamp, priority: priority)\n    }\n\n    access(all) fun getConfig(): {SchedulerConfig} {\n        return self.sharedScheduler.borrow()!.getConfig()\n    }\n    \n    /// getSizeOfData takes a transaction's data\n    /// argument and stores it in the contract account's storage, \n    /// checking storage used before and after to see how large the data is in MB\n    /// If data is nil, the function returns 0.0\n    access(all) fun getSizeOfData(_ data: AnyStruct?): UFix64 {\n        if data == nil {\n            return 0.0\n        } else {\n            let type = data!.getType()\n            if type.isSubtype(of: Type<Number>()) \n            || type.isSubtype(of: Type<Bool>()) \n            || type.isSubtype(of: Type<Address>())\n            || type.isSubtype(of: Type<Character>())\n            || type.isSubtype(of: Type<Capability>())\n            {\n                return 0.0\n            }\n        }\n        let storagePath = /storage/dataTemp\n        let storageUsedBefore = self.account.storage.used\n        self.account.storage.save(data!, to: storagePath)\n        let storageUsedAfter = self.account.storage.used\n        self.account.storage.load<AnyStruct>(from: storagePath)\n\n        return FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(storageUsedAfter.saturatingSubtract(storageUsedBefore))\n    }\n\n    access(all) init() {\n        self.storagePath = /storage/sharedScheduler\n        let scheduler <- create SharedScheduler()\n        let oldScheduler <- self.account.storage.load<@AnyResource>(from: self.storagePath)\n        destroy oldScheduler\n        self.account.storage.save(<-scheduler, to: self.storagePath)\n        \n        self.sharedScheduler = self.account.capabilities.storage\n            .issue<auth(Cancel) &SharedScheduler>(self.storagePath)\n    }\n}",
      "valid_from": 138786558,
      "valid_to": null,
      "created_at": "2026-01-13T22:56:05.214Z",
      "deployments": 3,
      "imported_by": [
        "A.b1d63873c3cc9f79.FlowYieldVaultsStrategiesV1_1",
        "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils"
      ],
      "imported_count": 2,
      "import_count": 5,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/138303622",
      "id": "A.e467b9dd11fa00df.EVM/138783761",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "146aaa2620bc1e003a241e8200939c1f96f39e99e4e1d276e8a7b15cc9cadcca",
      "status": "ok",
      "diff": "--- 613171cfe8abe0b70a3a8507adcefa9fbd1908b2fe55ab2cb912cd5166b681ee.138303622\n+++ 146aaa2620bc1e003a241e8200939c1f96f39e99e4e1d276e8a7b15cc9cadcca.138783761\n@@ -3,21 +3,34 @@\n import FungibleToken from 0xf233dcee88fe0abe\n import FlowToken from 0x1654653399040a61\n \n-access(all)\n-contract EVM {\n+/*\n \n-    // Entitlements enabling finer-grained access control on a CadenceOwnedAccount\n-    access(all) entitlement Validate\n-    access(all) entitlement Withdraw\n-    access(all) entitlement Call\n-    access(all) entitlement Deploy\n-    access(all) entitlement Owner\n-    access(all) entitlement Bridge\n+    The Flow EVM contract defines important types and functionality\n+    to allow Cadence code and Flow SDKs to interface\n+    with the Etherem Virtual Machine environment on Flow.\n \n+    The EVM contract emits events when relevant actions happen in Flow EVM\n+    such as creating new blocks, executing transactions, and bridging FLOW\n+\n+    This contract also defines Cadence-Owned Account functionality,\n+    which is currently the only way for Cadence code to interact with Flow EVM.\n+\n+    Additionally, functionality is provided for common EVM types\n+    such as addresses, balances, ABIs, transaction results, and more.\n+\n+    The EVM contract is deployed to the Flow Service Account on every network\n+    and many of its functionality is directly connected to the protocol software\n+    to allow interaction with the EVM.\n+\n+    See additional EVM documentation here: https://developers.flow.com/evm/about\n+\n+*/\n+\n+access(all) contract EVM {\n+\n     /// Block executed event is emitted when a new block is created,\n     /// which always happens when a transaction is executed.\n-    access(all)\n-    event BlockExecuted(\n+    access(all) event BlockExecuted (\n         // height or number of the block\n         height: UInt64,\n         // hash of the block\n@@ -40,8 +49,7 @@\n \n     /// Transaction executed event is emitted every time a transaction\n     /// is executed by the EVM (even if failed).\n-    access(all)\n-    event TransactionExecuted(\n+    access(all) event TransactionExecuted (\n         // hash of the transaction\n         hash: [UInt8; 32],\n         // index of the transaction in a block\n@@ -79,17 +87,13 @@\n         stateUpdateChecksum: [UInt8; 4]\n     )\n \n-    access(all)\n-    event CadenceOwnedAccountCreated(address: String)\n-\n     /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n     /// into the EVM environment. Note that this event is not emitted\n     /// for transfer of flow tokens between two EVM addresses.\n     /// Similar to the FungibleToken.Deposited event\n     /// this event includes a depositedUUID that captures the\n     /// uuid of the source vault.\n-    access(all)\n-    event FLOWTokensDeposited(\n+    access(all) event FLOWTokensDeposited (\n         address: String,\n         amount: UFix64,\n         depositedUUID: UInt64,\n@@ -102,8 +100,7 @@\n     /// similar to the FungibleToken.Withdrawn events\n     /// this event includes a withdrawnUUID that captures the\n     /// uuid of the returning vault.\n-    access(all)\n-    event FLOWTokensWithdrawn(\n+    access(all) event FLOWTokensWithdrawn (\n         address: String,\n         amount: UFix64,\n         withdrawnUUID: UInt64,\n@@ -113,8 +110,7 @@\n     /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n     /// is updated in the stored BridgeRouter along with identifying\n     /// information about both.\n-    access(all)\n-    event BridgeAccessorUpdated(\n+    access(all) event BridgeAccessorUpdated (\n         routerType: Type,\n         routerUUID: UInt64,\n         routerAddress: Address,\n@@ -123,13 +119,35 @@\n         accessorAddress: Address\n     )\n \n-    /// EVMAddress is an EVM-compatible address\n+     /// Block returns information about the latest executed block.\n+    access(all) struct EVMBlock {\n+        access(all) let height: UInt64\n+\n+        access(all) let hash: String\n+\n+        access(all) let totalSupply: Int\n+\n+        access(all) let timestamp: UInt64\n+\n+        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n+            self.height = height\n+            self.hash = hash\n+            self.totalSupply = totalSupply\n+            self.timestamp = timestamp\n+        }\n+    }\n+\n+    /// Returns the latest executed block.\n     access(all)\n-    struct EVMAddress {\n+    fun getLatestBlock(): EVMBlock {\n+        return InternalEVM.getLatestBlock() as! EVMBlock\n+    }\n \n+    /// EVMAddress is an EVM-compatible address\n+    access(all) struct EVMAddress {\n+\n         /// Bytes of the address\n-        access(all)\n-        let bytes: [UInt8; 20]\n+        access(all) let bytes: [UInt8; 20]\n \n         /// Constructs a new EVM address from the given byte representation\n         view init(bytes: [UInt8; 20]) {\n@@ -174,7 +189,8 @@\n         fun deposit(from: @FlowToken.Vault) {\n             let amount = from.balance\n             if amount == 0.0 {\n-                panic(\"calling deposit function with an empty vault is not allowed\")\n+                destroy from\n+                return\n             }\n             let depositedUUID = from.uuid\n             InternalEVM.deposit(\n@@ -203,14 +219,26 @@\n         }\n     }\n \n+    /// Converts a hex string to an EVM address if the string is a valid hex string\n+    /// Future implementations should pass data to InternalEVM for native deserialization\n+    access(all)\n+    fun addressFromString(_ asHex: String): EVMAddress {\n+        pre {\n+            asHex.length == 40 || asHex.length == 42:\n+                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n+        }\n+        // Strip the 0x prefix if it exists\n+        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n+        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n+        return EVMAddress(bytes: bytes)\n+    }\n+\n     /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes` type\n-    access(all)\n-    struct EVMBytes {\n+    access(all) struct EVMBytes {\n \n         /// Byte array representing the `bytes` value\n-        access(all)\n-        let value: [UInt8]\n+        access(all) let value: [UInt8]\n \n         view init(value: [UInt8]) {\n             self.value = value\n@@ -219,12 +243,10 @@\n \n     /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes4` type\n-    access(all)\n-    struct EVMBytes4 {\n+    access(all) struct EVMBytes4 {\n \n         /// Byte array representing the `bytes4` value\n-        access(all)\n-        let value: [UInt8; 4]\n+        access(all) let value: [UInt8; 4]\n \n         view init(value: [UInt8; 4]) {\n             self.value = value\n@@ -233,40 +253,23 @@\n \n     /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes32` type\n-    access(all)\n-    struct EVMBytes32 {\n+    access(all) struct EVMBytes32 {\n \n         /// Byte array representing the `bytes32` value\n-        access(all)\n-        let value: [UInt8; 32]\n+        access(all) let value: [UInt8; 32]\n \n         view init(value: [UInt8; 32]) {\n             self.value = value\n         }\n     }\n \n-    /// Converts a hex string to an EVM address if the string is a valid hex string\n-    /// Future implementations should pass data to InternalEVM for native deserialization\n-    access(all)\n-    fun addressFromString(_ asHex: String): EVMAddress {\n-        pre {\n-            asHex.length == 40 || asHex.length == 42: \"Invalid hex string length for an EVM address\"\n-        }\n-        // Strip the 0x prefix if it exists\n-        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n-        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n-        return EVMAddress(bytes: bytes)\n-    }\n+    access(all) struct Balance {\n \n-    access(all)\n-    struct Balance {\n-\n         /// The balance in atto-FLOW\n         /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n         /// that is used to store account balances inside EVM\n         /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n-        access(all)\n-        var attoflow: UInt\n+        access(all) var attoflow: UInt\n \n         /// Constructs a new balance\n         access(all)\n@@ -284,7 +274,7 @@\n         /// Casts the balance to a UFix64 (rounding down)\n         /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n         /// (8 decimal points in compare to 18) might result in rounding down error.\n-        /// Use the toAttoFlow function if you care need more accuracy.\n+        /// Use the inAttoFLOW function if you need more accuracy.\n         access(all)\n         view fun inFLOW(): UFix64 {\n             return InternalEVM.castToFLOW(balance: self.attoflow)\n@@ -305,48 +295,44 @@\n \n     /// reports the status of evm execution.\n     access(all) enum Status: UInt8 {\n-        /// is (rarely) returned when status is unknown\n+        /// Returned (rarely) when status is unknown\n         /// and something has gone very wrong.\n         access(all) case unknown\n \n-        /// is returned when execution of an evm transaction/call\n+        /// Returned when execution of an evm transaction/call\n         /// has failed at the validation step (e.g. nonce mismatch).\n         /// An invalid transaction/call is rejected to be executed\n         /// or be included in a block.\n         access(all) case invalid\n \n-        /// is returned when execution of an evm transaction/call\n-        /// has been successful but the vm has reported an error as\n+        /// Returned when execution of an evm transaction/call\n+        /// has been successful but the vm has reported an error in\n         /// the outcome of execution (e.g. running out of gas).\n         /// A failed tx/call is included in a block.\n         /// Note that resubmission of a failed transaction would\n         /// result in invalid status in the second attempt, given\n-        /// the nonce would be come invalid.\n+        /// the nonce would become invalid.\n         access(all) case failed\n \n-        /// is returned when execution of an evm transaction/call\n+        /// Returned when execution of an evm transaction/call\n         /// has been successful and no error is reported by the vm.\n         access(all) case successful\n     }\n \n-    /// reports the outcome of evm transaction/call execution attempt\n+    /// Reports the outcome of an evm transaction/call execution attempt\n     access(all) struct Result {\n         /// status of the execution\n-        access(all)\n-        let status: Status\n+        access(all) let status: Status\n \n         /// error code (error code zero means no error)\n-        access(all)\n-        let errorCode: UInt64\n+        access(all) let errorCode: UInt64\n \n         /// error message\n-        access(all)\n-        let errorMessage: String\n+        access(all) let errorMessage: String\n \n         /// returns the amount of gas metered during\n         /// evm execution\n-        access(all)\n-        let gasUsed: UInt64\n+        access(all) let gasUsed: UInt64\n \n         /// returns the data that is returned from\n         /// the evm for the call. For coa.deploy\n@@ -354,14 +313,12 @@\n         /// the address provided in the contractAddress field.\n         /// in case of revert, the smart contract custom error message\n         /// is also returned here (see EIP-140 for more details).\n-        access(all)\n-        let data: [UInt8]\n+        access(all) let data: [UInt8]\n \n         /// returns the newly deployed contract address\n         /// if the transaction caused such a deployment\n         /// otherwise the value is nil.\n-        access(all)\n-        let deployedContract: EVMAddress?\n+        access(all) let deployedContract: EVMAddress?\n \n         init(\n             status: Status,\n@@ -385,18 +338,61 @@\n         }\n     }\n \n-    access(all)\n-    resource interface Addressable {\n-        /// The EVM address\n+    /* \n+        Cadence-Owned Accounts (COA) \n+        A COA is a natively supported EVM smart contract wallet type \n+        that allows a Cadence resource to own and control an EVM address.\n+        This native wallet provides the primitives needed to bridge\n+        or control assets across Flow EVM and Cadence.\n+        From the EVM perspective, COAs are smart contract wallets\n+        that accept native token transfers and support several ERCs\n+        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n+\n+        COAs are not controlled by a key.\n+        Instead, every COA account has a unique resource accessible\n+        on the Cadence side, and anyone who owns that resource submits transactions\n+        on behalf of this address. These direct transactions have COAs EVM address\n+        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n+        is used to differentiate these transactions from other types\n+        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n+\n+        Because of this, users are never able to access a key for their account,\n+        meaning that they cannot control their COA's address on other EVM blockchains.\n+    */\n+\n+    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n+\n+    /// Allows validating ownership of a COA\n+    access(all) entitlement Validate\n+\n+    /// Allows withdrawing FLOW from the COA back to Cadence\n+    access(all) entitlement Withdraw\n+\n+    /// Allows sending Call transactions from the COA\n+    access(all) entitlement Call\n+\n+    /// Allows sending deploy contract transactions from the COA\n+    access(all) entitlement Deploy\n+\n+    /// Allows access to all the privliged functionality on a COA\n+    access(all) entitlement Owner\n+\n+    /// Allows access to all bridging functionality for COAs\n+    access(all) entitlement Bridge\n+\n+    /// Event that indicates when a new COA is created\n+    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n+\n+    /// Interface for types that have an associated EVM address\n+    access(all) resource interface Addressable {\n+        /// Gets the EVM address\n         access(all)\n         view fun address(): EVMAddress\n     }\n \n-    access(all)\n-    resource CadenceOwnedAccount: Addressable {\n+    access(all) resource CadenceOwnedAccount: Addressable {\n \n-        access(self)\n-        var addressBytes: [UInt8; 20]\n+        access(self) var addressBytes: [UInt8; 20]\n \n         init() {\n             // address is initially set to zero\n@@ -406,50 +397,70 @@\n             self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n         }\n \n+        /// Sets the EVM address for the COA. Only callable once on initial creation.\n+        ///\n+        /// @param addressBytes: The 20 byte EVM address\n+        ///\n+        /// @return the token decimals of the ERC20\n         access(contract)\n         fun initAddress(addressBytes: [UInt8; 20]) {\n-           // only allow set address for the first time\n-           // check address is empty\n-            for item in self.addressBytes {\n-                assert(item == 0, message: \"address byte is not empty\")\n+            // only allow set address for the first time\n+            // check address is empty\n+            pre {\n+                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n+                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n             }\n            self.addressBytes = addressBytes\n         }\n \n-        /// The EVM address of the cadence owned account\n+        /// Gets The EVM address of the cadence owned account\n+        ///\n         access(all)\n         view fun address(): EVMAddress {\n             // Always create a new EVMAddress instance\n             return EVMAddress(bytes: self.addressBytes)\n         }\n \n-        /// Get balance of the cadence owned account\n+        /// Gets the balance of the cadence owned account\n+        ///\n         access(all)\n         view fun balance(): Balance {\n             return self.address().balance()\n         }\n \n         /// Deposits the given vault into the cadence owned account's balance\n+        ///\n+        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n+        ///\n+        /// @return the token decimals of the ERC20\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n             self.address().deposit(from: <-from)\n         }\n \n-        /// The EVM address of the cadence owned account behind an entitlement, acting as proof of access\n+        /// Gets the EVM address of the cadence owned account behind an entitlement,\n+        /// acting as proof of access\n         access(Owner | Validate)\n         view fun protectedAddress(): EVMAddress {\n             return self.address()\n         }\n \n-        /// Withdraws the balance from the cadence owned account's balance\n-        /// Note that amounts smaller than 10nF (10e-8) can't be withdrawn\n-        /// given that Flow Token Vaults use UFix64s to store balances.\n-        /// If the given balance conversion to UFix64 results in\n-        /// rounding error, this function would fail.\n+        /// Withdraws the balance from the cadence owned account's balance.\n+        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n+        /// given that Flow Token Vaults use UFix64 to store balances.\n+        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n+        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n+        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n+        /// If the given balance conversion to UFix64 results in rounding loss,\n+        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n+        ///\n+        /// @param balance: The EVM balance to withdraw\n+        ///\n+        /// @return A FlowToken Vault with the requested balance\n         access(Owner | Withdraw)\n         fun withdraw(balance: Balance): @FlowToken.Vault {\n             if balance.isZero() {\n-                panic(\"calling withdraw function with zero balance is not allowed\")\n+                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n             }\n             let vault <- InternalEVM.withdraw(\n                 from: self.addressBytes,\n@@ -467,6 +447,12 @@\n         /// Deploys a contract to the EVM environment.\n         /// Returns the result which contains address of\n         /// the newly deployed contract\n+        ///\n+        /// @param code: The bytecode of the Solidity contract\n+        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n+        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n+        ///\n+        /// @return The EVM transaction result\n         access(Owner | Deploy)\n         fun deploy(\n             code: [UInt8],\n@@ -518,8 +504,12 @@\n             ) as! Result\n         }\n \n-        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n-        /// the bridge request\n+        /// Bridges the given NFT to the EVM environment, requiring a Provider\n+        /// from which to withdraw a fee to fulfill the bridge request\n+        ///\n+        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n+        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n+        ///                     that contains the fees to be taken to pay for bridging\n         access(all)\n         fun depositNFT(\n             nft: @{NonFungibleToken.NFT},\n@@ -528,8 +518,16 @@\n             EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n         }\n \n-        /// Bridges the given NFT from the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n-        /// the bridge request. Note: the caller should own the requested NFT in EVM\n+        /// Bridges the given NFT from the EVM environment, requiring a Provider\n+        /// from which to withdraw a fee to fulfill the bridge request.\n+        /// Note: the caller has to own the requested NFT in EVM\n+        ///\n+        /// @param type: The Cadence type of the NFT to withdraw\n+        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n+        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n+        ///                     that contains the fees to be taken to pay for bridging\n+        ///\n+        /// @return The requested NFT\n         access(Owner | Bridge)\n         fun withdrawNFT(\n             type: Type,\n@@ -544,8 +542,7 @@\n             )\n         }\n \n-        /// Bridges the given Vault to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n-        /// the bridge request\n+        /// Bridges the given Vault to the EVM environment\n         access(all)\n         fun depositTokens(\n             vault: @{FungibleToken.Vault},\n@@ -579,22 +576,28 @@\n         let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n         acc.initAddress(addressBytes: addr)\n \n-        emit CadenceOwnedAccountCreated(address: acc.address().toString())\n+        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n         return <-acc\n     }\n \n     /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n     /// and deposits the gas fees into the provided coinbase address.\n+    ///\n+    /// @param tx: The rlp-encoded transaction to run\n+    /// @param coinbase: The address of entity to receive the transaction fees\n+    /// for relaying the transaction\n+    ///\n+    /// @return: The transaction result\n     access(all)\n     fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n         return InternalEVM.run(\n-                tx: tx,\n-                coinbase: coinbase.bytes\n+            tx: tx,\n+            coinbase: coinbase.bytes\n         ) as! Result\n     }\n \n-    /// mustRun runs the transaction using EVM.run yet it\n-    /// rollback if the tx execution status is unknown or invalid.\n+    /// mustRun runs the transaction using EVM.run\n+    /// It will rollback if the tx execution status is unknown or invalid.\n     /// Note that this method does not rollback if transaction\n     /// is executed but an vm error is reported as the outcome\n     /// of the execution (status: failed).\n@@ -603,7 +595,7 @@\n         let runResult = self.run(tx: tx, coinbase: coinbase)\n         assert(\n             runResult.status == Status.failed || runResult.status == Status.successful,\n-            message: \"tx is not valid for execution\"\n+            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n         )\n         return runResult\n     }\n@@ -686,7 +678,7 @@\n \n         for byte in methodID {\n             if byte != data.removeFirst() {\n-                panic(\"signature mismatch\")\n+                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n             }\n         }\n \n@@ -694,14 +686,14 @@\n     }\n \n     /// ValidationResult returns the result of COA ownership proof validation\n-    access(all)\n-    struct ValidationResult {\n-        access(all)\n-        let isValid: Bool\n+    access(all) struct ValidationResult {\n \n-        access(all)\n-        let problem: String?\n+        access(all) let isValid: Bool\n \n+        /// If there was a problem with validation, this describes\n+        /// what the problem was\n+        access(all) let problem: String?\n+\n         init(isValid: Bool, problem: String?) {\n             self.isValid = isValid\n             self.problem = problem\n@@ -723,7 +713,8 @@\n         if keyIndices.length != signatures.length {\n             return ValidationResult(\n                 isValid: false,\n-                problem: \"key indices size doesn't match the signatures\"\n+                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n+                         .concat(\" doesn't match the signatures array length!\")\n             )\n         }\n \n@@ -734,7 +725,7 @@\n         let keyList = Crypto.KeyList()\n         var keyListLength = 0\n         let seenAccountKeyIndices: {Int: Int} = {}\n-        for signatureIndex, signature in signatures{\n+        for signatureIndex, signature in signatures {\n             // index of the key on the account\n             let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n             // index of the key in the key list\n@@ -746,7 +737,8 @@\n                     if key.isRevoked {\n                         return ValidationResult(\n                             isValid: false,\n-                            problem: \"account key is revoked\"\n+                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n+                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                         )\n                     }\n \n@@ -765,7 +757,8 @@\n                 } else {\n                     return ValidationResult(\n                         isValid: false,\n-                        problem: \"invalid key index\"\n+                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n+                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                     )\n                 }\n             } else {\n@@ -790,7 +783,8 @@\n         if !isValid{\n             return ValidationResult(\n                 isValid: false,\n-                problem: \"the given signatures are not valid or provide enough weight\"\n+                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n+                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n             )\n         }\n \n@@ -798,7 +792,8 @@\n         if coaRef == nil {\n              return ValidationResult(\n                  isValid: false,\n-                 problem: \"could not borrow bridge account's resource\"\n+                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n+                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n              )\n         }\n \n@@ -808,7 +803,8 @@\n             if item != evmAddress[index] {\n                 return ValidationResult(\n                     isValid: false,\n-                    problem: \"evm address mismatch\"\n+                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n+                             .concat(\"The provided evm address does not match the account's COA address.\")\n                 )\n             }\n         }\n@@ -819,38 +815,8 @@\n         )\n     }\n \n-    /// Block returns information about the latest executed block.\n-    access(all)\n-    struct EVMBlock {\n-        access(all)\n-        let height: UInt64\n-\n-        access(all)\n-        let hash: String\n-\n-        access(all)\n-        let totalSupply: Int\n-\n-        access(all)\n-        let timestamp: UInt64\n-\n-        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n-            self.height = height\n-            self.hash = hash\n-            self.totalSupply = totalSupply\n-            self.timestamp = timestamp\n-        }\n-    }\n-\n-    /// Returns the latest executed block.\n-    access(all)\n-    fun getLatestBlock(): EVMBlock {\n-        return InternalEVM.getLatestBlock() as! EVMBlock\n-    }\n-\n     /// Interface for a resource which acts as an entrypoint to the VM bridge\n-    access(all)\n-    resource interface BridgeAccessor {\n+    access(all) resource interface BridgeAccessor {\n \n         /// Endpoint enabling the bridging of an NFT to EVM\n         access(Bridge)\n@@ -887,21 +852,23 @@\n         ): @{FungibleToken.Vault}\n     }\n \n-    /// Interface which captures a Capability to the bridge Accessor, saving it within the BridgeRouter resource\n-    access(all)\n-    resource interface BridgeRouter {\n+    /// Interface which captures a Capability to the bridge Accessor,\n+    /// saving it within the BridgeRouter resource\n+    access(all) resource interface BridgeRouter {\n \n-        /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n+        /// Returns a reference to the BridgeAccessor designated\n+        /// for internal bridge requests\n         access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n \n         /// Sets the BridgeAccessor Capability in the BridgeRouter\n         access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n             pre {\n-                accessor.check(): \"Invalid BridgeAccessor Capability provided\"\n+                accessor.check(): \n+                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                 emit BridgeAccessorUpdated(\n                     routerType: self.getType(),\n                     routerUUID: self.uuid,\n-                    routerAddress: self.owner?.address ?? panic(\"Router must have an owner to be identified\"),\n+                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                     accessorType: accessor.borrow()!.getType(),\n                     accessorUUID: accessor.borrow()!.uuid,\n                     accessorAddress: accessor.address\n@@ -915,16 +873,17 @@\n     view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n         return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n             ?.borrowBridgeAccessor()\n-            ?? panic(\"Could not borrow reference to the EVM bridge\")\n+            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n     }\n \n     /// The Heartbeat resource controls the block production.\n-    /// It is stored in the storage and used in the Flow protocol to call the heartbeat function once per block.\n-    access(all)\n-    resource Heartbeat {\n-        /// heartbeat calls commit block proposals and forms new blocks including all the\n-        /// recently executed transactions.\n-        /// The Flow protocol makes sure to call this function once per block as a system call.\n+    /// It is stored in the storage and used in the Flow protocol\n+    /// to call the heartbeat function once per block.\n+    access(all) resource Heartbeat {\n+        /// heartbeat calls commit block proposals and forms new blocks\n+        /// including all the recently executed transactions.\n+        /// The Flow protocol makes sure to call this function\n+        /// once per block as a system call.\n         access(all)\n         fun heartbeat() {\n             InternalEVM.commitBlockProposal()\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\n/*\n\n    The Flow EVM contract defines important types and functionality\n    to allow Cadence code and Flow SDKs to interface\n    with the Etherem Virtual Machine environment on Flow.\n\n    The EVM contract emits events when relevant actions happen in Flow EVM\n    such as creating new blocks, executing transactions, and bridging FLOW\n\n    This contract also defines Cadence-Owned Account functionality,\n    which is currently the only way for Cadence code to interact with Flow EVM.\n\n    Additionally, functionality is provided for common EVM types\n    such as addresses, balances, ABIs, transaction results, and more.\n\n    The EVM contract is deployed to the Flow Service Account on every network\n    and many of its functionality is directly connected to the protocol software\n    to allow interaction with the EVM.\n\n    See additional EVM documentation here: https://developers.flow.com/evm/about\n\n*/\n\naccess(all) contract EVM {\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all) event BlockExecuted (\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all) event TransactionExecuted (\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all) event FLOWTokensDeposited (\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all) event FLOWTokensWithdrawn (\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all) event BridgeAccessorUpdated (\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n     /// Block returns information about the latest executed block.\n    access(all) struct EVMBlock {\n        access(all) let height: UInt64\n\n        access(all) let hash: String\n\n        access(all) let totalSupply: Int\n\n        access(all) let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// EVMAddress is an EVM-compatible address\n    access(all) struct EVMAddress {\n\n        /// Bytes of the address\n        access(all) let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let amount = from.balance\n            if amount == 0.0 {\n                destroy from\n                return\n            }\n            let depositedUUID = from.uuid\n            InternalEVM.deposit(\n                from: <-from,\n                to: self.bytes\n            )\n            emit FLOWTokensDeposited(\n                address: self.toString(),\n                amount: amount,\n                depositedUUID: depositedUUID,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42:\n                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all) struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all) let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all) struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all) let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all) struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all) let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    access(all) struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all) var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the inAttoFLOW function if you need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// Returned (rarely) when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// Returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error in\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would become invalid.\n        access(all) case failed\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// Reports the outcome of an evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all) let status: Status\n\n        /// error code (error code zero means no error)\n        access(all) let errorCode: UInt64\n\n        /// error message\n        access(all) let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all) let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all) let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all) let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    /* \n        Cadence-Owned Accounts (COA) \n        A COA is a natively supported EVM smart contract wallet type \n        that allows a Cadence resource to own and control an EVM address.\n        This native wallet provides the primitives needed to bridge\n        or control assets across Flow EVM and Cadence.\n        From the EVM perspective, COAs are smart contract wallets\n        that accept native token transfers and support several ERCs\n        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n\n        COAs are not controlled by a key.\n        Instead, every COA account has a unique resource accessible\n        on the Cadence side, and anyone who owns that resource submits transactions\n        on behalf of this address. These direct transactions have COAs EVM address\n        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n        is used to differentiate these transactions from other types\n        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n\n        Because of this, users are never able to access a key for their account,\n        meaning that they cannot control their COA's address on other EVM blockchains.\n    */\n\n    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n\n    /// Allows validating ownership of a COA\n    access(all) entitlement Validate\n\n    /// Allows withdrawing FLOW from the COA back to Cadence\n    access(all) entitlement Withdraw\n\n    /// Allows sending Call transactions from the COA\n    access(all) entitlement Call\n\n    /// Allows sending deploy contract transactions from the COA\n    access(all) entitlement Deploy\n\n    /// Allows access to all the privliged functionality on a COA\n    access(all) entitlement Owner\n\n    /// Allows access to all bridging functionality for COAs\n    access(all) entitlement Bridge\n\n    /// Event that indicates when a new COA is created\n    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n\n    /// Interface for types that have an associated EVM address\n    access(all) resource interface Addressable {\n        /// Gets the EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all) resource CadenceOwnedAccount: Addressable {\n\n        access(self) var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        /// Sets the EVM address for the COA. Only callable once on initial creation.\n        ///\n        /// @param addressBytes: The 20 byte EVM address\n        ///\n        /// @return the token decimals of the ERC20\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n            // only allow set address for the first time\n            // check address is empty\n            pre {\n                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// Gets The EVM address of the cadence owned account\n        ///\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Gets the balance of the cadence owned account\n        ///\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        ///\n        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n        ///\n        /// @return the token decimals of the ERC20\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            self.address().deposit(from: <-from)\n        }\n\n        /// Gets the EVM address of the cadence owned account behind an entitlement,\n        /// acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance.\n        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n        /// given that Flow Token Vaults use UFix64 to store balances.\n        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n        /// If the given balance conversion to UFix64 results in rounding loss,\n        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n        ///\n        /// @param balance: The EVM balance to withdraw\n        ///\n        /// @return A FlowToken Vault with the requested balance\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            if balance.isZero() {\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            }\n            let vault <- InternalEVM.withdraw(\n                from: self.addressBytes,\n                amount: balance.attoflow\n            ) as! @FlowToken.Vault\n            emit FLOWTokensWithdrawn(\n                address: self.address().toString(),\n                amount: balance.inFLOW(),\n                withdrawnUUID: vault.uuid,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n            return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        ///\n        /// @param code: The bytecode of the Solidity contract\n        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n        ///\n        /// @return The EVM transaction result\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.deploy(\n                from: self.addressBytes,\n                code: code,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.call(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request\n        ///\n        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request.\n        /// Note: the caller has to own the requested NFT in EVM\n        ///\n        /// @param type: The Cadence type of the NFT to withdraw\n        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        ///\n        /// @return The requested NFT\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    ///\n    /// @param tx: The rlp-encoded transaction to run\n    /// @param coinbase: The address of entity to receive the transaction fees\n    /// for relaying the transaction\n    ///\n    /// @return: The transaction result\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        return InternalEVM.run(\n            tx: tx,\n            coinbase: coinbase.bytes\n        ) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run\n    /// It will rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        let runResult = self.run(tx: tx, coinbase: coinbase)\n        assert(\n            runResult.status == Status.failed || runResult.status == Status.successful,\n            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n        )\n        return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        return InternalEVM.batchRun(\n            txs: txs,\n            coinbase: coinbase.bytes,\n        ) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all) struct ValidationResult {\n\n        access(all) let isValid: Bool\n\n        /// If there was a problem with validation, this describes\n        /// what the problem was\n        access(all) let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n                         .concat(\" doesn't match the signatures array length!\")\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures {\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n                             .concat(\"The provided evm address does not match the account's COA address.\")\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all) resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor,\n    /// saving it within the BridgeRouter resource\n    access(all) resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated\n        /// for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check(): \n                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol\n    /// to call the heartbeat function once per block.\n    access(all) resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks\n        /// including all the recently executed transactions.\n        /// The Flow protocol makes sure to call this function\n        /// once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}",
      "valid_from": 138783761,
      "valid_to": null,
      "created_at": "2026-01-13T22:17:50.773Z",
      "deployments": 13,
      "imported_by": [
        "A.04f5ae6bef48c1fc.ERC4626PriceOracles",
        "A.04f5ae6bef48c1fc.ERC4626SinkConnectors",
        "A.04f5ae6bef48c1fc.ERC4626SwapConnectors",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_e43fe00aea059f3a756cf556655b5a27faf9bec5",
        "A.3ddb31a3880d1d8f.SwapConfig",
        "A.a7825d405ac89518.UniswapV3SwapConnectors",
        "A.b1d63873c3cc9f79.FlowYieldVaultsStrategiesV1_1",
        "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils"
      ],
      "imported_count": 8,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/138127369",
      "id": "A.e467b9dd11fa00df.EVM/138303622",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "613171cfe8abe0b70a3a8507adcefa9fbd1908b2fe55ab2cb912cd5166b681ee",
      "status": "ok",
      "diff": "--- 63e53090715c5838f61044a982dd73b691b83c5f2ec8d2ab967387bed950f227.138127369\n+++ 613171cfe8abe0b70a3a8507adcefa9fbd1908b2fe55ab2cb912cd5166b681ee.138303622\n@@ -3,34 +3,21 @@\n import FungibleToken from 0xf233dcee88fe0abe\n import FlowToken from 0x1654653399040a61\n \n-/*\n+access(all)\n+contract EVM {\n \n-    The Flow EVM contract defines important types and functionality\n-    to allow Cadence code and Flow SDKs to interface\n-    with the Etherem Virtual Machine environment on Flow.\n+    // Entitlements enabling finer-grained access control on a CadenceOwnedAccount\n+    access(all) entitlement Validate\n+    access(all) entitlement Withdraw\n+    access(all) entitlement Call\n+    access(all) entitlement Deploy\n+    access(all) entitlement Owner\n+    access(all) entitlement Bridge\n \n-    The EVM contract emits events when relevant actions happen in Flow EVM\n-    such as creating new blocks, executing transactions, and bridging FLOW\n-\n-    This contract also defines Cadence-Owned Account functionality,\n-    which is currently the only way for Cadence code to interact with Flow EVM.\n-\n-    Additionally, functionality is provided for common EVM types\n-    such as addresses, balances, ABIs, transaction results, and more.\n-\n-    The EVM contract is deployed to the Flow Service Account on every network\n-    and many of its functionality is directly connected to the protocol software\n-    to allow interaction with the EVM.\n-\n-    See additional EVM documentation here: https://developers.flow.com/evm/about\n-\n-*/\n-\n-access(all) contract EVM {\n-\n     /// Block executed event is emitted when a new block is created,\n     /// which always happens when a transaction is executed.\n-    access(all) event BlockExecuted (\n+    access(all)\n+    event BlockExecuted(\n         // height or number of the block\n         height: UInt64,\n         // hash of the block\n@@ -53,7 +36,8 @@\n \n     /// Transaction executed event is emitted every time a transaction\n     /// is executed by the EVM (even if failed).\n-    access(all) event TransactionExecuted (\n+    access(all)\n+    event TransactionExecuted(\n         // hash of the transaction\n         hash: [UInt8; 32],\n         // index of the transaction in a block\n@@ -91,13 +75,17 @@\n         stateUpdateChecksum: [UInt8; 4]\n     )\n \n+    access(all)\n+    event CadenceOwnedAccountCreated(address: String)\n+\n     /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n     /// into the EVM environment. Note that this event is not emitted\n     /// for transfer of flow tokens between two EVM addresses.\n     /// Similar to the FungibleToken.Deposited event\n     /// this event includes a depositedUUID that captures the\n     /// uuid of the source vault.\n-    access(all) event FLOWTokensDeposited (\n+    access(all)\n+    event FLOWTokensDeposited(\n         address: String,\n         amount: UFix64,\n         depositedUUID: UInt64,\n@@ -110,7 +92,8 @@\n     /// similar to the FungibleToken.Withdrawn events\n     /// this event includes a withdrawnUUID that captures the\n     /// uuid of the returning vault.\n-    access(all) event FLOWTokensWithdrawn (\n+    access(all)\n+    event FLOWTokensWithdrawn(\n         address: String,\n         amount: UFix64,\n         withdrawnUUID: UInt64,\n@@ -120,7 +103,8 @@\n     /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n     /// is updated in the stored BridgeRouter along with identifying\n     /// information about both.\n-    access(all) event BridgeAccessorUpdated (\n+    access(all)\n+    event BridgeAccessorUpdated(\n         routerType: Type,\n         routerUUID: UInt64,\n         routerAddress: Address,\n@@ -129,35 +113,13 @@\n         accessorAddress: Address\n     )\n \n-     /// Block returns information about the latest executed block.\n-    access(all) struct EVMBlock {\n-        access(all) let height: UInt64\n-\n-        access(all) let hash: String\n-\n-        access(all) let totalSupply: Int\n-\n-        access(all) let timestamp: UInt64\n-\n-        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n-            self.height = height\n-            self.hash = hash\n-            self.totalSupply = totalSupply\n-            self.timestamp = timestamp\n-        }\n-    }\n-\n-    /// Returns the latest executed block.\n+    /// EVMAddress is an EVM-compatible address\n     access(all)\n-    fun getLatestBlock(): EVMBlock {\n-        return InternalEVM.getLatestBlock() as! EVMBlock\n-    }\n+    struct EVMAddress {\n \n-    /// EVMAddress is an EVM-compatible address\n-    access(all) struct EVMAddress {\n-\n         /// Bytes of the address\n-        access(all) let bytes: [UInt8; 20]\n+        access(all)\n+        let bytes: [UInt8; 20]\n \n         /// Constructs a new EVM address from the given byte representation\n         view init(bytes: [UInt8; 20]) {\n@@ -202,8 +161,7 @@\n         fun deposit(from: @FlowToken.Vault) {\n             let amount = from.balance\n             if amount == 0.0 {\n-                destroy from\n-                return\n+                panic(\"calling deposit function with an empty vault is not allowed\")\n             }\n             let depositedUUID = from.uuid\n             InternalEVM.deposit(\n@@ -232,26 +190,14 @@\n         }\n     }\n \n-    /// Converts a hex string to an EVM address if the string is a valid hex string\n-    /// Future implementations should pass data to InternalEVM for native deserialization\n-    access(all)\n-    fun addressFromString(_ asHex: String): EVMAddress {\n-        pre {\n-            asHex.length == 40 || asHex.length == 42:\n-                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n-        }\n-        // Strip the 0x prefix if it exists\n-        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n-        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n-        return EVMAddress(bytes: bytes)\n-    }\n-\n     /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes` type\n-    access(all) struct EVMBytes {\n+    access(all)\n+    struct EVMBytes {\n \n         /// Byte array representing the `bytes` value\n-        access(all) let value: [UInt8]\n+        access(all)\n+        let value: [UInt8]\n \n         view init(value: [UInt8]) {\n             self.value = value\n@@ -260,10 +202,12 @@\n \n     /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes4` type\n-    access(all) struct EVMBytes4 {\n+    access(all)\n+    struct EVMBytes4 {\n \n         /// Byte array representing the `bytes4` value\n-        access(all) let value: [UInt8; 4]\n+        access(all)\n+        let value: [UInt8; 4]\n \n         view init(value: [UInt8; 4]) {\n             self.value = value\n@@ -272,23 +214,40 @@\n \n     /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes32` type\n-    access(all) struct EVMBytes32 {\n+    access(all)\n+    struct EVMBytes32 {\n \n         /// Byte array representing the `bytes32` value\n-        access(all) let value: [UInt8; 32]\n+        access(all)\n+        let value: [UInt8; 32]\n \n         view init(value: [UInt8; 32]) {\n             self.value = value\n         }\n     }\n \n-    access(all) struct Balance {\n+    /// Converts a hex string to an EVM address if the string is a valid hex string\n+    /// Future implementations should pass data to InternalEVM for native deserialization\n+    access(all)\n+    fun addressFromString(_ asHex: String): EVMAddress {\n+        pre {\n+            asHex.length == 40 || asHex.length == 42: \"Invalid hex string length for an EVM address\"\n+        }\n+        // Strip the 0x prefix if it exists\n+        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n+        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n+        return EVMAddress(bytes: bytes)\n+    }\n \n+    access(all)\n+    struct Balance {\n+\n         /// The balance in atto-FLOW\n         /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n         /// that is used to store account balances inside EVM\n         /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n-        access(all) var attoflow: UInt\n+        access(all)\n+        var attoflow: UInt\n \n         /// Constructs a new balance\n         access(all)\n@@ -306,7 +252,7 @@\n         /// Casts the balance to a UFix64 (rounding down)\n         /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n         /// (8 decimal points in compare to 18) might result in rounding down error.\n-        /// Use the inAttoFLOW function if you need more accuracy.\n+        /// Use the toAttoFlow function if you care need more accuracy.\n         access(all)\n         view fun inFLOW(): UFix64 {\n             return InternalEVM.castToFLOW(balance: self.attoflow)\n@@ -327,44 +273,48 @@\n \n     /// reports the status of evm execution.\n     access(all) enum Status: UInt8 {\n-        /// Returned (rarely) when status is unknown\n+        /// is (rarely) returned when status is unknown\n         /// and something has gone very wrong.\n         access(all) case unknown\n \n-        /// Returned when execution of an evm transaction/call\n+        /// is returned when execution of an evm transaction/call\n         /// has failed at the validation step (e.g. nonce mismatch).\n         /// An invalid transaction/call is rejected to be executed\n         /// or be included in a block.\n         access(all) case invalid\n \n-        /// Returned when execution of an evm transaction/call\n-        /// has been successful but the vm has reported an error in\n+        /// is returned when execution of an evm transaction/call\n+        /// has been successful but the vm has reported an error as\n         /// the outcome of execution (e.g. running out of gas).\n         /// A failed tx/call is included in a block.\n         /// Note that resubmission of a failed transaction would\n         /// result in invalid status in the second attempt, given\n-        /// the nonce would become invalid.\n+        /// the nonce would be come invalid.\n         access(all) case failed\n \n-        /// Returned when execution of an evm transaction/call\n+        /// is returned when execution of an evm transaction/call\n         /// has been successful and no error is reported by the vm.\n         access(all) case successful\n     }\n \n-    /// Reports the outcome of an evm transaction/call execution attempt\n+    /// reports the outcome of evm transaction/call execution attempt\n     access(all) struct Result {\n         /// status of the execution\n-        access(all) let status: Status\n+        access(all)\n+        let status: Status\n \n         /// error code (error code zero means no error)\n-        access(all) let errorCode: UInt64\n+        access(all)\n+        let errorCode: UInt64\n \n         /// error message\n-        access(all) let errorMessage: String\n+        access(all)\n+        let errorMessage: String\n \n         /// returns the amount of gas metered during\n         /// evm execution\n-        access(all) let gasUsed: UInt64\n+        access(all)\n+        let gasUsed: UInt64\n \n         /// returns the data that is returned from\n         /// the evm for the call. For coa.deploy\n@@ -372,12 +295,14 @@\n         /// the address provided in the contractAddress field.\n         /// in case of revert, the smart contract custom error message\n         /// is also returned here (see EIP-140 for more details).\n-        access(all) let data: [UInt8]\n+        access(all)\n+        let data: [UInt8]\n \n         /// returns the newly deployed contract address\n         /// if the transaction caused such a deployment\n         /// otherwise the value is nil.\n-        access(all) let deployedContract: EVMAddress?\n+        access(all)\n+        let deployedContract: EVMAddress?\n \n         init(\n             status: Status,\n@@ -401,61 +322,18 @@\n         }\n     }\n \n-    /*\n-        Cadence-Owned Accounts (COA)\n-        A COA is a natively supported EVM smart contract wallet type\n-        that allows a Cadence resource to own and control an EVM address.\n-        This native wallet provides the primitives needed to bridge\n-        or control assets across Flow EVM and Cadence.\n-        From the EVM perspective, COAs are smart contract wallets\n-        that accept native token transfers and support several ERCs\n-        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n-\n-        COAs are not controlled by a key.\n-        Instead, every COA account has a unique resource accessible\n-        on the Cadence side, and anyone who owns that resource submits transactions\n-        on behalf of this address. These direct transactions have COAs EVM address\n-        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n-        is used to differentiate these transactions from other types\n-        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n-\n-        Because of this, users are never able to access a key for their account,\n-        meaning that they cannot control their COA's address on other EVM blockchains.\n-    */\n-\n-    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n-\n-    /// Allows validating ownership of a COA\n-    access(all) entitlement Validate\n-\n-    /// Allows withdrawing FLOW from the COA back to Cadence\n-    access(all) entitlement Withdraw\n-\n-    /// Allows sending Call transactions from the COA\n-    access(all) entitlement Call\n-\n-    /// Allows sending deploy contract transactions from the COA\n-    access(all) entitlement Deploy\n-\n-    /// Allows access to all the privliged functionality on a COA\n-    access(all) entitlement Owner\n-\n-    /// Allows access to all bridging functionality for COAs\n-    access(all) entitlement Bridge\n-\n-    /// Event that indicates when a new COA is created\n-    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n-\n-    /// Interface for types that have an associated EVM address\n-    access(all) resource interface Addressable {\n-        /// Gets the EVM address\n+    access(all)\n+    resource interface Addressable {\n+        /// The EVM address\n         access(all)\n         view fun address(): EVMAddress\n     }\n \n-    access(all) resource CadenceOwnedAccount: Addressable {\n+    access(all)\n+    resource CadenceOwnedAccount: Addressable {\n \n-        access(self) var addressBytes: [UInt8; 20]\n+        access(self)\n+        var addressBytes: [UInt8; 20]\n \n         init() {\n             // address is initially set to zero\n@@ -465,70 +338,50 @@\n             self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n         }\n \n-        /// Sets the EVM address for the COA. Only callable once on initial creation.\n-        ///\n-        /// @param addressBytes: The 20 byte EVM address\n-        ///\n-        /// @return the token decimals of the ERC20\n         access(contract)\n         fun initAddress(addressBytes: [UInt8; 20]) {\n-            // only allow set address for the first time\n-            // check address is empty\n-            pre {\n-                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n-                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n+           // only allow set address for the first time\n+           // check address is empty\n+            for item in self.addressBytes {\n+                assert(item == 0, message: \"address byte is not empty\")\n             }\n            self.addressBytes = addressBytes\n         }\n \n-        /// Gets The EVM address of the cadence owned account\n-        ///\n+        /// The EVM address of the cadence owned account\n         access(all)\n         view fun address(): EVMAddress {\n             // Always create a new EVMAddress instance\n             return EVMAddress(bytes: self.addressBytes)\n         }\n \n-        /// Gets the balance of the cadence owned account\n-        ///\n+        /// Get balance of the cadence owned account\n         access(all)\n         view fun balance(): Balance {\n             return self.address().balance()\n         }\n \n         /// Deposits the given vault into the cadence owned account's balance\n-        ///\n-        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n-        ///\n-        /// @return the token decimals of the ERC20\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n             self.address().deposit(from: <-from)\n         }\n \n-        /// Gets the EVM address of the cadence owned account behind an entitlement,\n-        /// acting as proof of access\n+        /// The EVM address of the cadence owned account behind an entitlement, acting as proof of access\n         access(Owner | Validate)\n         view fun protectedAddress(): EVMAddress {\n             return self.address()\n         }\n \n-        /// Withdraws the balance from the cadence owned account's balance.\n-        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n-        /// given that Flow Token Vaults use UFix64 to store balances.\n-        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n-        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n-        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n-        /// If the given balance conversion to UFix64 results in rounding loss,\n-        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n-        ///\n-        /// @param balance: The EVM balance to withdraw\n-        ///\n-        /// @return A FlowToken Vault with the requested balance\n+        /// Withdraws the balance from the cadence owned account's balance\n+        /// Note that amounts smaller than 10nF (10e-8) can't be withdrawn\n+        /// given that Flow Token Vaults use UFix64s to store balances.\n+        /// If the given balance conversion to UFix64 results in\n+        /// rounding error, this function would fail.\n         access(Owner | Withdraw)\n         fun withdraw(balance: Balance): @FlowToken.Vault {\n             if balance.isZero() {\n-                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n+                panic(\"calling withdraw function with zero balance is not allowed\")\n             }\n             let vault <- InternalEVM.withdraw(\n                 from: self.addressBytes,\n@@ -546,12 +368,6 @@\n         /// Deploys a contract to the EVM environment.\n         /// Returns the result which contains address of\n         /// the newly deployed contract\n-        ///\n-        /// @param code: The bytecode of the Solidity contract\n-        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n-        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n-        ///\n-        /// @return The EVM transaction result\n         access(Owner | Deploy)\n         fun deploy(\n             code: [UInt8],\n@@ -603,12 +419,8 @@\n             ) as! Result\n         }\n \n-        /// Bridges the given NFT to the EVM environment, requiring a Provider\n-        /// from which to withdraw a fee to fulfill the bridge request\n-        ///\n-        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n-        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n-        ///                     that contains the fees to be taken to pay for bridging\n+        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n+        /// the bridge request\n         access(all)\n         fun depositNFT(\n             nft: @{NonFungibleToken.NFT},\n@@ -617,16 +429,8 @@\n             EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n         }\n \n-        /// Bridges the given NFT from the EVM environment, requiring a Provider\n-        /// from which to withdraw a fee to fulfill the bridge request.\n-        /// Note: the caller has to own the requested NFT in EVM\n-        ///\n-        /// @param type: The Cadence type of the NFT to withdraw\n-        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n-        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n-        ///                     that contains the fees to be taken to pay for bridging\n-        ///\n-        /// @return The requested NFT\n+        /// Bridges the given NFT from the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n+        /// the bridge request. Note: the caller should own the requested NFT in EVM\n         access(Owner | Bridge)\n         fun withdrawNFT(\n             type: Type,\n@@ -641,7 +445,8 @@\n             )\n         }\n \n-        /// Bridges the given Vault to the EVM environment\n+        /// Bridges the given Vault to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n+        /// the bridge request\n         access(all)\n         fun depositTokens(\n             vault: @{FungibleToken.Vault},\n@@ -675,28 +480,22 @@\n         let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n         acc.initAddress(addressBytes: addr)\n \n-        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n+        emit CadenceOwnedAccountCreated(address: acc.address().toString())\n         return <-acc\n     }\n \n     /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n     /// and deposits the gas fees into the provided coinbase address.\n-    ///\n-    /// @param tx: The rlp-encoded transaction to run\n-    /// @param coinbase: The address of entity to receive the transaction fees\n-    /// for relaying the transaction\n-    ///\n-    /// @return: The transaction result\n     access(all)\n     fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n         return InternalEVM.run(\n-            tx: tx,\n-            coinbase: coinbase.bytes\n+                tx: tx,\n+                coinbase: coinbase.bytes\n         ) as! Result\n     }\n \n-    /// mustRun runs the transaction using EVM.run\n-    /// It will rollback if the tx execution status is unknown or invalid.\n+    /// mustRun runs the transaction using EVM.run yet it\n+    /// rollback if the tx execution status is unknown or invalid.\n     /// Note that this method does not rollback if transaction\n     /// is executed but an vm error is reported as the outcome\n     /// of the execution (status: failed).\n@@ -705,7 +493,7 @@\n         let runResult = self.run(tx: tx, coinbase: coinbase)\n         assert(\n             runResult.status == Status.failed || runResult.status == Status.successful,\n-            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n+            message: \"tx is not valid for execution\"\n         )\n         return runResult\n     }\n@@ -788,7 +576,7 @@\n \n         for byte in methodID {\n             if byte != data.removeFirst() {\n-                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n+                panic(\"signature mismatch\")\n             }\n         }\n \n@@ -796,14 +584,14 @@\n     }\n \n     /// ValidationResult returns the result of COA ownership proof validation\n-    access(all) struct ValidationResult {\n+    access(all)\n+    struct ValidationResult {\n+        access(all)\n+        let isValid: Bool\n \n-        access(all) let isValid: Bool\n+        access(all)\n+        let problem: String?\n \n-        /// If there was a problem with validation, this describes\n-        /// what the problem was\n-        access(all) let problem: String?\n-\n         init(isValid: Bool, problem: String?) {\n             self.isValid = isValid\n             self.problem = problem\n@@ -825,8 +611,7 @@\n         if keyIndices.length != signatures.length {\n             return ValidationResult(\n                 isValid: false,\n-                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n-                         .concat(\" doesn't match the signatures array length!\")\n+                problem: \"key indices size doesn't match the signatures\"\n             )\n         }\n \n@@ -837,7 +622,7 @@\n         let keyList = Crypto.KeyList()\n         var keyListLength = 0\n         let seenAccountKeyIndices: {Int: Int} = {}\n-        for signatureIndex, signature in signatures {\n+        for signatureIndex, signature in signatures{\n             // index of the key on the account\n             let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n             // index of the key in the key list\n@@ -849,8 +634,7 @@\n                     if key.isRevoked {\n                         return ValidationResult(\n                             isValid: false,\n-                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n-                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n+                            problem: \"account key is revoked\"\n                         )\n                     }\n \n@@ -869,8 +653,7 @@\n                 } else {\n                     return ValidationResult(\n                         isValid: false,\n-                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n-                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n+                        problem: \"invalid key index\"\n                     )\n                 }\n             } else {\n@@ -895,8 +678,7 @@\n         if !isValid{\n             return ValidationResult(\n                 isValid: false,\n-                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n-                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n+                problem: \"the given signatures are not valid or provide enough weight\"\n             )\n         }\n \n@@ -904,8 +686,7 @@\n         if coaRef == nil {\n              return ValidationResult(\n                  isValid: false,\n-                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n-                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n+                 problem: \"could not borrow bridge account's resource\"\n              )\n         }\n \n@@ -915,8 +696,7 @@\n             if item != evmAddress[index] {\n                 return ValidationResult(\n                     isValid: false,\n-                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n-                             .concat(\"The provided evm address does not match the account's COA address.\")\n+                    problem: \"evm address mismatch\"\n                 )\n             }\n         }\n@@ -927,8 +707,38 @@\n         )\n     }\n \n+    /// Block returns information about the latest executed block.\n+    access(all)\n+    struct EVMBlock {\n+        access(all)\n+        let height: UInt64\n+\n+        access(all)\n+        let hash: String\n+\n+        access(all)\n+        let totalSupply: Int\n+\n+        access(all)\n+        let timestamp: UInt64\n+\n+        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n+            self.height = height\n+            self.hash = hash\n+            self.totalSupply = totalSupply\n+            self.timestamp = timestamp\n+        }\n+    }\n+\n+    /// Returns the latest executed block.\n+    access(all)\n+    fun getLatestBlock(): EVMBlock {\n+        return InternalEVM.getLatestBlock() as! EVMBlock\n+    }\n+\n     /// Interface for a resource which acts as an entrypoint to the VM bridge\n-    access(all) resource interface BridgeAccessor {\n+    access(all)\n+    resource interface BridgeAccessor {\n \n         /// Endpoint enabling the bridging of an NFT to EVM\n         access(Bridge)\n@@ -965,23 +774,21 @@\n         ): @{FungibleToken.Vault}\n     }\n \n-    /// Interface which captures a Capability to the bridge Accessor,\n-    /// saving it within the BridgeRouter resource\n-    access(all) resource interface BridgeRouter {\n+    /// Interface which captures a Capability to the bridge Accessor, saving it within the BridgeRouter resource\n+    access(all)\n+    resource interface BridgeRouter {\n \n-        /// Returns a reference to the BridgeAccessor designated\n-        /// for internal bridge requests\n+        /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n         access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n \n         /// Sets the BridgeAccessor Capability in the BridgeRouter\n         access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n             pre {\n-                accessor.check():\n-                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n+                accessor.check(): \"Invalid BridgeAccessor Capability provided\"\n                 emit BridgeAccessorUpdated(\n                     routerType: self.getType(),\n                     routerUUID: self.uuid,\n-                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n+                    routerAddress: self.owner?.address ?? panic(\"Router must have an owner to be identified\"),\n                     accessorType: accessor.borrow()!.getType(),\n                     accessorUUID: accessor.borrow()!.uuid,\n                     accessorAddress: accessor.address\n@@ -995,17 +793,16 @@\n     view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n         return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n             ?.borrowBridgeAccessor()\n-            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n+            ?? panic(\"Could not borrow reference to the EVM bridge\")\n     }\n \n     /// The Heartbeat resource controls the block production.\n-    /// It is stored in the storage and used in the Flow protocol\n-    /// to call the heartbeat function once per block.\n-    access(all) resource Heartbeat {\n-        /// heartbeat calls commit block proposals and forms new blocks\n-        /// including all the recently executed transactions.\n-        /// The Flow protocol makes sure to call this function\n-        /// once per block as a system call.\n+    /// It is stored in the storage and used in the Flow protocol to call the heartbeat function once per block.\n+    access(all)\n+    resource Heartbeat {\n+        /// heartbeat calls commit block proposals and forms new blocks including all the\n+        /// recently executed transactions.\n+        /// The Flow protocol makes sure to call this function once per block as a system call.\n         access(all)\n         fun heartbeat() {\n             InternalEVM.commitBlockProposal()\n@@ -1028,38 +822,6 @@\n         self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n     }\n \n-    /// This is only a temporary measure and will be removed immediately\n-    /// after the remediation of the illicit tokens\n-    // in the Dec 2025 security incident is complete.\n-    /// This function can only be called from the `FlowServiceAccount` contract,\n-    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n-    access(account)\n-    fun reclaimFundsFromAttackerEOAs(from: String, to: String, amount: UInt): Result {\n-        return InternalEVM.call(\n-            from: EVM.addressFromString(from).bytes,\n-            to: EVM.addressFromString(to).bytes,\n-            data: [],\n-            gasLimit: 1_000_000,\n-            value: amount\n-        ) as! Result\n-    }\n-\n-    /// This is only a temporary measure and will be removed immediately\n-    /// after the remediation of the illicit tokens\n-    // in the Dec 2025 security incident is complete.\n-    /// This function can only be called from the `FlowServiceAccount` contract,\n-    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n-    access(account)\n-    fun reclaimERC20FromAttackerEOAs(from: String, to: String, data: [UInt8]): Result {\n-        return InternalEVM.call(\n-            from: EVM.addressFromString(from).bytes,\n-            to: EVM.addressFromString(to).bytes,\n-            data: data,\n-            gasLimit: 16_000_000,\n-            value: UInt(0)\n-        ) as! Result\n-    }\n-\n     init() {\n         self.setupHeartbeat()\n     }\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\naccess(all)\ncontract EVM {\n\n    // Entitlements enabling finer-grained access control on a CadenceOwnedAccount\n    access(all) entitlement Validate\n    access(all) entitlement Withdraw\n    access(all) entitlement Call\n    access(all) entitlement Deploy\n    access(all) entitlement Owner\n    access(all) entitlement Bridge\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all)\n    event BlockExecuted(\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all)\n    event TransactionExecuted(\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    access(all)\n    event CadenceOwnedAccountCreated(address: String)\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all)\n    event FLOWTokensDeposited(\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all)\n    event FLOWTokensWithdrawn(\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all)\n    event BridgeAccessorUpdated(\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n    /// EVMAddress is an EVM-compatible address\n    access(all)\n    struct EVMAddress {\n\n        /// Bytes of the address\n        access(all)\n        let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let amount = from.balance\n            if amount == 0.0 {\n                panic(\"calling deposit function with an empty vault is not allowed\")\n            }\n            let depositedUUID = from.uuid\n            InternalEVM.deposit(\n                from: <-from,\n                to: self.bytes\n            )\n            emit FLOWTokensDeposited(\n                address: self.toString(),\n                amount: amount,\n                depositedUUID: depositedUUID,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all)\n    struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all)\n        let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all)\n    struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all)\n        let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all)\n    struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all)\n        let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42: \"Invalid hex string length for an EVM address\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    access(all)\n    struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all)\n        var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the toAttoFlow function if you care need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// is (rarely) returned when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// is returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// is returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error as\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would be come invalid.\n        access(all) case failed\n\n        /// is returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// reports the outcome of evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all)\n        let status: Status\n\n        /// error code (error code zero means no error)\n        access(all)\n        let errorCode: UInt64\n\n        /// error message\n        access(all)\n        let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all)\n        let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all)\n        let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all)\n        let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    access(all)\n    resource interface Addressable {\n        /// The EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all)\n    resource CadenceOwnedAccount: Addressable {\n\n        access(self)\n        var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n           // only allow set address for the first time\n           // check address is empty\n            for item in self.addressBytes {\n                assert(item == 0, message: \"address byte is not empty\")\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// The EVM address of the cadence owned account\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Get balance of the cadence owned account\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            self.address().deposit(from: <-from)\n        }\n\n        /// The EVM address of the cadence owned account behind an entitlement, acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance\n        /// Note that amounts smaller than 10nF (10e-8) can't be withdrawn\n        /// given that Flow Token Vaults use UFix64s to store balances.\n        /// If the given balance conversion to UFix64 results in\n        /// rounding error, this function would fail.\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            if balance.isZero() {\n                panic(\"calling withdraw function with zero balance is not allowed\")\n            }\n            let vault <- InternalEVM.withdraw(\n                from: self.addressBytes,\n                amount: balance.attoflow\n            ) as! @FlowToken.Vault\n            emit FLOWTokensWithdrawn(\n                address: self.address().toString(),\n                amount: balance.inFLOW(),\n                withdrawnUUID: vault.uuid,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n            return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.deploy(\n                from: self.addressBytes,\n                code: code,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.call(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n        /// the bridge request\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n        /// the bridge request. Note: the caller should own the requested NFT in EVM\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n        /// the bridge request\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString())\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        return InternalEVM.run(\n                tx: tx,\n                coinbase: coinbase.bytes\n        ) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run yet it\n    /// rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        let runResult = self.run(tx: tx, coinbase: coinbase)\n        assert(\n            runResult.status == Status.failed || runResult.status == Status.successful,\n            message: \"tx is not valid for execution\"\n        )\n        return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        return InternalEVM.batchRun(\n            txs: txs,\n            coinbase: coinbase.bytes,\n        ) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"signature mismatch\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all)\n    struct ValidationResult {\n        access(all)\n        let isValid: Bool\n\n        access(all)\n        let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"key indices size doesn't match the signatures\"\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures{\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"account key is revoked\"\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"invalid key index\"\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"the given signatures are not valid or provide enough weight\"\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"could not borrow bridge account's resource\"\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"evm address mismatch\"\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Block returns information about the latest executed block.\n    access(all)\n    struct EVMBlock {\n        access(all)\n        let height: UInt64\n\n        access(all)\n        let hash: String\n\n        access(all)\n        let totalSupply: Int\n\n        access(all)\n        let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all)\n    resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor, saving it within the BridgeRouter resource\n    access(all)\n    resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check(): \"Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"Router must have an owner to be identified\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"Could not borrow reference to the EVM bridge\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol to call the heartbeat function once per block.\n    access(all)\n    resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks including all the\n        /// recently executed transactions.\n        /// The Flow protocol makes sure to call this function once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}",
      "valid_from": 138303622,
      "valid_to": 138783760,
      "created_at": "2026-01-09T00:08:43.776Z",
      "deployments": 13,
      "imported_by": [
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_d069d989e2f44b70c65347d1853c0c67e10a9f8d",
        "A.a7825d405ac89518.UniswapV3SwapConnectors",
        "A.b1d63873c3cc9f79.FlowYieldVaultsStrategiesV1_1",
        "A.b1d63873c3cc9f79.PMStrategiesV1"
      ],
      "imported_count": 4,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "FlowServiceAccount",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowServiceAccount/138127570",
      "id": "A.e467b9dd11fa00df.FlowServiceAccount/138301163",
      "identifier": "A.e467b9dd11fa00df.FlowServiceAccount",
      "transaction_hash": "7e6121bc89f741532091286a0eb62c22fb2a62b5adcbbd9a7d63d436030ade8b",
      "status": "ok",
      "diff": "--- 97298622dcab71dbee1887b64aba3362a36fe3644678137007f2d67e98006078.138127570\n+++ 7e6121bc89f741532091286a0eb62c22fb2a62b5adcbbd9a7d63d436030ade8b.138301163\n@@ -3,7 +3,6 @@\n import FlowFees from 0xf919ee77447b7497\n import FlowStorageFees from 0xe467b9dd11fa00df\n import FlowExecutionParameters from 0xf426ff57ee8f6110\n-import EVM from 0xe467b9dd11fa00df\n \n access(all) contract FlowServiceAccount {\n \n@@ -186,20 +185,6 @@\n                 emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n             }\n         }\n-\n-        /// This is only a temporary measure and will be removed immediately\n-        /// after the remediation of the minted tokens is complete\n-        access(all)\n-        fun governanceDirectCall(from: String, to: String, amount: UInt): EVM.Result {\n-            return EVM.reclaimFundsFromAttackerEOAs(from: from, to: to, amount: amount)\n-        }\n-\n-        /// This is only a temporary measure and will be removed immediately\n-        /// after the remediation of the minted tokens is complete\n-        access(all)\n-        fun reclaimERC20FromAttackerEOAs(from: String, to: String, data: [UInt8]): EVM.Result {\n-            return EVM.reclaimERC20FromAttackerEOAs(from: from, to: to, data: data)\n-        }\n     }\n \n     init() {\n",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowFees from 0xf919ee77447b7497\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport FlowExecutionParameters from 0xf426ff57ee8f6110\n\naccess(all) contract FlowServiceAccount {\n\n    access(all) event TransactionFeeUpdated(newFee: UFix64)\n\n    access(all) event AccountCreationFeeUpdated(newFee: UFix64)\n\n    access(all) event AccountCreatorAdded(accountCreator: Address)\n\n    access(all) event AccountCreatorRemoved(accountCreator: Address)\n\n    access(all) event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    access(all) var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    access(all) var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    access(all) fun initDefaultToken(_ acct: auth(SaveValue, Capabilities) &Account) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.storage.save(<-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>()), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        let receiverCapability = acct.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)\n        acct.capabilities.publish(receiverCapability, at: /public/flowTokenReceiver)\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        let balanceCapability = acct.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)\n        acct.capabilities.publish(balanceCapability, at: /public/flowTokenBalance)\n    }\n\n    /// Get the default token balance on an account\n    ///\n    /// Returns 0 if the account has no default balance\n    access(all) view fun defaultTokenBalance(_ acct: &Account): UFix64 {\n        var balance = 0.0\n        if let balanceRef = acct.capabilities.borrow<&FlowToken.Vault>(/public/flowTokenBalance) {\n            balance = balanceRef.balance\n        }\n\n        return balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    access(all) view fun defaultTokenVault(_ acct: auth(BorrowValue) &Account): auth(FungibleToken.Withdraw) &FlowToken.Vault {\n        return acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Will be deprecated and can be deleted after the switchover to FlowFees.deductTransactionFee\n    ///\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    access(all) fun deductTransactionFee(_ acct: auth(BorrowValue) &Account) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        var feeAmount = self.transactionFee\n        if self.transactionFee > tokenVault.balance {\n            feeAmount = tokenVault.balance\n        }\n\n        let feeVault <- tokenVault.withdraw(amount: feeAmount)\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    access(all) fun setupNewAccount(\n        newAccount: auth(SaveValue, BorrowValue, Capabilities) &Account,\n        payer: auth(BorrowValue) &Account\n    ) {\n\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    access(all) view fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    access(all) view fun isAccountCreationRestricted(): Bool {\n        return self.account.storage.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    access(all) view fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    // Gets Execution Effort Weights from the service account's storage\n    access(all) view fun getExecutionEffortWeights(): {UInt64: UInt64} {\n        return FlowExecutionParameters.getExecutionEffortWeights()\n    }\n\n    // Gets Execution Memory Weights from the service account's storage\n    access(all) view fun getExecutionMemoryWeights(): {UInt64: UInt64} {\n        return FlowExecutionParameters.getExecutionMemoryWeights()\n    }\n\n    // Gets Execution Memory Limit from the service account's storage\n    access(all) view fun getExecutionMemoryLimit(): UInt64 {\n        return FlowExecutionParameters.getExecutionMemoryLimit()\n    }\n\n    /// Authorization resource to change the fields of the contract\n    access(all) resource Administrator {\n\n        /// Sets the transaction fee\n        access(all) fun setTransactionFee(_ newFee: UFix64) {\n            if newFee != FlowServiceAccount.transactionFee {\n                emit TransactionFeeUpdated(newFee: newFee)\n            }\n            FlowServiceAccount.transactionFee = newFee\n        }\n\n        /// Sets the account creation fee\n        access(all) fun setAccountCreationFee(_ newFee: UFix64) {\n            if newFee != FlowServiceAccount.accountCreationFee {\n                emit AccountCreationFeeUpdated(newFee: newFee)\n            }\n            FlowServiceAccount.accountCreationFee = newFee\n        }\n\n        /// Adds an account address as an authorized account creator\n        access(all) fun addAccountCreator(_ accountCreator: Address) {\n            if FlowServiceAccount.accountCreators[accountCreator] == nil {\n                emit AccountCreatorAdded(accountCreator: accountCreator)\n            }\n            FlowServiceAccount.accountCreators[accountCreator] = true\n        }\n\n        /// Removes an account address as an authorized account creator\n        access(all) fun removeAccountCreator(_ accountCreator: Address) {\n            if FlowServiceAccount.accountCreators[accountCreator] != nil {\n                emit AccountCreatorRemoved(accountCreator: accountCreator)\n            }\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n        }\n\n         access(all) fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.storage.load<Bool>(from: path)\n            FlowServiceAccount.account.storage.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.storage.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}",
      "valid_from": 138301163,
      "valid_to": null,
      "created_at": "2026-01-08T23:28:17.797Z",
      "deployments": 12,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 5,
      "tags": null
    },
    {
      "name": "FlowServiceAccount",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowServiceAccount/137605379",
      "id": "A.e467b9dd11fa00df.FlowServiceAccount/138127570",
      "identifier": "A.e467b9dd11fa00df.FlowServiceAccount",
      "transaction_hash": "97298622dcab71dbee1887b64aba3362a36fe3644678137007f2d67e98006078",
      "status": "ok",
      "diff": "--- 83a8df8d43b519e598ac9b0b1df2cb57164b5e6f14e9e66ed188d27aeff0276e.137605379\n+++ 97298622dcab71dbee1887b64aba3362a36fe3644678137007f2d67e98006078.138127570\n@@ -74,7 +74,7 @@\n         if self.transactionFee > tokenVault.balance {\n             feeAmount = tokenVault.balance\n         }\n-        \n+\n         let feeVault <- tokenVault.withdraw(amount: feeAmount)\n         FlowFees.deposit(from: <-feeVault)\n     }\n@@ -128,12 +128,12 @@\n         return self.accountCreators.keys\n     }\n \n-    // Gets Execution Effort Weights from the service account's storage \n+    // Gets Execution Effort Weights from the service account's storage\n     access(all) view fun getExecutionEffortWeights(): {UInt64: UInt64} {\n         return FlowExecutionParameters.getExecutionEffortWeights()\n     }\n \n-    // Gets Execution Memory Weights from the service account's storage \n+    // Gets Execution Memory Weights from the service account's storage\n     access(all) view fun getExecutionMemoryWeights(): {UInt64: UInt64} {\n         return FlowExecutionParameters.getExecutionMemoryWeights()\n     }\n@@ -193,6 +189,13 @@\n         fun governanceDirectCall(from: String, to: String, amount: UInt): EVM.Result {\n             return EVM.reclaimFundsFromAttackerEOAs(from: from, to: to, amount: amount)\n         }\n+\n+        /// This is only a temporary measure and will be removed immediately\n+        /// after the remediation of the minted tokens is complete\n+        access(all)\n+        fun reclaimERC20FromAttackerEOAs(from: String, to: String, data: [UInt8]): EVM.Result {\n+            return EVM.reclaimERC20FromAttackerEOAs(from: from, to: to, data: data)\n+        }\n     }\n \n     init() {\n@@ -206,4 +209,4 @@\n \n         self.account.storage.save(<-admin, to: /storage/flowServiceAdmin)\n     }\n-}\n+}\n\\ No newline at end of file\n",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowFees from 0xf919ee77447b7497\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport FlowExecutionParameters from 0xf426ff57ee8f6110\nimport EVM from 0xe467b9dd11fa00df\n\naccess(all) contract FlowServiceAccount {\n\n    access(all) event TransactionFeeUpdated(newFee: UFix64)\n\n    access(all) event AccountCreationFeeUpdated(newFee: UFix64)\n\n    access(all) event AccountCreatorAdded(accountCreator: Address)\n\n    access(all) event AccountCreatorRemoved(accountCreator: Address)\n\n    access(all) event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    access(all) var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    access(all) var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    access(all) fun initDefaultToken(_ acct: auth(SaveValue, Capabilities) &Account) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.storage.save(<-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>()), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        let receiverCapability = acct.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)\n        acct.capabilities.publish(receiverCapability, at: /public/flowTokenReceiver)\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        let balanceCapability = acct.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)\n        acct.capabilities.publish(balanceCapability, at: /public/flowTokenBalance)\n    }\n\n    /// Get the default token balance on an account\n    ///\n    /// Returns 0 if the account has no default balance\n    access(all) view fun defaultTokenBalance(_ acct: &Account): UFix64 {\n        var balance = 0.0\n        if let balanceRef = acct.capabilities.borrow<&FlowToken.Vault>(/public/flowTokenBalance) {\n            balance = balanceRef.balance\n        }\n\n        return balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    access(all) view fun defaultTokenVault(_ acct: auth(BorrowValue) &Account): auth(FungibleToken.Withdraw) &FlowToken.Vault {\n        return acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Will be deprecated and can be deleted after the switchover to FlowFees.deductTransactionFee\n    ///\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    access(all) fun deductTransactionFee(_ acct: auth(BorrowValue) &Account) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        var feeAmount = self.transactionFee\n        if self.transactionFee > tokenVault.balance {\n            feeAmount = tokenVault.balance\n        }\n\n        let feeVault <- tokenVault.withdraw(amount: feeAmount)\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    access(all) fun setupNewAccount(\n        newAccount: auth(SaveValue, BorrowValue, Capabilities) &Account,\n        payer: auth(BorrowValue) &Account\n    ) {\n\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    access(all) view fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    access(all) view fun isAccountCreationRestricted(): Bool {\n        return self.account.storage.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    access(all) view fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    // Gets Execution Effort Weights from the service account's storage\n    access(all) view fun getExecutionEffortWeights(): {UInt64: UInt64} {\n        return FlowExecutionParameters.getExecutionEffortWeights()\n    }\n\n    // Gets Execution Memory Weights from the service account's storage\n    access(all) view fun getExecutionMemoryWeights(): {UInt64: UInt64} {\n        return FlowExecutionParameters.getExecutionMemoryWeights()\n    }\n\n    // Gets Execution Memory Limit from the service account's storage\n    access(all) view fun getExecutionMemoryLimit(): UInt64 {\n        return FlowExecutionParameters.getExecutionMemoryLimit()\n    }\n\n    /// Authorization resource to change the fields of the contract\n    access(all) resource Administrator {\n\n        /// Sets the transaction fee\n        access(all) fun setTransactionFee(_ newFee: UFix64) {\n            if newFee != FlowServiceAccount.transactionFee {\n                emit TransactionFeeUpdated(newFee: newFee)\n            }\n            FlowServiceAccount.transactionFee = newFee\n        }\n\n        /// Sets the account creation fee\n        access(all) fun setAccountCreationFee(_ newFee: UFix64) {\n            if newFee != FlowServiceAccount.accountCreationFee {\n                emit AccountCreationFeeUpdated(newFee: newFee)\n            }\n            FlowServiceAccount.accountCreationFee = newFee\n        }\n\n        /// Adds an account address as an authorized account creator\n        access(all) fun addAccountCreator(_ accountCreator: Address) {\n            if FlowServiceAccount.accountCreators[accountCreator] == nil {\n                emit AccountCreatorAdded(accountCreator: accountCreator)\n            }\n            FlowServiceAccount.accountCreators[accountCreator] = true\n        }\n\n        /// Removes an account address as an authorized account creator\n        access(all) fun removeAccountCreator(_ accountCreator: Address) {\n            if FlowServiceAccount.accountCreators[accountCreator] != nil {\n                emit AccountCreatorRemoved(accountCreator: accountCreator)\n            }\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n        }\n\n         access(all) fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.storage.load<Bool>(from: path)\n            FlowServiceAccount.account.storage.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n\n        /// This is only a temporary measure and will be removed immediately\n        /// after the remediation of the minted tokens is complete\n        access(all)\n        fun governanceDirectCall(from: String, to: String, amount: UInt): EVM.Result {\n            return EVM.reclaimFundsFromAttackerEOAs(from: from, to: to, amount: amount)\n        }\n\n        /// This is only a temporary measure and will be removed immediately\n        /// after the remediation of the minted tokens is complete\n        access(all)\n        fun reclaimERC20FromAttackerEOAs(from: String, to: String, data: [UInt8]): EVM.Result {\n            return EVM.reclaimERC20FromAttackerEOAs(from: from, to: to, data: data)\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.storage.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}",
      "valid_from": 138127570,
      "valid_to": 138301162,
      "created_at": "2026-01-06T22:42:10.049Z",
      "deployments": 12,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 6,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/137764971",
      "id": "A.e467b9dd11fa00df.EVM/138127369",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "63e53090715c5838f61044a982dd73b691b83c5f2ec8d2ab967387bed950f227",
      "status": "ok",
      "diff": "--- 0b5312110b73221bdccff55d3907f88fdc5944fa6ad181a848695cc84fde6ec3.137764971\n+++ 63e53090715c5838f61044a982dd73b691b83c5f2ec8d2ab967387bed950f227.138127369\n@@ -1044,6 +1044,22 @@\n         ) as! Result\n     }\n \n+    /// This is only a temporary measure and will be removed immediately\n+    /// after the remediation of the illicit tokens\n+    // in the Dec 2025 security incident is complete.\n+    /// This function can only be called from the `FlowServiceAccount` contract,\n+    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n+    access(account)\n+    fun reclaimERC20FromAttackerEOAs(from: String, to: String, data: [UInt8]): Result {\n+        return InternalEVM.call(\n+            from: EVM.addressFromString(from).bytes,\n+            to: EVM.addressFromString(to).bytes,\n+            data: data,\n+            gasLimit: 16_000_000,\n+            value: UInt(0)\n+        ) as! Result\n+    }\n+\n     init() {\n         self.setupHeartbeat()\n     }\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\n/*\n\n    The Flow EVM contract defines important types and functionality\n    to allow Cadence code and Flow SDKs to interface\n    with the Etherem Virtual Machine environment on Flow.\n\n    The EVM contract emits events when relevant actions happen in Flow EVM\n    such as creating new blocks, executing transactions, and bridging FLOW\n\n    This contract also defines Cadence-Owned Account functionality,\n    which is currently the only way for Cadence code to interact with Flow EVM.\n\n    Additionally, functionality is provided for common EVM types\n    such as addresses, balances, ABIs, transaction results, and more.\n\n    The EVM contract is deployed to the Flow Service Account on every network\n    and many of its functionality is directly connected to the protocol software\n    to allow interaction with the EVM.\n\n    See additional EVM documentation here: https://developers.flow.com/evm/about\n\n*/\n\naccess(all) contract EVM {\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all) event BlockExecuted (\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all) event TransactionExecuted (\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all) event FLOWTokensDeposited (\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all) event FLOWTokensWithdrawn (\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all) event BridgeAccessorUpdated (\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n     /// Block returns information about the latest executed block.\n    access(all) struct EVMBlock {\n        access(all) let height: UInt64\n\n        access(all) let hash: String\n\n        access(all) let totalSupply: Int\n\n        access(all) let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// EVMAddress is an EVM-compatible address\n    access(all) struct EVMAddress {\n\n        /// Bytes of the address\n        access(all) let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let amount = from.balance\n            if amount == 0.0 {\n                destroy from\n                return\n            }\n            let depositedUUID = from.uuid\n            InternalEVM.deposit(\n                from: <-from,\n                to: self.bytes\n            )\n            emit FLOWTokensDeposited(\n                address: self.toString(),\n                amount: amount,\n                depositedUUID: depositedUUID,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42:\n                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all) struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all) let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all) struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all) let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all) struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all) let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    access(all) struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all) var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the inAttoFLOW function if you need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// Returned (rarely) when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// Returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error in\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would become invalid.\n        access(all) case failed\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// Reports the outcome of an evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all) let status: Status\n\n        /// error code (error code zero means no error)\n        access(all) let errorCode: UInt64\n\n        /// error message\n        access(all) let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all) let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all) let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all) let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    /*\n        Cadence-Owned Accounts (COA)\n        A COA is a natively supported EVM smart contract wallet type\n        that allows a Cadence resource to own and control an EVM address.\n        This native wallet provides the primitives needed to bridge\n        or control assets across Flow EVM and Cadence.\n        From the EVM perspective, COAs are smart contract wallets\n        that accept native token transfers and support several ERCs\n        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n\n        COAs are not controlled by a key.\n        Instead, every COA account has a unique resource accessible\n        on the Cadence side, and anyone who owns that resource submits transactions\n        on behalf of this address. These direct transactions have COAs EVM address\n        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n        is used to differentiate these transactions from other types\n        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n\n        Because of this, users are never able to access a key for their account,\n        meaning that they cannot control their COA's address on other EVM blockchains.\n    */\n\n    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n\n    /// Allows validating ownership of a COA\n    access(all) entitlement Validate\n\n    /// Allows withdrawing FLOW from the COA back to Cadence\n    access(all) entitlement Withdraw\n\n    /// Allows sending Call transactions from the COA\n    access(all) entitlement Call\n\n    /// Allows sending deploy contract transactions from the COA\n    access(all) entitlement Deploy\n\n    /// Allows access to all the privliged functionality on a COA\n    access(all) entitlement Owner\n\n    /// Allows access to all bridging functionality for COAs\n    access(all) entitlement Bridge\n\n    /// Event that indicates when a new COA is created\n    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n\n    /// Interface for types that have an associated EVM address\n    access(all) resource interface Addressable {\n        /// Gets the EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all) resource CadenceOwnedAccount: Addressable {\n\n        access(self) var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        /// Sets the EVM address for the COA. Only callable once on initial creation.\n        ///\n        /// @param addressBytes: The 20 byte EVM address\n        ///\n        /// @return the token decimals of the ERC20\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n            // only allow set address for the first time\n            // check address is empty\n            pre {\n                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// Gets The EVM address of the cadence owned account\n        ///\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Gets the balance of the cadence owned account\n        ///\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        ///\n        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n        ///\n        /// @return the token decimals of the ERC20\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            self.address().deposit(from: <-from)\n        }\n\n        /// Gets the EVM address of the cadence owned account behind an entitlement,\n        /// acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance.\n        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n        /// given that Flow Token Vaults use UFix64 to store balances.\n        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n        /// If the given balance conversion to UFix64 results in rounding loss,\n        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n        ///\n        /// @param balance: The EVM balance to withdraw\n        ///\n        /// @return A FlowToken Vault with the requested balance\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            if balance.isZero() {\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            }\n            let vault <- InternalEVM.withdraw(\n                from: self.addressBytes,\n                amount: balance.attoflow\n            ) as! @FlowToken.Vault\n            emit FLOWTokensWithdrawn(\n                address: self.address().toString(),\n                amount: balance.inFLOW(),\n                withdrawnUUID: vault.uuid,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n            return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        ///\n        /// @param code: The bytecode of the Solidity contract\n        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n        ///\n        /// @return The EVM transaction result\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.deploy(\n                from: self.addressBytes,\n                code: code,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.call(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request\n        ///\n        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request.\n        /// Note: the caller has to own the requested NFT in EVM\n        ///\n        /// @param type: The Cadence type of the NFT to withdraw\n        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        ///\n        /// @return The requested NFT\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    ///\n    /// @param tx: The rlp-encoded transaction to run\n    /// @param coinbase: The address of entity to receive the transaction fees\n    /// for relaying the transaction\n    ///\n    /// @return: The transaction result\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        return InternalEVM.run(\n            tx: tx,\n            coinbase: coinbase.bytes\n        ) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run\n    /// It will rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        let runResult = self.run(tx: tx, coinbase: coinbase)\n        assert(\n            runResult.status == Status.failed || runResult.status == Status.successful,\n            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n        )\n        return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        return InternalEVM.batchRun(\n            txs: txs,\n            coinbase: coinbase.bytes,\n        ) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all) struct ValidationResult {\n\n        access(all) let isValid: Bool\n\n        /// If there was a problem with validation, this describes\n        /// what the problem was\n        access(all) let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n                         .concat(\" doesn't match the signatures array length!\")\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures {\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n                             .concat(\"The provided evm address does not match the account's COA address.\")\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all) resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor,\n    /// saving it within the BridgeRouter resource\n    access(all) resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated\n        /// for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check():\n                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol\n    /// to call the heartbeat function once per block.\n    access(all) resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks\n        /// including all the recently executed transactions.\n        /// The Flow protocol makes sure to call this function\n        /// once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    /// This is only a temporary measure and will be removed immediately\n    /// after the remediation of the illicit tokens\n    // in the Dec 2025 security incident is complete.\n    /// This function can only be called from the `FlowServiceAccount` contract,\n    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n    access(account)\n    fun reclaimFundsFromAttackerEOAs(from: String, to: String, amount: UInt): Result {\n        return InternalEVM.call(\n            from: EVM.addressFromString(from).bytes,\n            to: EVM.addressFromString(to).bytes,\n            data: [],\n            gasLimit: 1_000_000,\n            value: amount\n        ) as! Result\n    }\n\n    /// This is only a temporary measure and will be removed immediately\n    /// after the remediation of the illicit tokens\n    // in the Dec 2025 security incident is complete.\n    /// This function can only be called from the `FlowServiceAccount` contract,\n    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n    access(account)\n    fun reclaimERC20FromAttackerEOAs(from: String, to: String, data: [UInt8]): Result {\n        return InternalEVM.call(\n            from: EVM.addressFromString(from).bytes,\n            to: EVM.addressFromString(to).bytes,\n            data: data,\n            gasLimit: 16_000_000,\n            value: UInt(0)\n        ) as! Result\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}",
      "valid_from": 138127369,
      "valid_to": 138303621,
      "created_at": "2026-01-06T22:38:49.282Z",
      "deployments": 13,
      "imported_by": [
        "A.e467b9dd11fa00df.FlowServiceAccount"
      ],
      "imported_count": 1,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/137691627",
      "id": "A.e467b9dd11fa00df.EVM/137764971",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "0b5312110b73221bdccff55d3907f88fdc5944fa6ad181a848695cc84fde6ec3",
      "status": "ok",
      "diff": "--- a17c1017efa3d21542e29fc0a407dbfbd86ae82d55a9732d7a7cd77b556c5e33.137691627\n+++ 0b5312110b73221bdccff55d3907f88fdc5944fa6ad181a848695cc84fde6ec3.137764971\n@@ -200,13 +200,6 @@\n         /// Deposits the given vault into the EVM account with the given address\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n-            let address: String = self.toString().toLower()\n-            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n-            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n-            if !(address == allowedAddress1 || address == allowedAddress2) {\n-                panic(\"EVM deposits are temporarily disabled\")\n-            }\n-\n             let amount = from.balance\n             if amount == 0.0 {\n                 destroy from\n@@ -408,9 +401,9 @@\n         }\n     }\n \n-    /* \n-        Cadence-Owned Accounts (COA) \n-        A COA is a natively supported EVM smart contract wallet type \n+    /*\n+        Cadence-Owned Accounts (COA)\n+        A COA is a natively supported EVM smart contract wallet type\n         that allows a Cadence resource to own and control an EVM address.\n         This native wallet provides the primitives needed to bridge\n         or control assets across Flow EVM and Cadence.\n@@ -510,13 +503,6 @@\n         /// @return the token decimals of the ERC20\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n-            let address: String = self.address().toString().toLower()\n-            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n-            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n-            if !(address == allowedAddress1 || address == allowedAddress2) {\n-                panic(\"EVM deposits are temporarily disabled\")\n-            }\n-\n             self.address().deposit(from: <-from)\n         }\n \n@@ -541,13 +527,6 @@\n         /// @return A FlowToken Vault with the requested balance\n         access(Owner | Withdraw)\n         fun withdraw(balance: Balance): @FlowToken.Vault {\n-            let address: String = self.address().toString().toLower()\n-            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n-            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n-            if !(address == allowedAddress1 || address == allowedAddress2) {\n-                panic(\"EVM deposits are temporarily disabled\")\n-            }\n-\n             if balance.isZero() {\n                 return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n             }\n@@ -579,13 +558,6 @@\n             gasLimit: UInt64,\n             value: Balance\n         ): Result {\n-            let address: String = self.address().toString().toLower()\n-            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n-            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n-            if !(address == allowedAddress1 || address == allowedAddress2) {\n-                panic(\"EVM deposits are temporarily disabled\")\n-            }\n-\n             return InternalEVM.deploy(\n                 from: self.addressBytes,\n                 code: code,\n@@ -603,13 +575,6 @@\n             gasLimit: UInt64,\n             value: Balance\n         ): Result {\n-            let address: String = self.address().toString().toLower()\n-            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n-            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n-            if !(address == allowedAddress1 || address == allowedAddress2) {\n-                panic(\"EVM deposits are temporarily disabled\")\n-            }\n-\n             return InternalEVM.call(\n                 from: self.addressBytes,\n                 to: to.bytes,\n@@ -1011,7 +976,7 @@\n         /// Sets the BridgeAccessor Capability in the BridgeRouter\n         access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n             pre {\n-                accessor.check(): \n+                accessor.check():\n                     \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                 emit BridgeAccessorUpdated(\n                     routerType: self.getType(),\n@@ -1064,7 +1029,8 @@\n     }\n \n     /// This is only a temporary measure and will be removed immediately\n-    /// after the remediation of the minted tokens is complete.\n+    /// after the remediation of the illicit tokens\n+    // in the Dec 2025 security incident is complete.\n     /// This function can only be called from the `FlowServiceAccount` contract,\n     /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n     access(account)\n@@ -1081,4 +1047,4 @@\n     init() {\n         self.setupHeartbeat()\n     }\n-}\n+}\n\\ No newline at end of file\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\n/*\n\n    The Flow EVM contract defines important types and functionality\n    to allow Cadence code and Flow SDKs to interface\n    with the Etherem Virtual Machine environment on Flow.\n\n    The EVM contract emits events when relevant actions happen in Flow EVM\n    such as creating new blocks, executing transactions, and bridging FLOW\n\n    This contract also defines Cadence-Owned Account functionality,\n    which is currently the only way for Cadence code to interact with Flow EVM.\n\n    Additionally, functionality is provided for common EVM types\n    such as addresses, balances, ABIs, transaction results, and more.\n\n    The EVM contract is deployed to the Flow Service Account on every network\n    and many of its functionality is directly connected to the protocol software\n    to allow interaction with the EVM.\n\n    See additional EVM documentation here: https://developers.flow.com/evm/about\n\n*/\n\naccess(all) contract EVM {\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all) event BlockExecuted (\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all) event TransactionExecuted (\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all) event FLOWTokensDeposited (\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all) event FLOWTokensWithdrawn (\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all) event BridgeAccessorUpdated (\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n     /// Block returns information about the latest executed block.\n    access(all) struct EVMBlock {\n        access(all) let height: UInt64\n\n        access(all) let hash: String\n\n        access(all) let totalSupply: Int\n\n        access(all) let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// EVMAddress is an EVM-compatible address\n    access(all) struct EVMAddress {\n\n        /// Bytes of the address\n        access(all) let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let amount = from.balance\n            if amount == 0.0 {\n                destroy from\n                return\n            }\n            let depositedUUID = from.uuid\n            InternalEVM.deposit(\n                from: <-from,\n                to: self.bytes\n            )\n            emit FLOWTokensDeposited(\n                address: self.toString(),\n                amount: amount,\n                depositedUUID: depositedUUID,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42:\n                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all) struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all) let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all) struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all) let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all) struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all) let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    access(all) struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all) var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the inAttoFLOW function if you need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// Returned (rarely) when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// Returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error in\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would become invalid.\n        access(all) case failed\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// Reports the outcome of an evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all) let status: Status\n\n        /// error code (error code zero means no error)\n        access(all) let errorCode: UInt64\n\n        /// error message\n        access(all) let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all) let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all) let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all) let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    /*\n        Cadence-Owned Accounts (COA)\n        A COA is a natively supported EVM smart contract wallet type\n        that allows a Cadence resource to own and control an EVM address.\n        This native wallet provides the primitives needed to bridge\n        or control assets across Flow EVM and Cadence.\n        From the EVM perspective, COAs are smart contract wallets\n        that accept native token transfers and support several ERCs\n        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n\n        COAs are not controlled by a key.\n        Instead, every COA account has a unique resource accessible\n        on the Cadence side, and anyone who owns that resource submits transactions\n        on behalf of this address. These direct transactions have COAs EVM address\n        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n        is used to differentiate these transactions from other types\n        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n\n        Because of this, users are never able to access a key for their account,\n        meaning that they cannot control their COA's address on other EVM blockchains.\n    */\n\n    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n\n    /// Allows validating ownership of a COA\n    access(all) entitlement Validate\n\n    /// Allows withdrawing FLOW from the COA back to Cadence\n    access(all) entitlement Withdraw\n\n    /// Allows sending Call transactions from the COA\n    access(all) entitlement Call\n\n    /// Allows sending deploy contract transactions from the COA\n    access(all) entitlement Deploy\n\n    /// Allows access to all the privliged functionality on a COA\n    access(all) entitlement Owner\n\n    /// Allows access to all bridging functionality for COAs\n    access(all) entitlement Bridge\n\n    /// Event that indicates when a new COA is created\n    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n\n    /// Interface for types that have an associated EVM address\n    access(all) resource interface Addressable {\n        /// Gets the EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all) resource CadenceOwnedAccount: Addressable {\n\n        access(self) var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        /// Sets the EVM address for the COA. Only callable once on initial creation.\n        ///\n        /// @param addressBytes: The 20 byte EVM address\n        ///\n        /// @return the token decimals of the ERC20\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n            // only allow set address for the first time\n            // check address is empty\n            pre {\n                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// Gets The EVM address of the cadence owned account\n        ///\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Gets the balance of the cadence owned account\n        ///\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        ///\n        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n        ///\n        /// @return the token decimals of the ERC20\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            self.address().deposit(from: <-from)\n        }\n\n        /// Gets the EVM address of the cadence owned account behind an entitlement,\n        /// acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance.\n        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n        /// given that Flow Token Vaults use UFix64 to store balances.\n        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n        /// If the given balance conversion to UFix64 results in rounding loss,\n        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n        ///\n        /// @param balance: The EVM balance to withdraw\n        ///\n        /// @return A FlowToken Vault with the requested balance\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            if balance.isZero() {\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            }\n            let vault <- InternalEVM.withdraw(\n                from: self.addressBytes,\n                amount: balance.attoflow\n            ) as! @FlowToken.Vault\n            emit FLOWTokensWithdrawn(\n                address: self.address().toString(),\n                amount: balance.inFLOW(),\n                withdrawnUUID: vault.uuid,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n            return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        ///\n        /// @param code: The bytecode of the Solidity contract\n        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n        ///\n        /// @return The EVM transaction result\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.deploy(\n                from: self.addressBytes,\n                code: code,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.call(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request\n        ///\n        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request.\n        /// Note: the caller has to own the requested NFT in EVM\n        ///\n        /// @param type: The Cadence type of the NFT to withdraw\n        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        ///\n        /// @return The requested NFT\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    ///\n    /// @param tx: The rlp-encoded transaction to run\n    /// @param coinbase: The address of entity to receive the transaction fees\n    /// for relaying the transaction\n    ///\n    /// @return: The transaction result\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        return InternalEVM.run(\n            tx: tx,\n            coinbase: coinbase.bytes\n        ) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run\n    /// It will rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        let runResult = self.run(tx: tx, coinbase: coinbase)\n        assert(\n            runResult.status == Status.failed || runResult.status == Status.successful,\n            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n        )\n        return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        return InternalEVM.batchRun(\n            txs: txs,\n            coinbase: coinbase.bytes,\n        ) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all) struct ValidationResult {\n\n        access(all) let isValid: Bool\n\n        /// If there was a problem with validation, this describes\n        /// what the problem was\n        access(all) let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n                         .concat(\" doesn't match the signatures array length!\")\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures {\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n                             .concat(\"The provided evm address does not match the account's COA address.\")\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all) resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor,\n    /// saving it within the BridgeRouter resource\n    access(all) resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated\n        /// for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check():\n                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol\n    /// to call the heartbeat function once per block.\n    access(all) resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks\n        /// including all the recently executed transactions.\n        /// The Flow protocol makes sure to call this function\n        /// once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    /// This is only a temporary measure and will be removed immediately\n    /// after the remediation of the illicit tokens\n    // in the Dec 2025 security incident is complete.\n    /// This function can only be called from the `FlowServiceAccount` contract,\n    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n    access(account)\n    fun reclaimFundsFromAttackerEOAs(from: String, to: String, amount: UInt): Result {\n        return InternalEVM.call(\n            from: EVM.addressFromString(from).bytes,\n            to: EVM.addressFromString(to).bytes,\n            data: [],\n            gasLimit: 1_000_000,\n            value: amount\n        ) as! Result\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}",
      "valid_from": 137764971,
      "valid_to": 138127368,
      "created_at": "2026-01-02T15:49:53.211Z",
      "deployments": 13,
      "imported_by": [
        "A.b13b21a06b75536d.SwapKeepAliveHandlerV2"
      ],
      "imported_count": 1,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/137605218",
      "id": "A.e467b9dd11fa00df.EVM/137691627",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "a17c1017efa3d21542e29fc0a407dbfbd86ae82d55a9732d7a7cd77b556c5e33",
      "status": "ok",
      "diff": "--- 49904bf75cbf5f96f925b8d3d81d89a9af778afe378f7e586d19c45b6d6aa714.137605218\n+++ a17c1017efa3d21542e29fc0a407dbfbd86ae82d55a9732d7a7cd77b556c5e33.137691627\n@@ -200,24 +200,29 @@\n         /// Deposits the given vault into the EVM account with the given address\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n-            panic(\"EVM deposits are temporarily disabled\")\n+            let address: String = self.toString().toLower()\n+            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n+            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n+            if !(address == allowedAddress1 || address == allowedAddress2) {\n+                panic(\"EVM deposits are temporarily disabled\")\n+            }\n \n-            //let amount = from.balance\n-            //if amount == 0.0 {\n-            //    destroy from\n-            //    return\n-            //}\n-            //let depositedUUID = from.uuid\n-            //InternalEVM.deposit(\n-            //    from: <-from,\n-            //    to: self.bytes\n-            //)\n-            //emit FLOWTokensDeposited(\n-            //    address: self.toString(),\n-            //    amount: amount,\n-            //    depositedUUID: depositedUUID,\n-            //    balanceAfterInAttoFlow: self.balance().attoflow\n-            //)\n+            let amount = from.balance\n+            if amount == 0.0 {\n+                destroy from\n+                return\n+            }\n+            let depositedUUID = from.uuid\n+            InternalEVM.deposit(\n+                from: <-from,\n+                to: self.bytes\n+            )\n+            emit FLOWTokensDeposited(\n+                address: self.toString(),\n+                amount: amount,\n+                depositedUUID: depositedUUID,\n+                balanceAfterInAttoFlow: self.balance().attoflow\n+            )\n         }\n \n         /// Serializes the address to a hex string without the 0x prefix\n@@ -505,9 +509,14 @@\n         /// @return the token decimals of the ERC20\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n-            panic(\"EVM deposits are temporarily disabled\")\n+            let address: String = self.address().toString().toLower()\n+            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n+            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n+            if !(address == allowedAddress1 || address == allowedAddress2) {\n+                panic(\"EVM deposits are temporarily disabled\")\n+            }\n \n-            //self.address().deposit(from: <-from)\n+            self.address().deposit(from: <-from)\n         }\n \n         /// Gets the EVM address of the cadence owned account behind an entitlement,\n@@ -531,22 +539,27 @@\n         /// @return A FlowToken Vault with the requested balance\n         access(Owner | Withdraw)\n         fun withdraw(balance: Balance): @FlowToken.Vault {\n-            panic(\"EVM withdrawals are temporarily disabled\")\n+            let address: String = self.address().toString().toLower()\n+            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n+            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n+            if !(address == allowedAddress1 || address == allowedAddress2) {\n+                panic(\"EVM deposits are temporarily disabled\")\n+            }\n \n-            //if balance.isZero() {\n-            //    return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n-            //}\n-            //let vault <- InternalEVM.withdraw(\n-            //    from: self.addressBytes,\n-            //    amount: balance.attoflow\n-            //) as! @FlowToken.Vault\n-            //emit FLOWTokensWithdrawn(\n-            //    address: self.address().toString(),\n-            //    amount: balance.inFLOW(),\n-            //    withdrawnUUID: vault.uuid,\n-            //    balanceAfterInAttoFlow: self.balance().attoflow\n-            //)\n-            //return <-vault\n+            if balance.isZero() {\n+                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n+            }\n+            let vault <- InternalEVM.withdraw(\n+                from: self.addressBytes,\n+                amount: balance.attoflow\n+            ) as! @FlowToken.Vault\n+            emit FLOWTokensWithdrawn(\n+                address: self.address().toString(),\n+                amount: balance.inFLOW(),\n+                withdrawnUUID: vault.uuid,\n+                balanceAfterInAttoFlow: self.balance().attoflow\n+            )\n+            return <-vault\n         }\n \n         /// Deploys a contract to the EVM environment.\n@@ -564,14 +576,19 @@\n             gasLimit: UInt64,\n             value: Balance\n         ): Result {\n-            panic(\"EVM transactions are temporarily disabled\")\n+            let address: String = self.address().toString().toLower()\n+            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n+            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n+            if !(address == allowedAddress1 || address == allowedAddress2) {\n+                panic(\"EVM deposits are temporarily disabled\")\n+            }\n \n-            //return InternalEVM.deploy(\n-            //    from: self.addressBytes,\n-            //    code: code,\n-            //    gasLimit: gasLimit,\n-            //    value: value.attoflow\n-            //) as! Result\n+            return InternalEVM.deploy(\n+                from: self.addressBytes,\n+                code: code,\n+                gasLimit: gasLimit,\n+                value: value.attoflow\n+            ) as! Result\n         }\n \n         /// Calls a function with the given data.\n@@ -583,15 +599,20 @@\n             gasLimit: UInt64,\n             value: Balance\n         ): Result {\n-            panic(\"EVM transactions are temporarily disabled\")\n+            let address: String = self.address().toString().toLower()\n+            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n+            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n+            if !(address == allowedAddress1 || address == allowedAddress2) {\n+                panic(\"EVM deposits are temporarily disabled\")\n+            }\n \n-            //return InternalEVM.call(\n-            //    from: self.addressBytes,\n-            //    to: to.bytes,\n-            //    data: data,\n-            //    gasLimit: gasLimit,\n-            //    value: value.attoflow\n-            //) as! Result\n+            return InternalEVM.call(\n+                from: self.addressBytes,\n+                to: to.bytes,\n+                data: data,\n+                gasLimit: gasLimit,\n+                value: value.attoflow\n+            ) as! Result\n         }\n \n         /// Calls a contract function with the given data.\n@@ -699,12 +719,10 @@\n     /// @return: The transaction result\n     access(all)\n     fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n-        panic(\"EVM transactions are temporarily disabled\")\n-\n-        //return InternalEVM.run(\n-        //        tx: tx,\n-        //        coinbase: coinbase.bytes\n-        //) as! Result\n+        return InternalEVM.run(\n+            tx: tx,\n+            coinbase: coinbase.bytes\n+        ) as! Result\n     }\n \n     /// mustRun runs the transaction using EVM.run\n@@ -714,14 +732,12 @@\n     /// of the execution (status: failed).\n     access(all)\n     fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n-        panic(\"EVM transactions are temporarily disabled\")\n-\n-        //let runResult = self.run(tx: tx, coinbase: coinbase)\n-        //assert(\n-        //    runResult.status == Status.failed || runResult.status == Status.successful,\n-        //    message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n-        //)\n-        //return runResult\n+        let runResult = self.run(tx: tx, coinbase: coinbase)\n+        assert(\n+            runResult.status == Status.failed || runResult.status == Status.successful,\n+            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n+        )\n+        return runResult\n     }\n \n     /// Simulates running unsigned RLP-encoded transaction using\n@@ -761,12 +777,10 @@\n     /// An invalid transaction is not executed and not included in the block.\n     access(all)\n     fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n-        panic(\"EVM transactions are temporarily disabled\")\n-\n-        //return InternalEVM.batchRun(\n-        //    txs: txs,\n-        //    coinbase: coinbase.bytes,\n-        //) as! [Result]\n+        return InternalEVM.batchRun(\n+            txs: txs,\n+            coinbase: coinbase.bytes,\n+        ) as! [Result]\n     }\n \n     access(all)\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\n/*\n\n    The Flow EVM contract defines important types and functionality\n    to allow Cadence code and Flow SDKs to interface\n    with the Etherem Virtual Machine environment on Flow.\n\n    The EVM contract emits events when relevant actions happen in Flow EVM\n    such as creating new blocks, executing transactions, and bridging FLOW\n\n    This contract also defines Cadence-Owned Account functionality,\n    which is currently the only way for Cadence code to interact with Flow EVM.\n\n    Additionally, functionality is provided for common EVM types\n    such as addresses, balances, ABIs, transaction results, and more.\n\n    The EVM contract is deployed to the Flow Service Account on every network\n    and many of its functionality is directly connected to the protocol software\n    to allow interaction with the EVM.\n\n    See additional EVM documentation here: https://developers.flow.com/evm/about\n\n*/\n\naccess(all) contract EVM {\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all) event BlockExecuted (\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all) event TransactionExecuted (\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all) event FLOWTokensDeposited (\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all) event FLOWTokensWithdrawn (\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all) event BridgeAccessorUpdated (\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n     /// Block returns information about the latest executed block.\n    access(all) struct EVMBlock {\n        access(all) let height: UInt64\n\n        access(all) let hash: String\n\n        access(all) let totalSupply: Int\n\n        access(all) let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// EVMAddress is an EVM-compatible address\n    access(all) struct EVMAddress {\n\n        /// Bytes of the address\n        access(all) let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let address: String = self.toString().toLower()\n            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n            if !(address == allowedAddress1 || address == allowedAddress2) {\n                panic(\"EVM deposits are temporarily disabled\")\n            }\n\n            let amount = from.balance\n            if amount == 0.0 {\n                destroy from\n                return\n            }\n            let depositedUUID = from.uuid\n            InternalEVM.deposit(\n                from: <-from,\n                to: self.bytes\n            )\n            emit FLOWTokensDeposited(\n                address: self.toString(),\n                amount: amount,\n                depositedUUID: depositedUUID,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42:\n                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all) struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all) let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all) struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all) let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all) struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all) let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    access(all) struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all) var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the inAttoFLOW function if you need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// Returned (rarely) when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// Returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error in\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would become invalid.\n        access(all) case failed\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// Reports the outcome of an evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all) let status: Status\n\n        /// error code (error code zero means no error)\n        access(all) let errorCode: UInt64\n\n        /// error message\n        access(all) let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all) let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all) let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all) let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    /* \n        Cadence-Owned Accounts (COA) \n        A COA is a natively supported EVM smart contract wallet type \n        that allows a Cadence resource to own and control an EVM address.\n        This native wallet provides the primitives needed to bridge\n        or control assets across Flow EVM and Cadence.\n        From the EVM perspective, COAs are smart contract wallets\n        that accept native token transfers and support several ERCs\n        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n\n        COAs are not controlled by a key.\n        Instead, every COA account has a unique resource accessible\n        on the Cadence side, and anyone who owns that resource submits transactions\n        on behalf of this address. These direct transactions have COAs EVM address\n        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n        is used to differentiate these transactions from other types\n        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n\n        Because of this, users are never able to access a key for their account,\n        meaning that they cannot control their COA's address on other EVM blockchains.\n    */\n\n    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n\n    /// Allows validating ownership of a COA\n    access(all) entitlement Validate\n\n    /// Allows withdrawing FLOW from the COA back to Cadence\n    access(all) entitlement Withdraw\n\n    /// Allows sending Call transactions from the COA\n    access(all) entitlement Call\n\n    /// Allows sending deploy contract transactions from the COA\n    access(all) entitlement Deploy\n\n    /// Allows access to all the privliged functionality on a COA\n    access(all) entitlement Owner\n\n    /// Allows access to all bridging functionality for COAs\n    access(all) entitlement Bridge\n\n    /// Event that indicates when a new COA is created\n    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n\n    /// Interface for types that have an associated EVM address\n    access(all) resource interface Addressable {\n        /// Gets the EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all) resource CadenceOwnedAccount: Addressable {\n\n        access(self) var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        /// Sets the EVM address for the COA. Only callable once on initial creation.\n        ///\n        /// @param addressBytes: The 20 byte EVM address\n        ///\n        /// @return the token decimals of the ERC20\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n            // only allow set address for the first time\n            // check address is empty\n            pre {\n                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// Gets The EVM address of the cadence owned account\n        ///\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Gets the balance of the cadence owned account\n        ///\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        ///\n        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n        ///\n        /// @return the token decimals of the ERC20\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let address: String = self.address().toString().toLower()\n            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n            if !(address == allowedAddress1 || address == allowedAddress2) {\n                panic(\"EVM deposits are temporarily disabled\")\n            }\n\n            self.address().deposit(from: <-from)\n        }\n\n        /// Gets the EVM address of the cadence owned account behind an entitlement,\n        /// acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance.\n        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n        /// given that Flow Token Vaults use UFix64 to store balances.\n        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n        /// If the given balance conversion to UFix64 results in rounding loss,\n        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n        ///\n        /// @param balance: The EVM balance to withdraw\n        ///\n        /// @return A FlowToken Vault with the requested balance\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            let address: String = self.address().toString().toLower()\n            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n            if !(address == allowedAddress1 || address == allowedAddress2) {\n                panic(\"EVM deposits are temporarily disabled\")\n            }\n\n            if balance.isZero() {\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            }\n            let vault <- InternalEVM.withdraw(\n                from: self.addressBytes,\n                amount: balance.attoflow\n            ) as! @FlowToken.Vault\n            emit FLOWTokensWithdrawn(\n                address: self.address().toString(),\n                amount: balance.inFLOW(),\n                withdrawnUUID: vault.uuid,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n            return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        ///\n        /// @param code: The bytecode of the Solidity contract\n        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n        ///\n        /// @return The EVM transaction result\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            let address: String = self.address().toString().toLower()\n            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n            if !(address == allowedAddress1 || address == allowedAddress2) {\n                panic(\"EVM deposits are temporarily disabled\")\n            }\n\n            return InternalEVM.deploy(\n                from: self.addressBytes,\n                code: code,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            let address: String = self.address().toString().toLower()\n            let allowedAddress1: String = \"0000000000000000000000029d7005cab847dcdf\".toLower()\n            let allowedAddress2: String = \"00000000000000000000000249250a5C27Ecab3B\".toLower()\n            if !(address == allowedAddress1 || address == allowedAddress2) {\n                panic(\"EVM deposits are temporarily disabled\")\n            }\n\n            return InternalEVM.call(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request\n        ///\n        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request.\n        /// Note: the caller has to own the requested NFT in EVM\n        ///\n        /// @param type: The Cadence type of the NFT to withdraw\n        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        ///\n        /// @return The requested NFT\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    ///\n    /// @param tx: The rlp-encoded transaction to run\n    /// @param coinbase: The address of entity to receive the transaction fees\n    /// for relaying the transaction\n    ///\n    /// @return: The transaction result\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        return InternalEVM.run(\n            tx: tx,\n            coinbase: coinbase.bytes\n        ) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run\n    /// It will rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        let runResult = self.run(tx: tx, coinbase: coinbase)\n        assert(\n            runResult.status == Status.failed || runResult.status == Status.successful,\n            message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n        )\n        return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        return InternalEVM.batchRun(\n            txs: txs,\n            coinbase: coinbase.bytes,\n        ) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all) struct ValidationResult {\n\n        access(all) let isValid: Bool\n\n        /// If there was a problem with validation, this describes\n        /// what the problem was\n        access(all) let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n                         .concat(\" doesn't match the signatures array length!\")\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures {\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n                             .concat(\"The provided evm address does not match the account's COA address.\")\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all) resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor,\n    /// saving it within the BridgeRouter resource\n    access(all) resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated\n        /// for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check(): \n                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol\n    /// to call the heartbeat function once per block.\n    access(all) resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks\n        /// including all the recently executed transactions.\n        /// The Flow protocol makes sure to call this function\n        /// once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    /// This is only a temporary measure and will be removed immediately\n    /// after the remediation of the minted tokens is complete.\n    /// This function can only be called from the `FlowServiceAccount` contract,\n    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n    access(account)\n    fun reclaimFundsFromAttackerEOAs(from: String, to: String, amount: UInt): Result {\n        return InternalEVM.call(\n            from: EVM.addressFromString(from).bytes,\n            to: EVM.addressFromString(to).bytes,\n            data: [],\n            gasLimit: 1_000_000,\n            value: amount\n        ) as! Result\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}\n",
      "valid_from": 137691627,
      "valid_to": 137764970,
      "created_at": "2026-01-01T19:02:43.135Z",
      "deployments": 13,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "RetrieveFraudulentTokensEvents",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": null,
      "id": "A.e467b9dd11fa00df.RetrieveFraudulentTokensEvents/137606081",
      "identifier": "A.e467b9dd11fa00df.RetrieveFraudulentTokensEvents",
      "transaction_hash": "9cc90b203d564ea182f2cb7480b287a282b3fef15c7b98c661e88015fbff42a8",
      "status": "ok",
      "diff": "",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport EVM from 0xe467b9dd11fa00df\n\n/// Contract deployed to the service account to emit events when fraudulent tokens\n/// from the Dec 27th, 2025 attack are retrieved or destroyed\n/// This is to have transparency with the actions the service account committee takes\n/// to reconcile the fraudulent tokens\n\naccess(all) contract RetrieveFraudulentTokensEvents {\n\n    access(all) let adminStoragePath: StoragePath\n\n    /// Event emitted when fraudulent tokens are retrieved from any address and stored in the service account's vault\n    /// for later destruction\n    /// @param typeIdentifier - The type identifier of the fraudulent tokens\n    /// @param amount - The amount of fraudulent tokens retrieved\n    /// @param fromAddress - The address from which the fraudulent tokens were retrieved.\n    ///                      This can be a Cadence Address, a COA Address, or an EOA Address.\n    access(all) event FraudulentTokensRetrieved(typeIdentifier: String, amount: UFix64, fromAddress: String)\n\n    /// Event emitted when fraudulent tokens are destroyed from the service account's vault\n    /// @param typeIdentifier - The type identifier of the fraudulent tokens to be destroyed\n    /// @param amount - The amount of fraudulent tokens destroyed\n    access(all) event FraudulentTokensDestroyed(typeIdentifier: String, amount: UFix64)\n\n    /// Resource that allows only the service account admin to emit the events\n    access(all) resource Admin {\n\n        /// Emits the FraudulentTokensRetrieved event\n        access(all) fun emitRetrieveTokensEvent(typeIdentifier: String, amount: UFix64, fromAddress: String) {\n            emit FraudulentTokensRetrieved(typeIdentifier: typeIdentifier, amount: amount, fromAddress: fromAddress)\n        }\n        \n        /// Emits the FraudulentTokensDestroyed event\n        access(all) fun emitDestroyTokensEvent(typeIdentifier: String, amount: UFix64) {\n            emit FraudulentTokensDestroyed(typeIdentifier: typeIdentifier, amount: amount)\n        }\n    }\n\n    init() {\n\n        self.adminStoragePath = /storage/serviceAccountAdmin\n\n        // Create a new ServiceAccountAdmin resource\n        self.account.storage.save(<-create Admin(), to: self.adminStoragePath)\n\n        // Store a new FlowToken Vault at a non-standard storage path to hold fraudulent tokens\n        let emptyVault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n        self.account.storage.save(<-emptyVault, to: /storage/fraudulentFlowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        let receiverCapability = self.account.capabilities.storage.issue<&FlowToken.Vault>(/storage/fraudulentFlowTokenVault)\n        self.account.capabilities.publish(receiverCapability, at: /public/fraudulentFlowTokenReceiver)\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        let balanceCapability = self.account.capabilities.storage.issue<&FlowToken.Vault>(/storage/fraudulentFlowTokenVault)\n        self.account.capabilities.publish(balanceCapability, at: /public/fraudulentFlowTokenBalance)\n\n        // Create a new array to store the COAs to be destroyed\n        let newCoaArray: @[EVM.CadenceOwnedAccount] <- []\n        self.account.storage.save(<-newCoaArray, to: /storage/coaArrayToDestroy)\n\n        /* --- Configure COA --- */\n        //\n        // Ensure there is not yet a CadenceOwnedAccount in the standard path\n        let coaPath = /storage/evm\n        if self.account.storage.type(at: coaPath) != nil {\n            panic(\n                \"COA already exists in the service account at path=\\(coaPath)\"\n                .concat(\". Make sure the signing account does not already have a CadenceOwnedAccount.\")\n            )\n        }\n        // COA not found in standard path, create and publish a public **unentitled** capability\n        self.account.storage.save(<-EVM.createCadenceOwnedAccount(), to: coaPath)\n        let coaCapability = self.account.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(coaPath)\n        self.account.capabilities.publish(coaCapability, at: /public/evm)\n    }\n}",
      "valid_from": 137606081,
      "valid_to": null,
      "created_at": "2025-12-31T18:49:31.76Z",
      "deployments": 1,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "FlowServiceAccount",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowServiceAccount/102344248",
      "id": "A.e467b9dd11fa00df.FlowServiceAccount/137605379",
      "identifier": "A.e467b9dd11fa00df.FlowServiceAccount",
      "transaction_hash": "83a8df8d43b519e598ac9b0b1df2cb57164b5e6f14e9e66ed188d27aeff0276e",
      "status": "ok",
      "diff": "--- a39b473868f4f6a80440499cc3afefa02a77a2b81e7c85918076dffce93691e4.102344248\n+++ 83a8df8d43b519e598ac9b0b1df2cb57164b5e6f14e9e66ed188d27aeff0276e.137605379\n@@ -3,6 +3,7 @@\n import FlowFees from 0xf919ee77447b7497\n import FlowStorageFees from 0xe467b9dd11fa00df\n import FlowExecutionParameters from 0xf426ff57ee8f6110\n+import EVM from 0xe467b9dd11fa00df\n \n access(all) contract FlowServiceAccount {\n \n@@ -185,6 +186,13 @@\n                 emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n             }\n         }\n+\n+        /// This is only a temporary measure and will be removed immediately\n+        /// after the remediation of the minted tokens is complete\n+        access(all)\n+        fun governanceDirectCall(from: String, to: String, amount: UInt): EVM.Result {\n+            return EVM.reclaimFundsFromAttackerEOAs(from: from, to: to, amount: amount)\n+        }\n     }\n \n     init() {\n",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowFees from 0xf919ee77447b7497\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport FlowExecutionParameters from 0xf426ff57ee8f6110\nimport EVM from 0xe467b9dd11fa00df\n\naccess(all) contract FlowServiceAccount {\n\n    access(all) event TransactionFeeUpdated(newFee: UFix64)\n\n    access(all) event AccountCreationFeeUpdated(newFee: UFix64)\n\n    access(all) event AccountCreatorAdded(accountCreator: Address)\n\n    access(all) event AccountCreatorRemoved(accountCreator: Address)\n\n    access(all) event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    access(all) var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    access(all) var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    access(all) fun initDefaultToken(_ acct: auth(SaveValue, Capabilities) &Account) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.storage.save(<-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>()), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        let receiverCapability = acct.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)\n        acct.capabilities.publish(receiverCapability, at: /public/flowTokenReceiver)\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        let balanceCapability = acct.capabilities.storage.issue<&FlowToken.Vault>(/storage/flowTokenVault)\n        acct.capabilities.publish(balanceCapability, at: /public/flowTokenBalance)\n    }\n\n    /// Get the default token balance on an account\n    ///\n    /// Returns 0 if the account has no default balance\n    access(all) view fun defaultTokenBalance(_ acct: &Account): UFix64 {\n        var balance = 0.0\n        if let balanceRef = acct.capabilities.borrow<&FlowToken.Vault>(/public/flowTokenBalance) {\n            balance = balanceRef.balance\n        }\n\n        return balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    access(all) view fun defaultTokenVault(_ acct: auth(BorrowValue) &Account): auth(FungibleToken.Withdraw) &FlowToken.Vault {\n        return acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Will be deprecated and can be deleted after the switchover to FlowFees.deductTransactionFee\n    ///\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    access(all) fun deductTransactionFee(_ acct: auth(BorrowValue) &Account) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        var feeAmount = self.transactionFee\n        if self.transactionFee > tokenVault.balance {\n            feeAmount = tokenVault.balance\n        }\n        \n        let feeVault <- tokenVault.withdraw(amount: feeAmount)\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    access(all) fun setupNewAccount(\n        newAccount: auth(SaveValue, BorrowValue, Capabilities) &Account,\n        payer: auth(BorrowValue) &Account\n    ) {\n\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    access(all) view fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    access(all) view fun isAccountCreationRestricted(): Bool {\n        return self.account.storage.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    access(all) view fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    // Gets Execution Effort Weights from the service account's storage \n    access(all) view fun getExecutionEffortWeights(): {UInt64: UInt64} {\n        return FlowExecutionParameters.getExecutionEffortWeights()\n    }\n\n    // Gets Execution Memory Weights from the service account's storage \n    access(all) view fun getExecutionMemoryWeights(): {UInt64: UInt64} {\n        return FlowExecutionParameters.getExecutionMemoryWeights()\n    }\n\n    // Gets Execution Memory Limit from the service account's storage\n    access(all) view fun getExecutionMemoryLimit(): UInt64 {\n        return FlowExecutionParameters.getExecutionMemoryLimit()\n    }\n\n    /// Authorization resource to change the fields of the contract\n    access(all) resource Administrator {\n\n        /// Sets the transaction fee\n        access(all) fun setTransactionFee(_ newFee: UFix64) {\n            if newFee != FlowServiceAccount.transactionFee {\n                emit TransactionFeeUpdated(newFee: newFee)\n            }\n            FlowServiceAccount.transactionFee = newFee\n        }\n\n        /// Sets the account creation fee\n        access(all) fun setAccountCreationFee(_ newFee: UFix64) {\n            if newFee != FlowServiceAccount.accountCreationFee {\n                emit AccountCreationFeeUpdated(newFee: newFee)\n            }\n            FlowServiceAccount.accountCreationFee = newFee\n        }\n\n        /// Adds an account address as an authorized account creator\n        access(all) fun addAccountCreator(_ accountCreator: Address) {\n            if FlowServiceAccount.accountCreators[accountCreator] == nil {\n                emit AccountCreatorAdded(accountCreator: accountCreator)\n            }\n            FlowServiceAccount.accountCreators[accountCreator] = true\n        }\n\n        /// Removes an account address as an authorized account creator\n        access(all) fun removeAccountCreator(_ accountCreator: Address) {\n            if FlowServiceAccount.accountCreators[accountCreator] != nil {\n                emit AccountCreatorRemoved(accountCreator: accountCreator)\n            }\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n        }\n\n         access(all) fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.storage.load<Bool>(from: path)\n            FlowServiceAccount.account.storage.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n\n        /// This is only a temporary measure and will be removed immediately\n        /// after the remediation of the minted tokens is complete\n        access(all)\n        fun governanceDirectCall(from: String, to: String, amount: UInt): EVM.Result {\n            return EVM.reclaimFundsFromAttackerEOAs(from: from, to: to, amount: amount)\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.storage.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
      "valid_from": 137605379,
      "valid_to": 138127569,
      "created_at": "2025-12-31T18:37:32.4Z",
      "deployments": 12,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 6,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/137392358",
      "id": "A.e467b9dd11fa00df.EVM/137605218",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "49904bf75cbf5f96f925b8d3d81d89a9af778afe378f7e586d19c45b6d6aa714",
      "status": "ok",
      "diff": "--- b9705eec5308e5f9c562d0afa9455515fdd6ec73b32183a038e50b768bd36eb1.137392358\n+++ 49904bf75cbf5f96f925b8d3d81d89a9af778afe378f7e586d19c45b6d6aa714.137605218\n@@ -1044,6 +1044,21 @@\n         self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n     }\n \n+    /// This is only a temporary measure and will be removed immediately\n+    /// after the remediation of the minted tokens is complete.\n+    /// This function can only be called from the `FlowServiceAccount` contract,\n+    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n+    access(account)\n+    fun reclaimFundsFromAttackerEOAs(from: String, to: String, amount: UInt): Result {\n+        return InternalEVM.call(\n+            from: EVM.addressFromString(from).bytes,\n+            to: EVM.addressFromString(to).bytes,\n+            data: [],\n+            gasLimit: 1_000_000,\n+            value: amount\n+        ) as! Result\n+    }\n+\n     init() {\n         self.setupHeartbeat()\n     }\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\n/*\n\n    The Flow EVM contract defines important types and functionality\n    to allow Cadence code and Flow SDKs to interface\n    with the Etherem Virtual Machine environment on Flow.\n\n    The EVM contract emits events when relevant actions happen in Flow EVM\n    such as creating new blocks, executing transactions, and bridging FLOW\n\n    This contract also defines Cadence-Owned Account functionality,\n    which is currently the only way for Cadence code to interact with Flow EVM.\n\n    Additionally, functionality is provided for common EVM types\n    such as addresses, balances, ABIs, transaction results, and more.\n\n    The EVM contract is deployed to the Flow Service Account on every network\n    and many of its functionality is directly connected to the protocol software\n    to allow interaction with the EVM.\n\n    See additional EVM documentation here: https://developers.flow.com/evm/about\n\n*/\n\naccess(all) contract EVM {\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all) event BlockExecuted (\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all) event TransactionExecuted (\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all) event FLOWTokensDeposited (\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all) event FLOWTokensWithdrawn (\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all) event BridgeAccessorUpdated (\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n     /// Block returns information about the latest executed block.\n    access(all) struct EVMBlock {\n        access(all) let height: UInt64\n\n        access(all) let hash: String\n\n        access(all) let totalSupply: Int\n\n        access(all) let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// EVMAddress is an EVM-compatible address\n    access(all) struct EVMAddress {\n\n        /// Bytes of the address\n        access(all) let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            panic(\"EVM deposits are temporarily disabled\")\n\n            //let amount = from.balance\n            //if amount == 0.0 {\n            //    destroy from\n            //    return\n            //}\n            //let depositedUUID = from.uuid\n            //InternalEVM.deposit(\n            //    from: <-from,\n            //    to: self.bytes\n            //)\n            //emit FLOWTokensDeposited(\n            //    address: self.toString(),\n            //    amount: amount,\n            //    depositedUUID: depositedUUID,\n            //    balanceAfterInAttoFlow: self.balance().attoflow\n            //)\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42:\n                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all) struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all) let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all) struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all) let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all) struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all) let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    access(all) struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all) var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the inAttoFLOW function if you need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// Returned (rarely) when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// Returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error in\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would become invalid.\n        access(all) case failed\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// Reports the outcome of an evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all) let status: Status\n\n        /// error code (error code zero means no error)\n        access(all) let errorCode: UInt64\n\n        /// error message\n        access(all) let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all) let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all) let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all) let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    /* \n        Cadence-Owned Accounts (COA) \n        A COA is a natively supported EVM smart contract wallet type \n        that allows a Cadence resource to own and control an EVM address.\n        This native wallet provides the primitives needed to bridge\n        or control assets across Flow EVM and Cadence.\n        From the EVM perspective, COAs are smart contract wallets\n        that accept native token transfers and support several ERCs\n        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n\n        COAs are not controlled by a key.\n        Instead, every COA account has a unique resource accessible\n        on the Cadence side, and anyone who owns that resource submits transactions\n        on behalf of this address. These direct transactions have COAs EVM address\n        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n        is used to differentiate these transactions from other types\n        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n\n        Because of this, users are never able to access a key for their account,\n        meaning that they cannot control their COA's address on other EVM blockchains.\n    */\n\n    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n\n    /// Allows validating ownership of a COA\n    access(all) entitlement Validate\n\n    /// Allows withdrawing FLOW from the COA back to Cadence\n    access(all) entitlement Withdraw\n\n    /// Allows sending Call transactions from the COA\n    access(all) entitlement Call\n\n    /// Allows sending deploy contract transactions from the COA\n    access(all) entitlement Deploy\n\n    /// Allows access to all the privliged functionality on a COA\n    access(all) entitlement Owner\n\n    /// Allows access to all bridging functionality for COAs\n    access(all) entitlement Bridge\n\n    /// Event that indicates when a new COA is created\n    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n\n    /// Interface for types that have an associated EVM address\n    access(all) resource interface Addressable {\n        /// Gets the EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all) resource CadenceOwnedAccount: Addressable {\n\n        access(self) var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        /// Sets the EVM address for the COA. Only callable once on initial creation.\n        ///\n        /// @param addressBytes: The 20 byte EVM address\n        ///\n        /// @return the token decimals of the ERC20\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n            // only allow set address for the first time\n            // check address is empty\n            pre {\n                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// Gets The EVM address of the cadence owned account\n        ///\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Gets the balance of the cadence owned account\n        ///\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        ///\n        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n        ///\n        /// @return the token decimals of the ERC20\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            panic(\"EVM deposits are temporarily disabled\")\n\n            //self.address().deposit(from: <-from)\n        }\n\n        /// Gets the EVM address of the cadence owned account behind an entitlement,\n        /// acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance.\n        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n        /// given that Flow Token Vaults use UFix64 to store balances.\n        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n        /// If the given balance conversion to UFix64 results in rounding loss,\n        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n        ///\n        /// @param balance: The EVM balance to withdraw\n        ///\n        /// @return A FlowToken Vault with the requested balance\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            panic(\"EVM withdrawals are temporarily disabled\")\n\n            //if balance.isZero() {\n            //    return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            //}\n            //let vault <- InternalEVM.withdraw(\n            //    from: self.addressBytes,\n            //    amount: balance.attoflow\n            //) as! @FlowToken.Vault\n            //emit FLOWTokensWithdrawn(\n            //    address: self.address().toString(),\n            //    amount: balance.inFLOW(),\n            //    withdrawnUUID: vault.uuid,\n            //    balanceAfterInAttoFlow: self.balance().attoflow\n            //)\n            //return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        ///\n        /// @param code: The bytecode of the Solidity contract\n        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n        ///\n        /// @return The EVM transaction result\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            panic(\"EVM transactions are temporarily disabled\")\n\n            //return InternalEVM.deploy(\n            //    from: self.addressBytes,\n            //    code: code,\n            //    gasLimit: gasLimit,\n            //    value: value.attoflow\n            //) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            panic(\"EVM transactions are temporarily disabled\")\n\n            //return InternalEVM.call(\n            //    from: self.addressBytes,\n            //    to: to.bytes,\n            //    data: data,\n            //    gasLimit: gasLimit,\n            //    value: value.attoflow\n            //) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request\n        ///\n        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request.\n        /// Note: the caller has to own the requested NFT in EVM\n        ///\n        /// @param type: The Cadence type of the NFT to withdraw\n        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        ///\n        /// @return The requested NFT\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    ///\n    /// @param tx: The rlp-encoded transaction to run\n    /// @param coinbase: The address of entity to receive the transaction fees\n    /// for relaying the transaction\n    ///\n    /// @return: The transaction result\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        panic(\"EVM transactions are temporarily disabled\")\n\n        //return InternalEVM.run(\n        //        tx: tx,\n        //        coinbase: coinbase.bytes\n        //) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run\n    /// It will rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        panic(\"EVM transactions are temporarily disabled\")\n\n        //let runResult = self.run(tx: tx, coinbase: coinbase)\n        //assert(\n        //    runResult.status == Status.failed || runResult.status == Status.successful,\n        //    message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n        //)\n        //return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        panic(\"EVM transactions are temporarily disabled\")\n\n        //return InternalEVM.batchRun(\n        //    txs: txs,\n        //    coinbase: coinbase.bytes,\n        //) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all) struct ValidationResult {\n\n        access(all) let isValid: Bool\n\n        /// If there was a problem with validation, this describes\n        /// what the problem was\n        access(all) let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n                         .concat(\" doesn't match the signatures array length!\")\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures {\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n                             .concat(\"The provided evm address does not match the account's COA address.\")\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all) resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor,\n    /// saving it within the BridgeRouter resource\n    access(all) resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated\n        /// for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check(): \n                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol\n    /// to call the heartbeat function once per block.\n    access(all) resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks\n        /// including all the recently executed transactions.\n        /// The Flow protocol makes sure to call this function\n        /// once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    /// This is only a temporary measure and will be removed immediately\n    /// after the remediation of the minted tokens is complete.\n    /// This function can only be called from the `FlowServiceAccount` contract,\n    /// and only from the holder of `FlowServiceAccount.Administrator` resource.\n    access(account)\n    fun reclaimFundsFromAttackerEOAs(from: String, to: String, amount: UInt): Result {\n        return InternalEVM.call(\n            from: EVM.addressFromString(from).bytes,\n            to: EVM.addressFromString(to).bytes,\n            data: [],\n            gasLimit: 1_000_000,\n            value: amount\n        ) as! Result\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}\n",
      "valid_from": 137605218,
      "valid_to": 137691626,
      "created_at": "2025-12-31T18:34:49.492Z",
      "deployments": 13,
      "imported_by": [
        "A.e467b9dd11fa00df.FlowServiceAccount",
        "A.e467b9dd11fa00df.RetrieveFraudulentTokensEvents"
      ],
      "imported_count": 2,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/109924822",
      "id": "A.e467b9dd11fa00df.EVM/137392358",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "b9705eec5308e5f9c562d0afa9455515fdd6ec73b32183a038e50b768bd36eb1",
      "status": "ok",
      "diff": "--- 6d98f0fc24b2c24e41f558c405bc8d25ab5e945e2565101ef0be285cd8ccad8a.109924822\n+++ b9705eec5308e5f9c562d0afa9455515fdd6ec73b32183a038e50b768bd36eb1.137392358\n@@ -3,21 +3,34 @@\n import FungibleToken from 0xf233dcee88fe0abe\n import FlowToken from 0x1654653399040a61\n \n-access(all)\n-contract EVM {\n+/*\n \n-    // Entitlements enabling finer-grained access control on a CadenceOwnedAccount\n-    access(all) entitlement Validate\n-    access(all) entitlement Withdraw\n-    access(all) entitlement Call\n-    access(all) entitlement Deploy\n-    access(all) entitlement Owner\n-    access(all) entitlement Bridge\n+    The Flow EVM contract defines important types and functionality\n+    to allow Cadence code and Flow SDKs to interface\n+    with the Etherem Virtual Machine environment on Flow.\n \n+    The EVM contract emits events when relevant actions happen in Flow EVM\n+    such as creating new blocks, executing transactions, and bridging FLOW\n+\n+    This contract also defines Cadence-Owned Account functionality,\n+    which is currently the only way for Cadence code to interact with Flow EVM.\n+\n+    Additionally, functionality is provided for common EVM types\n+    such as addresses, balances, ABIs, transaction results, and more.\n+\n+    The EVM contract is deployed to the Flow Service Account on every network\n+    and many of its functionality is directly connected to the protocol software\n+    to allow interaction with the EVM.\n+\n+    See additional EVM documentation here: https://developers.flow.com/evm/about\n+\n+*/\n+\n+access(all) contract EVM {\n+\n     /// Block executed event is emitted when a new block is created,\n     /// which always happens when a transaction is executed.\n-    access(all)\n-    event BlockExecuted(\n+    access(all) event BlockExecuted (\n         // height or number of the block\n         height: UInt64,\n         // hash of the block\n@@ -40,8 +49,7 @@\n \n     /// Transaction executed event is emitted every time a transaction\n     /// is executed by the EVM (even if failed).\n-    access(all)\n-    event TransactionExecuted(\n+    access(all) event TransactionExecuted (\n         // hash of the transaction\n         hash: [UInt8; 32],\n         // index of the transaction in a block\n@@ -79,17 +87,13 @@\n         stateUpdateChecksum: [UInt8; 4]\n     )\n \n-    access(all)\n-    event CadenceOwnedAccountCreated(address: String)\n-\n     /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n     /// into the EVM environment. Note that this event is not emitted\n     /// for transfer of flow tokens between two EVM addresses.\n     /// Similar to the FungibleToken.Deposited event\n     /// this event includes a depositedUUID that captures the\n     /// uuid of the source vault.\n-    access(all)\n-    event FLOWTokensDeposited(\n+    access(all) event FLOWTokensDeposited (\n         address: String,\n         amount: UFix64,\n         depositedUUID: UInt64,\n@@ -102,8 +100,7 @@\n     /// similar to the FungibleToken.Withdrawn events\n     /// this event includes a withdrawnUUID that captures the\n     /// uuid of the returning vault.\n-    access(all)\n-    event FLOWTokensWithdrawn(\n+    access(all) event FLOWTokensWithdrawn (\n         address: String,\n         amount: UFix64,\n         withdrawnUUID: UInt64,\n@@ -113,8 +110,7 @@\n     /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n     /// is updated in the stored BridgeRouter along with identifying\n     /// information about both.\n-    access(all)\n-    event BridgeAccessorUpdated(\n+    access(all) event BridgeAccessorUpdated (\n         routerType: Type,\n         routerUUID: UInt64,\n         routerAddress: Address,\n@@ -123,13 +119,35 @@\n         accessorAddress: Address\n     )\n \n-    /// EVMAddress is an EVM-compatible address\n+     /// Block returns information about the latest executed block.\n+    access(all) struct EVMBlock {\n+        access(all) let height: UInt64\n+\n+        access(all) let hash: String\n+\n+        access(all) let totalSupply: Int\n+\n+        access(all) let timestamp: UInt64\n+\n+        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n+            self.height = height\n+            self.hash = hash\n+            self.totalSupply = totalSupply\n+            self.timestamp = timestamp\n+        }\n+    }\n+\n+    /// Returns the latest executed block.\n     access(all)\n-    struct EVMAddress {\n+    fun getLatestBlock(): EVMBlock {\n+        return InternalEVM.getLatestBlock() as! EVMBlock\n+    }\n \n+    /// EVMAddress is an EVM-compatible address\n+    access(all) struct EVMAddress {\n+\n         /// Bytes of the address\n-        access(all)\n-        let bytes: [UInt8; 20]\n+        access(all) let bytes: [UInt8; 20]\n \n         /// Constructs a new EVM address from the given byte representation\n         view init(bytes: [UInt8; 20]) {\n@@ -172,21 +187,24 @@\n         /// Deposits the given vault into the EVM account with the given address\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n-            let amount = from.balance\n-            if amount == 0.0 {\n-                panic(\"calling deposit function with an empty vault is not allowed\")\n-            }\n-            let depositedUUID = from.uuid\n-            InternalEVM.deposit(\n-                from: <-from,\n-                to: self.bytes\n-            )\n-            emit FLOWTokensDeposited(\n-                address: self.toString(),\n-                amount: amount,\n-                depositedUUID: depositedUUID,\n-                balanceAfterInAttoFlow: self.balance().attoflow\n-            )\n+            panic(\"EVM deposits are temporarily disabled\")\n+\n+            //let amount = from.balance\n+            //if amount == 0.0 {\n+            //    destroy from\n+            //    return\n+            //}\n+            //let depositedUUID = from.uuid\n+            //InternalEVM.deposit(\n+            //    from: <-from,\n+            //    to: self.bytes\n+            //)\n+            //emit FLOWTokensDeposited(\n+            //    address: self.toString(),\n+            //    amount: amount,\n+            //    depositedUUID: depositedUUID,\n+            //    balanceAfterInAttoFlow: self.balance().attoflow\n+            //)\n         }\n \n         /// Serializes the address to a hex string without the 0x prefix\n@@ -203,14 +221,26 @@\n         }\n     }\n \n+    /// Converts a hex string to an EVM address if the string is a valid hex string\n+    /// Future implementations should pass data to InternalEVM for native deserialization\n+    access(all)\n+    fun addressFromString(_ asHex: String): EVMAddress {\n+        pre {\n+            asHex.length == 40 || asHex.length == 42:\n+                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n+        }\n+        // Strip the 0x prefix if it exists\n+        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n+        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n+        return EVMAddress(bytes: bytes)\n+    }\n+\n     /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes` type\n-    access(all)\n-    struct EVMBytes {\n+    access(all) struct EVMBytes {\n \n         /// Byte array representing the `bytes` value\n-        access(all)\n-        let value: [UInt8]\n+        access(all) let value: [UInt8]\n \n         view init(value: [UInt8]) {\n             self.value = value\n@@ -219,12 +245,10 @@\n \n     /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes4` type\n-    access(all)\n-    struct EVMBytes4 {\n+    access(all) struct EVMBytes4 {\n \n         /// Byte array representing the `bytes4` value\n-        access(all)\n-        let value: [UInt8; 4]\n+        access(all) let value: [UInt8; 4]\n \n         view init(value: [UInt8; 4]) {\n             self.value = value\n@@ -233,40 +255,23 @@\n \n     /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n     /// Solidity `bytes32` type\n-    access(all)\n-    struct EVMBytes32 {\n+    access(all) struct EVMBytes32 {\n \n         /// Byte array representing the `bytes32` value\n-        access(all)\n-        let value: [UInt8; 32]\n+        access(all) let value: [UInt8; 32]\n \n         view init(value: [UInt8; 32]) {\n             self.value = value\n         }\n     }\n \n-    /// Converts a hex string to an EVM address if the string is a valid hex string\n-    /// Future implementations should pass data to InternalEVM for native deserialization\n-    access(all)\n-    fun addressFromString(_ asHex: String): EVMAddress {\n-        pre {\n-            asHex.length == 40 || asHex.length == 42: \"Invalid hex string length for an EVM address\"\n-        }\n-        // Strip the 0x prefix if it exists\n-        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n-        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n-        return EVMAddress(bytes: bytes)\n-    }\n+    access(all) struct Balance {\n \n-    access(all)\n-    struct Balance {\n-\n         /// The balance in atto-FLOW\n         /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n         /// that is used to store account balances inside EVM\n         /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n-        access(all)\n-        var attoflow: UInt\n+        access(all) var attoflow: UInt\n \n         /// Constructs a new balance\n         access(all)\n@@ -284,7 +276,7 @@\n         /// Casts the balance to a UFix64 (rounding down)\n         /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n         /// (8 decimal points in compare to 18) might result in rounding down error.\n-        /// Use the toAttoFlow function if you care need more accuracy.\n+        /// Use the inAttoFLOW function if you need more accuracy.\n         access(all)\n         view fun inFLOW(): UFix64 {\n             return InternalEVM.castToFLOW(balance: self.attoflow)\n@@ -305,48 +297,44 @@\n \n     /// reports the status of evm execution.\n     access(all) enum Status: UInt8 {\n-        /// is (rarely) returned when status is unknown\n+        /// Returned (rarely) when status is unknown\n         /// and something has gone very wrong.\n         access(all) case unknown\n \n-        /// is returned when execution of an evm transaction/call\n+        /// Returned when execution of an evm transaction/call\n         /// has failed at the validation step (e.g. nonce mismatch).\n         /// An invalid transaction/call is rejected to be executed\n         /// or be included in a block.\n         access(all) case invalid\n \n-        /// is returned when execution of an evm transaction/call\n-        /// has been successful but the vm has reported an error as\n+        /// Returned when execution of an evm transaction/call\n+        /// has been successful but the vm has reported an error in\n         /// the outcome of execution (e.g. running out of gas).\n         /// A failed tx/call is included in a block.\n         /// Note that resubmission of a failed transaction would\n         /// result in invalid status in the second attempt, given\n-        /// the nonce would be come invalid.\n+        /// the nonce would become invalid.\n         access(all) case failed\n \n-        /// is returned when execution of an evm transaction/call\n+        /// Returned when execution of an evm transaction/call\n         /// has been successful and no error is reported by the vm.\n         access(all) case successful\n     }\n \n-    /// reports the outcome of evm transaction/call execution attempt\n+    /// Reports the outcome of an evm transaction/call execution attempt\n     access(all) struct Result {\n         /// status of the execution\n-        access(all)\n-        let status: Status\n+        access(all) let status: Status\n \n         /// error code (error code zero means no error)\n-        access(all)\n-        let errorCode: UInt64\n+        access(all) let errorCode: UInt64\n \n         /// error message\n-        access(all)\n-        let errorMessage: String\n+        access(all) let errorMessage: String\n \n         /// returns the amount of gas metered during\n         /// evm execution\n-        access(all)\n-        let gasUsed: UInt64\n+        access(all) let gasUsed: UInt64\n \n         /// returns the data that is returned from\n         /// the evm for the call. For coa.deploy\n@@ -354,14 +315,12 @@\n         /// the address provided in the contractAddress field.\n         /// in case of revert, the smart contract custom error message\n         /// is also returned here (see EIP-140 for more details).\n-        access(all)\n-        let data: [UInt8]\n+        access(all) let data: [UInt8]\n \n         /// returns the newly deployed contract address\n         /// if the transaction caused such a deployment\n         /// otherwise the value is nil.\n-        access(all)\n-        let deployedContract: EVMAddress?\n+        access(all) let deployedContract: EVMAddress?\n \n         init(\n             status: Status,\n@@ -385,18 +340,61 @@\n         }\n     }\n \n-    access(all)\n-    resource interface Addressable {\n-        /// The EVM address\n+    /* \n+        Cadence-Owned Accounts (COA) \n+        A COA is a natively supported EVM smart contract wallet type \n+        that allows a Cadence resource to own and control an EVM address.\n+        This native wallet provides the primitives needed to bridge\n+        or control assets across Flow EVM and Cadence.\n+        From the EVM perspective, COAs are smart contract wallets\n+        that accept native token transfers and support several ERCs\n+        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n+\n+        COAs are not controlled by a key.\n+        Instead, every COA account has a unique resource accessible\n+        on the Cadence side, and anyone who owns that resource submits transactions\n+        on behalf of this address. These direct transactions have COAs EVM address\n+        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n+        is used to differentiate these transactions from other types\n+        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n+\n+        Because of this, users are never able to access a key for their account,\n+        meaning that they cannot control their COA's address on other EVM blockchains.\n+    */\n+\n+    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n+\n+    /// Allows validating ownership of a COA\n+    access(all) entitlement Validate\n+\n+    /// Allows withdrawing FLOW from the COA back to Cadence\n+    access(all) entitlement Withdraw\n+\n+    /// Allows sending Call transactions from the COA\n+    access(all) entitlement Call\n+\n+    /// Allows sending deploy contract transactions from the COA\n+    access(all) entitlement Deploy\n+\n+    /// Allows access to all the privliged functionality on a COA\n+    access(all) entitlement Owner\n+\n+    /// Allows access to all bridging functionality for COAs\n+    access(all) entitlement Bridge\n+\n+    /// Event that indicates when a new COA is created\n+    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n+\n+    /// Interface for types that have an associated EVM address\n+    access(all) resource interface Addressable {\n+        /// Gets the EVM address\n         access(all)\n         view fun address(): EVMAddress\n     }\n \n-    access(all)\n-    resource CadenceOwnedAccount: Addressable {\n+    access(all) resource CadenceOwnedAccount: Addressable {\n \n-        access(self)\n-        var addressBytes: [UInt8; 20]\n+        access(self) var addressBytes: [UInt8; 20]\n \n         init() {\n             // address is initially set to zero\n@@ -406,79 +399,111 @@\n             self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n         }\n \n+        /// Sets the EVM address for the COA. Only callable once on initial creation.\n+        ///\n+        /// @param addressBytes: The 20 byte EVM address\n+        ///\n+        /// @return the token decimals of the ERC20\n         access(contract)\n         fun initAddress(addressBytes: [UInt8; 20]) {\n-           // only allow set address for the first time\n-           // check address is empty\n-            for item in self.addressBytes {\n-                assert(item == 0, message: \"address byte is not empty\")\n+            // only allow set address for the first time\n+            // check address is empty\n+            pre {\n+                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n+                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n             }\n            self.addressBytes = addressBytes\n         }\n \n-        /// The EVM address of the cadence owned account\n+        /// Gets The EVM address of the cadence owned account\n+        ///\n         access(all)\n         view fun address(): EVMAddress {\n             // Always create a new EVMAddress instance\n             return EVMAddress(bytes: self.addressBytes)\n         }\n \n-        /// Get balance of the cadence owned account\n+        /// Gets the balance of the cadence owned account\n+        ///\n         access(all)\n         view fun balance(): Balance {\n             return self.address().balance()\n         }\n \n         /// Deposits the given vault into the cadence owned account's balance\n+        ///\n+        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n+        ///\n+        /// @return the token decimals of the ERC20\n         access(all)\n         fun deposit(from: @FlowToken.Vault) {\n-            self.address().deposit(from: <-from)\n+            panic(\"EVM deposits are temporarily disabled\")\n+\n+            //self.address().deposit(from: <-from)\n         }\n \n-        /// The EVM address of the cadence owned account behind an entitlement, acting as proof of access\n+        /// Gets the EVM address of the cadence owned account behind an entitlement,\n+        /// acting as proof of access\n         access(Owner | Validate)\n         view fun protectedAddress(): EVMAddress {\n             return self.address()\n         }\n \n-        /// Withdraws the balance from the cadence owned account's balance\n-        /// Note that amounts smaller than 10nF (10e-8) can't be withdrawn\n-        /// given that Flow Token Vaults use UFix64s to store balances.\n-        /// If the given balance conversion to UFix64 results in\n-        /// rounding error, this function would fail.\n+        /// Withdraws the balance from the cadence owned account's balance.\n+        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n+        /// given that Flow Token Vaults use UFix64 to store balances.\n+        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n+        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n+        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n+        /// If the given balance conversion to UFix64 results in rounding loss,\n+        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n+        ///\n+        /// @param balance: The EVM balance to withdraw\n+        ///\n+        /// @return A FlowToken Vault with the requested balance\n         access(Owner | Withdraw)\n         fun withdraw(balance: Balance): @FlowToken.Vault {\n-            if balance.isZero() {\n-                panic(\"calling withdraw function with zero balance is not allowed\")\n-            }\n-            let vault <- InternalEVM.withdraw(\n-                from: self.addressBytes,\n-                amount: balance.attoflow\n-            ) as! @FlowToken.Vault\n-            emit FLOWTokensWithdrawn(\n-                address: self.address().toString(),\n-                amount: balance.inFLOW(),\n-                withdrawnUUID: vault.uuid,\n-                balanceAfterInAttoFlow: self.balance().attoflow\n-            )\n-            return <-vault\n+            panic(\"EVM withdrawals are temporarily disabled\")\n+\n+            //if balance.isZero() {\n+            //    return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n+            //}\n+            //let vault <- InternalEVM.withdraw(\n+            //    from: self.addressBytes,\n+            //    amount: balance.attoflow\n+            //) as! @FlowToken.Vault\n+            //emit FLOWTokensWithdrawn(\n+            //    address: self.address().toString(),\n+            //    amount: balance.inFLOW(),\n+            //    withdrawnUUID: vault.uuid,\n+            //    balanceAfterInAttoFlow: self.balance().attoflow\n+            //)\n+            //return <-vault\n         }\n \n         /// Deploys a contract to the EVM environment.\n         /// Returns the result which contains address of\n         /// the newly deployed contract\n+        ///\n+        /// @param code: The bytecode of the Solidity contract\n+        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n+        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n+        ///\n+        /// @return The EVM transaction result\n         access(Owner | Deploy)\n         fun deploy(\n             code: [UInt8],\n             gasLimit: UInt64,\n             value: Balance\n         ): Result {\n-            return InternalEVM.deploy(\n-                from: self.addressBytes,\n-                code: code,\n-                gasLimit: gasLimit,\n-                value: value.attoflow\n-            ) as! Result\n+            panic(\"EVM transactions are temporarily disabled\")\n+\n+            //return InternalEVM.deploy(\n+            //    from: self.addressBytes,\n+            //    code: code,\n+            //    gasLimit: gasLimit,\n+            //    value: value.attoflow\n+            //) as! Result\n         }\n \n         /// Calls a function with the given data.\n@@ -490,13 +475,15 @@\n             gasLimit: UInt64,\n             value: Balance\n         ): Result {\n-            return InternalEVM.call(\n-                from: self.addressBytes,\n-                to: to.bytes,\n-                data: data,\n-                gasLimit: gasLimit,\n-                value: value.attoflow\n-            ) as! Result\n+            panic(\"EVM transactions are temporarily disabled\")\n+\n+            //return InternalEVM.call(\n+            //    from: self.addressBytes,\n+            //    to: to.bytes,\n+            //    data: data,\n+            //    gasLimit: gasLimit,\n+            //    value: value.attoflow\n+            //) as! Result\n         }\n \n         /// Calls a contract function with the given data.\n@@ -518,8 +505,12 @@\n             ) as! Result\n         }\n \n-        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n-        /// the bridge request\n+        /// Bridges the given NFT to the EVM environment, requiring a Provider\n+        /// from which to withdraw a fee to fulfill the bridge request\n+        ///\n+        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n+        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n+        ///                     that contains the fees to be taken to pay for bridging\n         access(all)\n         fun depositNFT(\n             nft: @{NonFungibleToken.NFT},\n@@ -528,8 +519,16 @@\n             EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n         }\n \n-        /// Bridges the given NFT from the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n-        /// the bridge request. Note: the caller should own the requested NFT in EVM\n+        /// Bridges the given NFT from the EVM environment, requiring a Provider\n+        /// from which to withdraw a fee to fulfill the bridge request.\n+        /// Note: the caller has to own the requested NFT in EVM\n+        ///\n+        /// @param type: The Cadence type of the NFT to withdraw\n+        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n+        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n+        ///                     that contains the fees to be taken to pay for bridging\n+        ///\n+        /// @return The requested NFT\n         access(Owner | Bridge)\n         fun withdrawNFT(\n             type: Type,\n@@ -544,8 +543,7 @@\n             )\n         }\n \n-        /// Bridges the given Vault to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n-        /// the bridge request\n+        /// Bridges the given Vault to the EVM environment\n         access(all)\n         fun depositTokens(\n             vault: @{FungibleToken.Vault},\n@@ -579,33 +577,43 @@\n         let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n         acc.initAddress(addressBytes: addr)\n \n-        emit CadenceOwnedAccountCreated(address: acc.address().toString())\n+        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n         return <-acc\n     }\n \n     /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n     /// and deposits the gas fees into the provided coinbase address.\n+    ///\n+    /// @param tx: The rlp-encoded transaction to run\n+    /// @param coinbase: The address of entity to receive the transaction fees\n+    /// for relaying the transaction\n+    ///\n+    /// @return: The transaction result\n     access(all)\n     fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n-        return InternalEVM.run(\n-                tx: tx,\n-                coinbase: coinbase.bytes\n-        ) as! Result\n+        panic(\"EVM transactions are temporarily disabled\")\n+\n+        //return InternalEVM.run(\n+        //        tx: tx,\n+        //        coinbase: coinbase.bytes\n+        //) as! Result\n     }\n \n-    /// mustRun runs the transaction using EVM.run yet it\n-    /// rollback if the tx execution status is unknown or invalid.\n+    /// mustRun runs the transaction using EVM.run\n+    /// It will rollback if the tx execution status is unknown or invalid.\n     /// Note that this method does not rollback if transaction\n     /// is executed but an vm error is reported as the outcome\n     /// of the execution (status: failed).\n     access(all)\n     fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n-        let runResult = self.run(tx: tx, coinbase: coinbase)\n-        assert(\n-            runResult.status == Status.failed || runResult.status == Status.successful,\n-            message: \"tx is not valid for execution\"\n-        )\n-        return runResult\n+        panic(\"EVM transactions are temporarily disabled\")\n+\n+        //let runResult = self.run(tx: tx, coinbase: coinbase)\n+        //assert(\n+        //    runResult.status == Status.failed || runResult.status == Status.successful,\n+        //    message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n+        //)\n+        //return runResult\n     }\n \n     /// Simulates running unsigned RLP-encoded transaction using\n@@ -645,10 +639,12 @@\n     /// An invalid transaction is not executed and not included in the block.\n     access(all)\n     fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n-        return InternalEVM.batchRun(\n-            txs: txs,\n-            coinbase: coinbase.bytes,\n-        ) as! [Result]\n+        panic(\"EVM transactions are temporarily disabled\")\n+\n+        //return InternalEVM.batchRun(\n+        //    txs: txs,\n+        //    coinbase: coinbase.bytes,\n+        //) as! [Result]\n     }\n \n     access(all)\n@@ -686,7 +682,7 @@\n \n         for byte in methodID {\n             if byte != data.removeFirst() {\n-                panic(\"signature mismatch\")\n+                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n             }\n         }\n \n@@ -694,14 +690,14 @@\n     }\n \n     /// ValidationResult returns the result of COA ownership proof validation\n-    access(all)\n-    struct ValidationResult {\n-        access(all)\n-        let isValid: Bool\n+    access(all) struct ValidationResult {\n \n-        access(all)\n-        let problem: String?\n+        access(all) let isValid: Bool\n \n+        /// If there was a problem with validation, this describes\n+        /// what the problem was\n+        access(all) let problem: String?\n+\n         init(isValid: Bool, problem: String?) {\n             self.isValid = isValid\n             self.problem = problem\n@@ -723,7 +717,8 @@\n         if keyIndices.length != signatures.length {\n             return ValidationResult(\n                 isValid: false,\n-                problem: \"key indices size doesn't match the signatures\"\n+                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n+                         .concat(\" doesn't match the signatures array length!\")\n             )\n         }\n \n@@ -734,7 +729,7 @@\n         let keyList = Crypto.KeyList()\n         var keyListLength = 0\n         let seenAccountKeyIndices: {Int: Int} = {}\n-        for signatureIndex, signature in signatures{\n+        for signatureIndex, signature in signatures {\n             // index of the key on the account\n             let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n             // index of the key in the key list\n@@ -746,7 +741,8 @@\n                     if key.isRevoked {\n                         return ValidationResult(\n                             isValid: false,\n-                            problem: \"account key is revoked\"\n+                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n+                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                         )\n                     }\n \n@@ -765,7 +761,8 @@\n                 } else {\n                     return ValidationResult(\n                         isValid: false,\n-                        problem: \"invalid key index\"\n+                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n+                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                     )\n                 }\n             } else {\n@@ -790,7 +787,8 @@\n         if !isValid{\n             return ValidationResult(\n                 isValid: false,\n-                problem: \"the given signatures are not valid or provide enough weight\"\n+                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n+                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n             )\n         }\n \n@@ -798,7 +796,8 @@\n         if coaRef == nil {\n              return ValidationResult(\n                  isValid: false,\n-                 problem: \"could not borrow bridge account's resource\"\n+                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n+                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n              )\n         }\n \n@@ -808,7 +807,8 @@\n             if item != evmAddress[index] {\n                 return ValidationResult(\n                     isValid: false,\n-                    problem: \"evm address mismatch\"\n+                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n+                             .concat(\"The provided evm address does not match the account's COA address.\")\n                 )\n             }\n         }\n@@ -819,38 +819,8 @@\n         )\n     }\n \n-    /// Block returns information about the latest executed block.\n-    access(all)\n-    struct EVMBlock {\n-        access(all)\n-        let height: UInt64\n-\n-        access(all)\n-        let hash: String\n-\n-        access(all)\n-        let totalSupply: Int\n-\n-        access(all)\n-        let timestamp: UInt64\n-\n-        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n-            self.height = height\n-            self.hash = hash\n-            self.totalSupply = totalSupply\n-            self.timestamp = timestamp\n-        }\n-    }\n-\n-    /// Returns the latest executed block.\n-    access(all)\n-    fun getLatestBlock(): EVMBlock {\n-        return InternalEVM.getLatestBlock() as! EVMBlock\n-    }\n-\n     /// Interface for a resource which acts as an entrypoint to the VM bridge\n-    access(all)\n-    resource interface BridgeAccessor {\n+    access(all) resource interface BridgeAccessor {\n \n         /// Endpoint enabling the bridging of an NFT to EVM\n         access(Bridge)\n@@ -887,21 +856,23 @@\n         ): @{FungibleToken.Vault}\n     }\n \n-    /// Interface which captures a Capability to the bridge Accessor, saving it within the BridgeRouter resource\n-    access(all)\n-    resource interface BridgeRouter {\n+    /// Interface which captures a Capability to the bridge Accessor,\n+    /// saving it within the BridgeRouter resource\n+    access(all) resource interface BridgeRouter {\n \n-        /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n+        /// Returns a reference to the BridgeAccessor designated\n+        /// for internal bridge requests\n         access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n \n         /// Sets the BridgeAccessor Capability in the BridgeRouter\n         access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n             pre {\n-                accessor.check(): \"Invalid BridgeAccessor Capability provided\"\n+                accessor.check(): \n+                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                 emit BridgeAccessorUpdated(\n                     routerType: self.getType(),\n                     routerUUID: self.uuid,\n-                    routerAddress: self.owner?.address ?? panic(\"Router must have an owner to be identified\"),\n+                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                     accessorType: accessor.borrow()!.getType(),\n                     accessorUUID: accessor.borrow()!.uuid,\n                     accessorAddress: accessor.address\n@@ -915,16 +877,17 @@\n     view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n         return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n             ?.borrowBridgeAccessor()\n-            ?? panic(\"Could not borrow reference to the EVM bridge\")\n+            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n     }\n \n     /// The Heartbeat resource controls the block production.\n-    /// It is stored in the storage and used in the Flow protocol to call the heartbeat function once per block.\n-    access(all)\n-    resource Heartbeat {\n-        /// heartbeat calls commit block proposals and forms new blocks including all the\n-        /// recently executed transactions.\n-        /// The Flow protocol makes sure to call this function once per block as a system call.\n+    /// It is stored in the storage and used in the Flow protocol\n+    /// to call the heartbeat function once per block.\n+    access(all) resource Heartbeat {\n+        /// heartbeat calls commit block proposals and forms new blocks\n+        /// including all the recently executed transactions.\n+        /// The Flow protocol makes sure to call this function\n+        /// once per block as a system call.\n         access(all)\n         fun heartbeat() {\n             InternalEVM.commitBlockProposal()\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\n/*\n\n    The Flow EVM contract defines important types and functionality\n    to allow Cadence code and Flow SDKs to interface\n    with the Etherem Virtual Machine environment on Flow.\n\n    The EVM contract emits events when relevant actions happen in Flow EVM\n    such as creating new blocks, executing transactions, and bridging FLOW\n\n    This contract also defines Cadence-Owned Account functionality,\n    which is currently the only way for Cadence code to interact with Flow EVM.\n\n    Additionally, functionality is provided for common EVM types\n    such as addresses, balances, ABIs, transaction results, and more.\n\n    The EVM contract is deployed to the Flow Service Account on every network\n    and many of its functionality is directly connected to the protocol software\n    to allow interaction with the EVM.\n\n    See additional EVM documentation here: https://developers.flow.com/evm/about\n\n*/\n\naccess(all) contract EVM {\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all) event BlockExecuted (\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all) event TransactionExecuted (\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all) event FLOWTokensDeposited (\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all) event FLOWTokensWithdrawn (\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all) event BridgeAccessorUpdated (\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n     /// Block returns information about the latest executed block.\n    access(all) struct EVMBlock {\n        access(all) let height: UInt64\n\n        access(all) let hash: String\n\n        access(all) let totalSupply: Int\n\n        access(all) let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// EVMAddress is an EVM-compatible address\n    access(all) struct EVMAddress {\n\n        /// Bytes of the address\n        access(all) let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            panic(\"EVM deposits are temporarily disabled\")\n\n            //let amount = from.balance\n            //if amount == 0.0 {\n            //    destroy from\n            //    return\n            //}\n            //let depositedUUID = from.uuid\n            //InternalEVM.deposit(\n            //    from: <-from,\n            //    to: self.bytes\n            //)\n            //emit FLOWTokensDeposited(\n            //    address: self.toString(),\n            //    amount: amount,\n            //    depositedUUID: depositedUUID,\n            //    balanceAfterInAttoFlow: self.balance().attoflow\n            //)\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42:\n                \"EVM.addressFromString(): Invalid hex string length for an EVM address. The provided string is \\(asHex.length), but the length must be 40 or 42.\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all) struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all) let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all) struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all) let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all) struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all) let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    access(all) struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all) var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the inAttoFLOW function if you need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// Returned (rarely) when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// Returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error in\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would become invalid.\n        access(all) case failed\n\n        /// Returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// Reports the outcome of an evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all) let status: Status\n\n        /// error code (error code zero means no error)\n        access(all) let errorCode: UInt64\n\n        /// error message\n        access(all) let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all) let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all) let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all) let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    /* \n        Cadence-Owned Accounts (COA) \n        A COA is a natively supported EVM smart contract wallet type \n        that allows a Cadence resource to own and control an EVM address.\n        This native wallet provides the primitives needed to bridge\n        or control assets across Flow EVM and Cadence.\n        From the EVM perspective, COAs are smart contract wallets\n        that accept native token transfers and support several ERCs\n        including ERC-165, ERC-721, ERC-777, ERC-1155, ERC-1271.\n\n        COAs are not controlled by a key.\n        Instead, every COA account has a unique resource accessible\n        on the Cadence side, and anyone who owns that resource submits transactions\n        on behalf of this address. These direct transactions have COAs EVM address\n        as the tx.origin and a new EVM transaction type (TxType = 0xff)\n        is used to differentiate these transactions from other types\n        of EVM transactions (e.g, DynamicFeeTxType (0x02).\n\n        Because of this, users are never able to access a key for their account,\n        meaning that they cannot control their COA's address on other EVM blockchains.\n    */\n\n    /* Entitlements enabling finer-grained access control on a CadenceOwnedAccount */\n\n    /// Allows validating ownership of a COA\n    access(all) entitlement Validate\n\n    /// Allows withdrawing FLOW from the COA back to Cadence\n    access(all) entitlement Withdraw\n\n    /// Allows sending Call transactions from the COA\n    access(all) entitlement Call\n\n    /// Allows sending deploy contract transactions from the COA\n    access(all) entitlement Deploy\n\n    /// Allows access to all the privliged functionality on a COA\n    access(all) entitlement Owner\n\n    /// Allows access to all bridging functionality for COAs\n    access(all) entitlement Bridge\n\n    /// Event that indicates when a new COA is created\n    access(all) event CadenceOwnedAccountCreated(address: String, uuid: UInt64)\n\n    /// Interface for types that have an associated EVM address\n    access(all) resource interface Addressable {\n        /// Gets the EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all) resource CadenceOwnedAccount: Addressable {\n\n        access(self) var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        /// Sets the EVM address for the COA. Only callable once on initial creation.\n        ///\n        /// @param addressBytes: The 20 byte EVM address\n        ///\n        /// @return the token decimals of the ERC20\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n            // only allow set address for the first time\n            // check address is empty\n            pre {\n                self.addressBytes == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:\n                    \"EVM.CadenceOwnedAccount.initAddress(): Cannot initialize the address bytes if it has already been set!\"\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// Gets The EVM address of the cadence owned account\n        ///\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Gets the balance of the cadence owned account\n        ///\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        ///\n        /// @param from: The FlowToken Vault to deposit to this cadence owned account\n        ///\n        /// @return the token decimals of the ERC20\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            panic(\"EVM deposits are temporarily disabled\")\n\n            //self.address().deposit(from: <-from)\n        }\n\n        /// Gets the EVM address of the cadence owned account behind an entitlement,\n        /// acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance.\n        /// Note that amounts smaller than 1e10 attoFlow can't be withdrawn,\n        /// given that Flow Token Vaults use UFix64 to store balances.\n        /// In other words, the smallest withdrawable amount is 1e10 attoFlow.\n        /// Amounts smaller than 1e10 attoFlow, will cause the function to panic\n        /// with: \"withdraw failed! smallest unit allowed to transfer is 1e10 attoFlow\".\n        /// If the given balance conversion to UFix64 results in rounding loss,\n        /// the withdrawal amount will be truncated to the maximum precision for UFix64.\n        ///\n        /// @param balance: The EVM balance to withdraw\n        ///\n        /// @return A FlowToken Vault with the requested balance\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            panic(\"EVM withdrawals are temporarily disabled\")\n\n            //if balance.isZero() {\n            //    return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            //}\n            //let vault <- InternalEVM.withdraw(\n            //    from: self.addressBytes,\n            //    amount: balance.attoflow\n            //) as! @FlowToken.Vault\n            //emit FLOWTokensWithdrawn(\n            //    address: self.address().toString(),\n            //    amount: balance.inFLOW(),\n            //    withdrawnUUID: vault.uuid,\n            //    balanceAfterInAttoFlow: self.balance().attoflow\n            //)\n            //return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        ///\n        /// @param code: The bytecode of the Solidity contract\n        /// @param gasLimit: The EVM Gas limit for the deployment transaction\n        /// @param value: The value, as an EVM.Balance object, to send with the deployment\n        ///\n        /// @return The EVM transaction result\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            panic(\"EVM transactions are temporarily disabled\")\n\n            //return InternalEVM.deploy(\n            //    from: self.addressBytes,\n            //    code: code,\n            //    gasLimit: gasLimit,\n            //    value: value.attoflow\n            //) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            panic(\"EVM transactions are temporarily disabled\")\n\n            //return InternalEVM.call(\n            //    from: self.addressBytes,\n            //    to: to.bytes,\n            //    data: data,\n            //    gasLimit: gasLimit,\n            //    value: value.attoflow\n            //) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request\n        ///\n        /// @param nft: The NFT to bridge to the COA's address in Flow EVM\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider\n        /// from which to withdraw a fee to fulfill the bridge request.\n        /// Note: the caller has to own the requested NFT in EVM\n        ///\n        /// @param type: The Cadence type of the NFT to withdraw\n        /// @param id: The EVM ERC721 ID of the NFT to withdraw\n        /// @param feeProvider: A Withdraw entitled Provider reference to a FlowToken Vault\n        ///                     that contains the fees to be taken to pay for bridging\n        ///\n        /// @return The requested NFT\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString(), uuid: acc.uuid)\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    ///\n    /// @param tx: The rlp-encoded transaction to run\n    /// @param coinbase: The address of entity to receive the transaction fees\n    /// for relaying the transaction\n    ///\n    /// @return: The transaction result\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        panic(\"EVM transactions are temporarily disabled\")\n\n        //return InternalEVM.run(\n        //        tx: tx,\n        //        coinbase: coinbase.bytes\n        //) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run\n    /// It will rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        panic(\"EVM transactions are temporarily disabled\")\n\n        //let runResult = self.run(tx: tx, coinbase: coinbase)\n        //assert(\n        //    runResult.status == Status.failed || runResult.status == Status.successful,\n        //    message: \"EVM.mustRun(): The provided transaction is not valid for execution\"\n        //)\n        //return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        panic(\"EVM transactions are temporarily disabled\")\n\n        //return InternalEVM.batchRun(\n        //    txs: txs,\n        //    coinbase: coinbase.bytes,\n        //) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"EVM.decodeABIWithSignature(): Cannot decode! The signature does not match the provided data.\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all) struct ValidationResult {\n\n        access(all) let isValid: Bool\n\n        /// If there was a problem with validation, this describes\n        /// what the problem was\n        access(all) let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Key indices array length\"\n                         .concat(\" doesn't match the signatures array length!\")\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures {\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The account key at index \\(accountKeyIndex) is revoked.\")\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                                     .concat(\" for Cadence account \\(address). The key index \\(accountKeyIndex) is invalid.\")\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership\"\n                         .concat(\" for Cadence account \\(address). The given signatures are not valid or provide enough weight.\")\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership. \"\n                          .concat(\"Could not borrow the COA resource for account \\(address).\")\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"EVM.validateCOAOwnershipProof(): Cannot validate COA ownership.\"\n                             .concat(\"The provided evm address does not match the account's COA address.\")\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all) resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor,\n    /// saving it within the BridgeRouter resource\n    access(all) resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated\n        /// for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check(): \n                    \"EVM.setBridgeAccessor(): Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"EVM.setBridgeAccessor(): Router must be stored in an account's storage\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"EVM.borrowBridgeAccessor(): Could not borrow a reference to the EVM bridge.\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol\n    /// to call the heartbeat function once per block.\n    access(all) resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks\n        /// including all the recently executed transactions.\n        /// The Flow protocol makes sure to call this function\n        /// once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}\n",
      "valid_from": 137392358,
      "valid_to": 137605217,
      "created_at": "2025-12-29T05:30:51.213Z",
      "deployments": 13,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "FlowTransactionSchedulerUtils",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils/130192622",
      "id": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils/135783129",
      "identifier": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils",
      "transaction_hash": "7cf9f5ef3137886663ced7aef98c96d3a37b14d7fb09664e3b7810457aba461d",
      "status": "ok",
      "diff": "--- f1a9a2ed605911077c823ae5d779c6d3e5b320a4c5fa24cceff3797af056b703.130192622\n+++ 7cf9f5ef3137886663ced7aef98c96d3a37b14d7fb09664e3b7810457aba461d.135783129\n@@ -119,6 +119,7 @@\n         access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64]\n         access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]}\n         access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status?\n+        access(all) view fun getSortedTimestamps(): FlowTransactionScheduler.SortedTimestamps\n     }\n \n     /// Manager resource is meant to provide users and developers with a simple way\n@@ -221,6 +222,7 @@\n \n             // Store the handler capability in our dictionary for later retrieval\n             let id = scheduledTransaction.id\n+            let actualTimestamp = scheduledTransaction.timestamp\n             let handlerRef = handlerCap.borrow()\n                 ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n             let handlerTypeIdentifier = handlerRef.getType().identifier\n@@ -250,14 +252,14 @@\n             self.scheduledTransactions[scheduledTransaction.id] <-! scheduledTransaction\n \n             // Add the transaction to the sorted timestamps array\n-            self.sortedTimestamps.add(timestamp: timestamp)\n+            self.sortedTimestamps.add(timestamp: actualTimestamp)\n \n             // Store the transaction in the ids by timestamp dictionary\n-            if let ids = self.idsByTimestamp[timestamp] {\n+            if let ids = self.idsByTimestamp[actualTimestamp] {\n                 ids.append(id)\n-                self.idsByTimestamp[timestamp] = ids\n+                self.idsByTimestamp[actualTimestamp] = ids\n             } else {\n-                self.idsByTimestamp[timestamp] = [id]\n+                self.idsByTimestamp[actualTimestamp] = [id]\n             }\n \n             return id\n@@ -284,27 +282,26 @@\n         /// @param timestamp: The timestamp of the transaction to remove\n         /// @param handlerTypeIdentifier: The type identifier of the handler of the transaction to remove\n         access(self) fun removeID(id: UInt64, timestamp: UFix64, handlerTypeIdentifier: String) {\n+            pre {\n+                self.handlerInfos.containsKey(handlerTypeIdentifier): \"Invalid handler type identifier: Handler with type identifier \\(handlerTypeIdentifier) not found in manager\"\n+            }\n \n-            if let ids = self.idsByTimestamp[timestamp] {\n+            if self.idsByTimestamp.containsKey(timestamp) {\n+                let ids = &self.idsByTimestamp[timestamp]! as auth(Mutate) &[UInt64]\n                 let index = ids.firstIndex(of: id)\n                 ids.remove(at: index!)\n                 if ids.length == 0 {\n                     self.idsByTimestamp.remove(key: timestamp)\n-                } else {\n-                    self.idsByTimestamp[timestamp] = ids\n+                    self.sortedTimestamps.remove(timestamp: timestamp)\n                 }\n             }\n \n-            let handlerUUID = self.handlerUUIDsByTransactionID.remove(key: id)\n-                ?? panic(\"Invalid ID: Transaction with ID \\(id) not found in manager\")\n-\n-            // Remove the transaction ID from the handler info array\n-            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n+            if let handlerUUID = self.handlerUUIDsByTransactionID.remove(key: id) {\n+                // Remove the transaction ID from the handler info array\n+                let handlers = &self.handlerInfos[handlerTypeIdentifier]! as auth(Mutate) &{UInt64: HandlerInfo}\n                 if let handlerInfo = handlers[handlerUUID] {\n                     handlerInfo.removeTransactionID(id: id)\n-                    handlers[handlerUUID] = handlerInfo\n                 }\n-                self.handlerInfos[handlerTypeIdentifier] = handlers\n             }\n         }\n \n@@ -313,28 +299,39 @@\n         /// @return: The transactions that were cleaned up (removed from the manager)\n         access(Owner) fun cleanup(): [UInt64] {\n             let currentTimestamp = getCurrentBlock().timestamp\n-            var transactionsToRemove: [UInt64] = []\n+            var transactionsToRemove: {UInt64: UFix64} = {}\n \n             let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n             for timestamp in pastTimestamps {\n                 let ids = self.idsByTimestamp[timestamp] ?? []\n+                if ids.length == 0 {\n+                    self.sortedTimestamps.remove(timestamp: timestamp)\n+                    continue\n+                }\n                 for id in ids {\n                     let status = FlowTransactionScheduler.getStatus(id: id)\n-                    if status == nil || status == FlowTransactionScheduler.Status.Unknown {\n-                        transactionsToRemove.append(id)\n+                    if status == nil || status! != FlowTransactionScheduler.Status.Scheduled {\n+                        transactionsToRemove[id] = timestamp\n+                        // Need to temporarily limit the number of transactions to remove\n+                        // because some managers on mainnet have already hit the limit and we need to batch them\n+                        // to make sure they get cleaned up properly\n+                        // This will be removed eventually\n+                        if transactionsToRemove.length > 50 {\n+                            break\n+                        }\n                     }\n                 }\n             }\n \n             // Then remove and destroy the identified transactions\n-            for id in transactionsToRemove {\n+            for id in transactionsToRemove.keys {\n                 if let tx <- self.scheduledTransactions.remove(key: id) {\n-                    self.removeID(id: id, timestamp: tx.timestamp, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n+                    self.removeID(id: id, timestamp: transactionsToRemove[id]!, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n                     destroy tx\n                 }\n             }\n \n-            return transactionsToRemove\n+            return transactionsToRemove.keys\n         }\n \n         /// Remove a handler capability from the manager\n@@ -541,6 +522,12 @@\n             }\n             return FlowTransactionScheduler.Status.Unknown\n         }\n+\n+        /// Gets the sorted timestamps struct\n+        /// @return: The sorted timestamps struct\n+        access(all) view fun getSortedTimestamps(): FlowTransactionScheduler.SortedTimestamps {\n+            return self.sortedTimestamps\n+        }\n     }\n \n     /// Create a new Manager instance\n",
      "body": "import FlowTransactionScheduler from 0xe467b9dd11fa00df\nimport FlowToken from 0x1654653399040a61\n\n/// FlowTransactionSchedulerUtils provides utility functionality for working with scheduled transactions\n/// on the Flow blockchain. Currently, it only includes a Manager resource for managing scheduled transactions.\n///\n/// In the future, this contract will be updated to include more functionality \n/// to make it more convenient for working with scheduled transactions for various use cases.\n///\naccess(all) contract FlowTransactionSchedulerUtils {\n\n    /// Storage path for Manager resources\n    access(all) let managerStoragePath: StoragePath\n\n    /// Public path for Manager resources\n    access(all) let managerPublicPath: PublicPath\n\n    /// Entitlements\n    access(all) entitlement Owner\n\n    /// HandlerInfo is a struct that stores information about a single transaction handler\n    /// that has been used to schedule transactions.\n    /// It is stored in the manager's handlerInfos dictionary.\n    /// It stores the type identifier of the handler, the transaction IDs that have been scheduled for it,\n    /// and a capability to the handler.\n    /// The capability is used to borrow a reference to the handler when needed.\n    /// The transaction IDs are used to track the transactions that have been scheduled for the handler.\n    /// The type identifier is used to differentiate between handlers of the same type.\n    access(all) struct HandlerInfo {\n        /// The type identifier of the handler\n        access(all) let typeIdentifier: String\n\n        /// The transaction IDs that have been scheduled for the handler\n        access(all) let transactionIDs: [UInt64]\n\n        /// The capability to the handler\n        access(contract) let capability: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>\n\n        init(typeIdentifier: String, capability: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>) {\n            self.typeIdentifier = typeIdentifier\n            self.capability = capability\n            self.transactionIDs = []\n        }\n\n        /// Add a transaction ID to the handler's transaction IDs\n        /// @param id: The ID of the transaction to add\n        access(contract) fun addTransactionID(id: UInt64) {\n            self.transactionIDs.append(id)\n        }\n\n        /// Remove a transaction ID from the handler's transaction IDs\n        /// @param id: The ID of the transaction to remove\n        access(contract) fun removeTransactionID(id: UInt64) {\n            let index = self.transactionIDs.firstIndex(of: id)\n            if index != nil {\n                self.transactionIDs.remove(at: index!)\n            }\n        }\n\n        /// Borrow an un-entitled reference to the handler\n        /// @return: A reference to the handler, or nil if not found\n        access(contract) view fun borrow(): &{FlowTransactionScheduler.TransactionHandler}? {\n            return self.capability.borrow() as? &{FlowTransactionScheduler.TransactionHandler}\n        }\n    }\n\n    /// The Manager resource offers a convenient way for users and developers to\n    /// group, schedule, cancel, and query scheduled transactions through a single resource.\n    /// The Manager is defined as an interface to allow for multiple implementations of the manager\n    /// and to support upgrades that may be needed in the future to add additional storage fields and functionality.\n    /// \n    /// Key features:\n    /// - Organizes scheduled and executed transactions by handler type and timestamp\n    /// - Simplified scheduling interface that works with previously used transaction handlers\n    /// - Transaction tracking and querying capabilities by handler, timestamp, and ID\n    /// - Handler metadata and view resolution support\n    access(all) resource interface Manager {\n\n        /// Schedules a transaction by passing the arguments directly\n        /// to the FlowTransactionScheduler schedule function\n        /// This also should store the information about the transaction\n        /// and handler in the manager's fields\n        access(Owner) fun schedule(\n            handlerCap: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64\n\n        /// Schedules a transaction that uses a previously used handler\n        /// This should also store the information about the transaction\n        /// and handler in the manager's fields\n        access(Owner) fun scheduleByHandler(\n            handlerTypeIdentifier: String,\n            handlerUUID: UInt64?,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64\n\n        /// Cancels a scheduled transaction by its ID\n        /// This should also remove the information about the transaction from the manager's fields\n        access(Owner) fun cancel(id: UInt64): @FlowToken.Vault\n        \n        access(all) view fun getTransactionData(_ id: UInt64): FlowTransactionScheduler.TransactionData?\n        access(all) view fun borrowTransactionHandlerForID(_ id: UInt64): &{FlowTransactionScheduler.TransactionHandler}?\n        access(all) fun getHandlerTypeIdentifiers(): {String: [UInt64]}\n        access(all) view fun borrowHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): &{FlowTransactionScheduler.TransactionHandler}?\n        access(all) fun getHandlerViews(handlerTypeIdentifier: String, handlerUUID: UInt64?): [Type] \n        access(all) fun resolveHandlerView(handlerTypeIdentifier: String, handlerUUID: UInt64?, viewType: Type): AnyStruct?      \n        access(all) fun getHandlerViewsFromTransactionID(_ id: UInt64): [Type]\n        access(all) fun resolveHandlerViewFromTransactionID(_ id: UInt64, viewType: Type): AnyStruct? \n        access(all) view fun getTransactionIDs(): [UInt64]\n        access(all) view fun getTransactionIDsByHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): [UInt64]\n        access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64]\n        access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]}\n        access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status?\n        access(all) view fun getSortedTimestamps(): FlowTransactionScheduler.SortedTimestamps\n    }\n\n    /// Manager resource is meant to provide users and developers with a simple way\n    /// to group the scheduled transactions that they own into one place to make it more\n    /// convenient to schedule/cancel transactions and get information about the transactions\n    /// that are managed.\n    /// It stores ScheduledTransaction resources in a dictionary and has other fields\n    /// to track the scheduled transactions by timestamp and handler\n    ///\n    access(all) resource ManagerV1: Manager {\n        /// Dictionary storing scheduled transactions by their ID\n        access(self) var scheduledTransactions: @{UInt64: FlowTransactionScheduler.ScheduledTransaction}\n\n        /// Sorted array of timestamps that this manager has transactions scheduled at\n        access(self) var sortedTimestamps: FlowTransactionScheduler.SortedTimestamps\n\n        /// Dictionary storing the IDs of the transactions scheduled at a given timestamp\n        access(self) let idsByTimestamp: {UFix64: [UInt64]}\n\n        /// Dictionary storing the handler UUIDs for transaction IDs\n        access(self) let handlerUUIDsByTransactionID: {UInt64: UInt64}\n\n        /// Dictionary storing the handlers that this manager has scheduled transactions for at one point\n        /// The field differentiates between handlers of the same type by their UUID because there can be multiple handlers of the same type\n        /// that perform the same functionality but maybe do it for different purposes\n        /// so it is important to differentiate between them in case the user needs to retrieve a specific handler\n        /// The metadata for each handler that potentially includes information about the handler's purpose\n        /// can be retrieved from the handler's reference via the getViews() and resolveView() functions\n        access(self) let handlerInfos: {String: {UInt64: HandlerInfo}}\n\n        init() {\n            self.scheduledTransactions <- {}\n            self.sortedTimestamps = FlowTransactionScheduler.SortedTimestamps()\n            self.idsByTimestamp = {}\n            self.handlerUUIDsByTransactionID = {}\n            self.handlerInfos = {}\n        }\n\n        /// scheduleByHandler schedules a transaction by a given handler that has been used before\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param data: Optional data to pass to the transaction when executed\n        /// @param timestamp: The timestamp when the transaction should be executed\n        /// @param priority: The priority of the transaction (High, Medium, or Low)\n        /// @param executionEffort: The execution effort for the transaction\n        /// @param fees: A FlowToken vault containing sufficient fees\n        /// @return: The ID of the scheduled transaction\n        access(Owner) fun scheduleByHandler(\n            handlerTypeIdentifier: String,\n            handlerUUID: UInt64?,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64 {\n            pre {\n                self.handlerInfos.containsKey(handlerTypeIdentifier): \"Invalid handler type identifier: Handler with type identifier \\(handlerTypeIdentifier) not found in manager\"\n                handlerUUID == nil || self.handlerInfos[handlerTypeIdentifier]!.containsKey(handlerUUID!): \"Invalid handler UUID: Handler with type identifier \\(handlerTypeIdentifier) and UUID \\(handlerUUID!) not found in manager\"\n            }\n            let handlers = self.handlerInfos[handlerTypeIdentifier]!\n            var id = handlerUUID\n            if handlerUUID == nil {\n                assert (\n                    handlers.keys.length == 1,\n                    message: \"Invalid handler UUID: Handler with type identifier \\(handlerTypeIdentifier) has more than one UUID, but no UUID was provided\"\n                )\n                id = handlers.keys[0]\n            }\n            return self.schedule(handlerCap: handlers[id!]!.capability, data: data, timestamp: timestamp, priority: priority, executionEffort: executionEffort, fees: <-fees)\n        }\n\n        /// Schedule a transaction and store it in the manager's dictionary\n        /// @param handlerCap: A capability to a resource that implements the TransactionHandler interface\n        /// @param data: Optional data to pass to the transaction when executed\n        /// @param timestamp: The timestamp when the transaction should be executed\n        /// @param priority: The priority of the transaction (High, Medium, or Low)\n        /// @param executionEffort: The execution effort for the transaction\n        /// @param fees: A FlowToken vault containing sufficient fees\n        /// @return: The ID of the scheduled transaction\n        access(Owner) fun schedule(\n            handlerCap: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64 {\n            // Clean up any stale transactions before scheduling a new one\n            self.cleanup()\n\n            // Route to the main FlowTransactionScheduler\n            let scheduledTransaction <- FlowTransactionScheduler.schedule(\n                handlerCap: handlerCap,\n                data: data,\n                timestamp: timestamp,\n                priority: priority,\n                executionEffort: executionEffort,\n                fees: <-fees\n            )\n\n            // Store the handler capability in our dictionary for later retrieval\n            let id = scheduledTransaction.id\n            let actualTimestamp = scheduledTransaction.timestamp\n            let handlerRef = handlerCap.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n            let handlerTypeIdentifier = handlerRef.getType().identifier\n            let handlerUUID = handlerRef.uuid\n\n            self.handlerUUIDsByTransactionID[id] = handlerUUID\n\n            // Store the handler capability in the handlers dictionary for later retrieval\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if let handlerInfo = handlers[handlerUUID] {\n                    handlerInfo.addTransactionID(id: id)\n                    handlers[handlerUUID] = handlerInfo\n                } else {\n                    let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                    handlerInfo.addTransactionID(id: id)\n                    handlers[handlerUUID] = handlerInfo\n                }\n                self.handlerInfos[handlerTypeIdentifier] = handlers\n            } else {\n                let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                handlerInfo.addTransactionID(id: id)\n                let uuidDictionary: {UInt64: HandlerInfo} = {handlerUUID: handlerInfo}\n                self.handlerInfos[handlerTypeIdentifier] = uuidDictionary\n            }\n\n            // Store the transaction in the transactions dictionary\n            self.scheduledTransactions[scheduledTransaction.id] <-! scheduledTransaction\n\n            // Add the transaction to the sorted timestamps array\n            self.sortedTimestamps.add(timestamp: actualTimestamp)\n\n            // Store the transaction in the ids by timestamp dictionary\n            if let ids = self.idsByTimestamp[actualTimestamp] {\n                ids.append(id)\n                self.idsByTimestamp[actualTimestamp] = ids\n            } else {\n                self.idsByTimestamp[actualTimestamp] = [id]\n            }\n\n            return id\n        }\n\n        /// Cancel a scheduled transaction by its ID\n        /// @param id: The ID of the transaction to cancel\n        /// @return: A FlowToken vault containing the refunded fees\n        access(Owner) fun cancel(id: UInt64): @FlowToken.Vault {\n            // Remove the transaction from the transactions dictionary\n            let tx <- self.scheduledTransactions.remove(key: id)\n                ?? panic(\"Invalid ID: Transaction with ID \\(id) not found in manager\")\n\n            self.removeID(id: id, timestamp: tx.timestamp, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n\n            // Cancel the transaction through the main scheduler\n            let refundedFees <- FlowTransactionScheduler.cancel(scheduledTx: <-tx!)\n\n            return <-refundedFees\n        }\n\n        /// Remove an ID from the manager's fields\n        /// @param id: The ID of the transaction to remove\n        /// @param timestamp: The timestamp of the transaction to remove\n        /// @param handlerTypeIdentifier: The type identifier of the handler of the transaction to remove\n        access(self) fun removeID(id: UInt64, timestamp: UFix64, handlerTypeIdentifier: String) {\n            pre {\n                self.handlerInfos.containsKey(handlerTypeIdentifier): \"Invalid handler type identifier: Handler with type identifier \\(handlerTypeIdentifier) not found in manager\"\n            }\n\n            if self.idsByTimestamp.containsKey(timestamp) {\n                let ids = &self.idsByTimestamp[timestamp]! as auth(Mutate) &[UInt64]\n                let index = ids.firstIndex(of: id)\n                ids.remove(at: index!)\n                if ids.length == 0 {\n                    self.idsByTimestamp.remove(key: timestamp)\n                    self.sortedTimestamps.remove(timestamp: timestamp)\n                }\n            }\n\n            if let handlerUUID = self.handlerUUIDsByTransactionID.remove(key: id) {\n                // Remove the transaction ID from the handler info array\n                let handlers = &self.handlerInfos[handlerTypeIdentifier]! as auth(Mutate) &{UInt64: HandlerInfo}\n                if let handlerInfo = handlers[handlerUUID] {\n                    handlerInfo.removeTransactionID(id: id)\n                }\n            }\n        }\n\n        /// Clean up transactions that are no longer valid (return nil or Unknown status)\n        /// This removes and destroys transactions that have been executed, canceled, or are otherwise invalid\n        /// @return: The transactions that were cleaned up (removed from the manager)\n        access(Owner) fun cleanup(): [UInt64] {\n            let currentTimestamp = getCurrentBlock().timestamp\n            var transactionsToRemove: {UInt64: UFix64} = {}\n\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n            for timestamp in pastTimestamps {\n                let ids = self.idsByTimestamp[timestamp] ?? []\n                if ids.length == 0 {\n                    self.sortedTimestamps.remove(timestamp: timestamp)\n                    continue\n                }\n                for id in ids {\n                    let status = FlowTransactionScheduler.getStatus(id: id)\n                    if status == nil || status! != FlowTransactionScheduler.Status.Scheduled {\n                        transactionsToRemove[id] = timestamp\n                        // Need to temporarily limit the number of transactions to remove\n                        // because some managers on mainnet have already hit the limit and we need to batch them\n                        // to make sure they get cleaned up properly\n                        // This will be removed eventually\n                        if transactionsToRemove.length > 50 {\n                            break\n                        }\n                    }\n                }\n            }\n\n            // Then remove and destroy the identified transactions\n            for id in transactionsToRemove.keys {\n                if let tx <- self.scheduledTransactions.remove(key: id) {\n                    self.removeID(id: id, timestamp: transactionsToRemove[id]!, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n                    destroy tx\n                }\n            }\n\n            return transactionsToRemove.keys\n        }\n\n        /// Remove a handler capability from the manager\n        /// The specified handler must not have any transactions scheduled for it\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler\n        access(Owner) fun removeHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?) {\n            // Make sure the handler exists\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                var id = handlerUUID\n                // If no UUID is provided, there must be only one handler of the type\n                if handlerUUID == nil {\n                    if handlers.keys.length > 1 {\n                        // No-op if we don't know which UUID to remove\n                        return\n                    } else if handlers.keys.length == 0 {\n                        self.handlerInfos.remove(key: handlerTypeIdentifier)\n                        return\n                    }\n                    id = handlers.keys[0]\n                }\n                // Make sure the handler has no transactions scheduled for it\n                if let handlerInfo = handlers[id!] {\n                    if handlerInfo.transactionIDs.length > 0 {\n                        return\n                    }\n                }\n                // Remove the handler uuid from the handlers dictionary\n                handlers.remove(key: id!)\n\n                // If there are no more handlers of the type, remove the type from the handlers dictionary\n                if handlers.keys.length == 0 {\n                    self.handlerInfos.remove(key: handlerTypeIdentifier)\n                } else {\n                    self.handlerInfos[handlerTypeIdentifier] = handlers\n                }\n            }\n        }\n\n        /// Get transaction data by its ID\n        /// @param id: The ID of the transaction to retrieve\n        /// @return: The transaction data from FlowTransactionScheduler, or nil if not found\n        access(all) view fun getTransactionData(_ id: UInt64): FlowTransactionScheduler.TransactionData? {\n            if self.scheduledTransactions.containsKey(id) {\n                return FlowTransactionScheduler.getTransactionData(id: id)\n            }\n            return nil\n        }\n\n        /// Get an un-entitled reference to a transaction handler of a given ID\n        /// @param id: The ID of the transaction to retrieve\n        /// @return: A reference to the transaction handler, or nil if not found\n        access(all) view fun borrowTransactionHandlerForID(_ id: UInt64): &{FlowTransactionScheduler.TransactionHandler}? {\n            let txData = self.getTransactionData(id)\n            return txData?.borrowHandler()\n        }\n\n        /// Get all the handler type identifiers that the manager has scheduled transactions for\n        /// @return: A dictionary of all handler type identifiers and their UUIDs\n        access(all) fun getHandlerTypeIdentifiers(): {String: [UInt64]} {\n            var handlerTypeIdentifiers: {String: [UInt64]} = {}\n            for handlerTypeIdentifier in self.handlerInfos.keys {\n                let handlerUUIDs: [UInt64] = []\n                let handlerTypes = self.handlerInfos[handlerTypeIdentifier]!\n                for uuid in handlerTypes.keys {\n                    let handlerInfo = handlerTypes[uuid]!\n                    if !handlerInfo.capability.check() {\n                        continue\n                    }\n                    handlerUUIDs.append(uuid)\n                }\n                handlerTypeIdentifiers[handlerTypeIdentifier] = handlerUUIDs\n            }\n            return handlerTypeIdentifiers\n        }\n\n        /// Get an un-entitled reference to a handler by a given type identifier\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @return: An un-entitled reference to the handler, or nil if not found\n        access(all) view fun borrowHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): &{FlowTransactionScheduler.TransactionHandler}? {\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if handlerUUID != nil {\n                    if let handlerInfo = handlers[handlerUUID!] {\n                        return handlerInfo.borrow()\n                    } \n                } else if handlers.keys.length == 1 {\n                    // If no uuid is provided, we can just default to the only handler uuid\n                    return handlers[handlers.keys[0]]!.borrow()\n                }\n            }\n            return nil\n        }\n\n        /// Get all the views that a handler implements\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @return: An array of all views\n        access(all) fun getHandlerViews(handlerTypeIdentifier: String, handlerUUID: UInt64?): [Type] {\n            if let handler = self.borrowHandler(handlerTypeIdentifier: handlerTypeIdentifier, handlerUUID: handlerUUID) {\n                return handler.getViews()\n            }\n            return []\n        }\n\n        /// Resolve a view for a handler by a given type identifier\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @param viewType: The type of the view to resolve\n        /// @return: The resolved view, or nil if not found\n        access(all) fun resolveHandlerView(handlerTypeIdentifier: String, handlerUUID: UInt64?, viewType: Type): AnyStruct? {\n            if let handler = self.borrowHandler(handlerTypeIdentifier: handlerTypeIdentifier, handlerUUID: handlerUUID) {\n                return handler.resolveView(viewType)\n            }\n            return nil\n        }\n\n        /// Get all the views that a handler implements from a given transaction ID\n        /// @param transactionId: The ID of the transaction\n        /// @return: An array of all views\n        access(all) fun getHandlerViewsFromTransactionID(_ id: UInt64): [Type] {\n            if let handler = self.borrowTransactionHandlerForID(id) {\n                return handler.getViews()\n            }\n            return []\n        }\n\n        /// Resolve a view for a handler from a given transaction ID\n        /// @param transactionId: The ID of the transaction\n        /// @param viewType: The type of the view to resolve\n        /// @return: The resolved view, or nil if not found\n        access(all) fun resolveHandlerViewFromTransactionID(_ id: UInt64, viewType: Type): AnyStruct? {\n            if let handler = self.borrowTransactionHandlerForID(id) {\n                return handler.resolveView(viewType)\n            }\n            return nil\n        }\n\n        /// Get all transaction IDs stored in the manager\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDs(): [UInt64] {\n            return self.scheduledTransactions.keys\n        }\n\n        /// Get all transaction IDs stored in the manager by a given handler\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDsByHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): [UInt64] {\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if handlerUUID != nil {\n                    if let handlerInfo = handlers[handlerUUID!] {\n                        return handlerInfo.transactionIDs\n                    } \n                } else if handlers.keys.length == 1 {\n                    // If no uuid is provided, we can just default to the only handler uuid\n                    return handlers[handlers.keys[0]]!.transactionIDs\n                }\n            }\n            return []\n        }\n\n        /// Get all transaction IDs stored in the manager by a given timestamp\n        /// @param timestamp: The timestamp\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64] {\n            return self.idsByTimestamp[timestamp] ?? []\n        }\n\n        /// Get all the timestamps and IDs from a given range of timestamps\n        /// @param startTimestamp: The start timestamp\n        /// @param endTimestamp: The end timestamp\n        /// @return: A dictionary of timestamps and IDs\n        access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]} {\n            var transactionsInTimeframe: {UFix64: [UInt64]} = {}\n            \n            // Validate input parameters\n            if startTimestamp > endTimestamp {\n                return transactionsInTimeframe\n            }\n            \n            // Get all timestamps that fall within the specified range\n            let allTimestampsBeforeEnd = self.sortedTimestamps.getBefore(current: endTimestamp)\n            \n            for timestamp in allTimestampsBeforeEnd {\n                // Check if this timestamp falls within our range\n                if timestamp < startTimestamp { continue }\n                \n                var timestampTransactions: [UInt64] = self.idsByTimestamp[timestamp] ?? []\n                \n                if timestampTransactions.length > 0 {\n                    transactionsInTimeframe[timestamp] = timestampTransactions\n                }\n            }\n            \n            return transactionsInTimeframe\n        }\n\n        /// Get the status of a transaction by its ID\n        /// @param id: The ID of the transaction\n        /// @return: The status of the transaction, or Status.Unknown if not found in manager\n        access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status? {\n            if self.scheduledTransactions.containsKey(id) {\n                return FlowTransactionScheduler.getStatus(id: id)\n            }\n            return FlowTransactionScheduler.Status.Unknown\n        }\n\n        /// Gets the sorted timestamps struct\n        /// @return: The sorted timestamps struct\n        access(all) view fun getSortedTimestamps(): FlowTransactionScheduler.SortedTimestamps {\n            return self.sortedTimestamps\n        }\n    }\n\n    /// Create a new Manager instance\n    /// @return: A new Manager resource\n    access(all) fun createManager(): @{Manager} {\n        return <-create ManagerV1()\n    }\n\n    access(all) init() {\n        self.managerStoragePath = /storage/flowTransactionSchedulerManager\n        self.managerPublicPath = /public/flowTransactionSchedulerManager\n    }\n\n    /// Get a public reference to a manager at the given address\n    /// @param address: The address of the manager\n    /// @return: A public reference to the manager\n    access(all) view fun borrowManager(at: Address): &{Manager}? {\n        return getAccount(at).capabilities.borrow<&{Manager}>(self.managerPublicPath)\n    }\n\n    /********************************************\n    \n    Scheduled Transactions Metadata Views\n    \n    ***********************************************/\n\n}",
      "valid_from": 135783129,
      "valid_to": 138787574,
      "created_at": "2025-12-12T16:09:05.008Z",
      "deployments": 3,
      "imported_by": [
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV4",
        "A.6a3c3dad7074bca5.PrizeVaultScheduler",
        "A.6dec6e64a13b881e.FlowCron",
        "A.a092c4aab33daeda.PrizeVaultScheduler"
      ],
      "imported_count": 4,
      "import_count": 2,
      "tags": null
    },
    {
      "name": "FlowTransactionScheduler",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.FlowTransactionScheduler/130192448",
      "id": "A.e467b9dd11fa00df.FlowTransactionScheduler/131028293",
      "identifier": "A.e467b9dd11fa00df.FlowTransactionScheduler",
      "transaction_hash": "077522dd3aabe1fe9f98960a9c66433fce0aef2cb0a253b2841ae3df4b256b2a",
      "status": "ok",
      "diff": "--- 2e4c7aedbe40c591023d70264adb927c62c13c45a73d9a1e11d5ef9220d6195b.130192448\n+++ 077522dd3aabe1fe9f98960a9c66433fce0aef2cb0a253b2841ae3df4b256b2a.131028293\n@@ -439,8 +439,6 @@\n             self.canceledTransactionsLimit = canceledTransactionsLimit\n             self.collectionEffortLimit = collectionEffortLimit\n             self.collectionTransactionsLimit = collectionTransactionsLimit\n-            FlowTransactionScheduler.account.storage.load<UInt>(from: /storage/txRemovalLimit)\n-            FlowTransactionScheduler.account.storage.save(txRemovalLimit, to: /storage/txRemovalLimit)\n         }\n \n         access(all) view fun getTxRemovalLimit(): UInt {\n@@ -607,8 +605,10 @@\n         }\n \n         /// sets all the configuration details for the Scheduler resource\n-        access(UpdateConfig) fun setConfig(newConfig: {SchedulerConfig}) {\n+        access(UpdateConfig) fun setConfig(newConfig: {SchedulerConfig}, txRemovalLimit: UInt) {\n             self.config = newConfig\n+            FlowTransactionScheduler.account.storage.load<UInt>(from: /storage/txRemovalLimit)\n+            FlowTransactionScheduler.account.storage.save(txRemovalLimit, to: /storage/txRemovalLimit)\n             emit ConfigUpdated()\n         }\n \n",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowFees from 0xf919ee77447b7497\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport ViewResolver from 0x1d7e57aa55817448\n\n/// FlowTransactionScheduler enables smart contracts to schedule autonomous execution in the future.\n///\n/// This contract implements FLIP 330's scheduled transaction system, allowing contracts to \"wake up\" and execute\n/// logic at predefined times without external triggers. \n///\n/// Scheduled transactions are prioritized (High/Medium/Low) with different execution guarantees and fee multipliers: \n///   - High priority guarantees first-block execution,\n///   - Medium priority provides best-effort scheduling,\n///   - Low priority executes opportunistically when capacity allows after the time it was scheduled. \n///\n/// The system uses time slots with execution effort limits to manage network resources,\n/// ensuring predictable performance while enabling novel autonomous blockchain patterns like recurring\n/// payments, automated arbitrage, and time-based contract logic.\naccess(all) contract FlowTransactionScheduler {\n\n    /// singleton instance used to store all scheduled transaction data\n    /// and route all scheduled transaction functionality\n    access(self) var sharedScheduler: Capability<auth(Cancel) &SharedScheduler>\n\n    /// storage path for the singleton scheduler resource\n    access(all) let storagePath: StoragePath\n\n    /// Enums\n\n    /// Priority\n    access(all) enum Priority: UInt8 {\n        access(all) case High\n        access(all) case Medium\n        access(all) case Low\n    }\n\n    /// Status\n    access(all) enum Status: UInt8 {\n        /// unknown statuses are used for handling historic scheduled transactions with null statuses\n        access(all) case Unknown\n        /// mutable status\n        access(all) case Scheduled\n        /// finalized statuses\n        access(all) case Executed\n        access(all) case Canceled\n    }\n\n    /// Events\n\n    /// Emitted when a transaction is scheduled\n    access(all) event Scheduled(\n        id: UInt64,\n        priority: UInt8,\n        timestamp: UFix64,\n        executionEffort: UInt64,\n        fees: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String,\n        transactionHandlerUUID: UInt64,\n        \n        // The public path of the transaction handler that can be used to resolve views\n        // DISCLAIMER: There is no guarantee that the public path is accurate\n        transactionHandlerPublicPath: PublicPath?\n    )\n\n    /// Emitted when a scheduled transaction's scheduled timestamp is reached and it is ready for execution\n    access(all) event PendingExecution(\n        id: UInt64,\n        priority: UInt8,\n        executionEffort: UInt64,\n        fees: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String\n    )\n\n    /// Emitted when a scheduled transaction is executed by the FVM\n    access(all) event Executed(\n        id: UInt64,\n        priority: UInt8,\n        executionEffort: UInt64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String,\n        transactionHandlerUUID: UInt64,\n\n        // The public path of the transaction handler that can be used to resolve views\n        // DISCLAIMER: There is no guarantee that the public path is accurate\n        transactionHandlerPublicPath: PublicPath?\n    )\n\n    /// Emitted when a scheduled transaction is canceled by the creator of the transaction\n    access(all) event Canceled(\n        id: UInt64,\n        priority: UInt8,\n        feesReturned: UFix64,\n        feesDeducted: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String\n    )\n\n    /// Emitted when a collection limit is reached\n    /// The limit that was reached is non-nil and is the limit that was reached\n    /// The other limit that was not reached is nil\n    access(all) event CollectionLimitReached(\n        collectionEffortLimit: UInt64?,\n        collectionTransactionsLimit: Int?\n    )\n\n    /// Emitted when the limit on the number of transactions that can be removed in process() is reached\n    access(all) event RemovalLimitReached()\n\n    // Emitted when one or more of the configuration details fields are updated\n    // Event listeners can listen to this and query the new configuration\n    // if they need to\n    access(all) event ConfigUpdated()\n\n    // Emitted when a critical issue is encountered\n    access(all) event CriticalIssue(message: String)\n\n    /// Entitlements\n    access(all) entitlement Execute\n    access(all) entitlement Process\n    access(all) entitlement Cancel\n    access(all) entitlement UpdateConfig\n\n    /// Interfaces\n\n    /// TransactionHandler is an interface that defines a single method executeTransaction that \n    /// must be implemented by the resource that contains the logic to be executed by the scheduled transaction.\n    /// An authorized capability to this resource is provided when scheduling a transaction.\n    /// The transaction scheduler uses this capability to execute the transaction when its scheduled timestamp arrives.\n    access(all) resource interface TransactionHandler: ViewResolver.Resolver {\n\n        access(all) view fun getViews(): [Type] {\n            return []\n        }\n\n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            return nil\n        }\n\n        /// Executes the implemented transaction logic\n        ///\n        /// @param id: The id of the scheduled transaction (this can be useful for any internal tracking)\n        /// @param data: The data that was passed when the transaction was originally scheduled\n        /// that may be useful for the execution of the transaction logic\n        access(Execute) fun executeTransaction(id: UInt64, data: AnyStruct?)\n    }\n\n    /// Structs\n\n    /// ScheduledTransaction is the resource that the user receives after scheduling a transaction.\n    /// It allows them to get the status of their transaction and can be passed back\n    /// to the scheduler contract to cancel the transaction if it has not yet been executed. \n    access(all) resource ScheduledTransaction {\n        access(all) let id: UInt64\n        access(all) let timestamp: UFix64\n        access(all) let handlerTypeIdentifier: String\n\n        access(all) view fun status(): Status? {\n            return FlowTransactionScheduler.sharedScheduler.borrow()!.getStatus(id: self.id)\n        }\n\n        init(\n            id: UInt64, \n            timestamp: UFix64,\n            handlerTypeIdentifier: String\n        ) {\n            self.id = id\n            self.timestamp = timestamp\n            self.handlerTypeIdentifier = handlerTypeIdentifier\n        }\n\n        // event emitted when the resource is destroyed\n        access(all) event ResourceDestroyed(id: UInt64 = self.id, timestamp: UFix64 = self.timestamp, handlerTypeIdentifier: String = self.handlerTypeIdentifier)\n    }\n\n    /// EstimatedScheduledTransaction contains data for estimating transaction scheduling.\n    access(all) struct EstimatedScheduledTransaction {\n        /// flowFee is the estimated fee in Flow for the transaction to be scheduled\n        access(all) let flowFee: UFix64?\n        /// timestamp is estimated timestamp that the transaction will be executed at\n        access(all) let timestamp: UFix64?\n        /// error is an optional error message if the transaction cannot be scheduled\n        access(all) let error: String?\n\n        access(contract) view init(flowFee: UFix64?, timestamp: UFix64?, error: String?) {\n            self.flowFee = flowFee\n            self.timestamp = timestamp\n            self.error = error\n        }\n    }\n\n    /// Transaction data is a representation of a scheduled transaction\n    /// It is the source of truth for an individual transaction and stores the\n    /// capability to the handler that contains the logic that will be executed by the transaction.\n    access(all) struct TransactionData {\n        access(all) let id: UInt64\n        access(all) let priority: Priority\n        access(all) let executionEffort: UInt64\n        access(all) var status: Status\n\n        /// Fee amount to pay for the transaction\n        access(all) let fees: UFix64\n\n        /// The timestamp that the transaction is scheduled for\n        /// For medium priority transactions, it may be different than the requested timestamp\n        /// For low priority transactions, it is the requested timestamp,\n        /// but the timestamp where the transaction is actually executed may be different\n        access(all) var scheduledTimestamp: UFix64\n\n        /// Capability to the logic that the transaction will execute\n        access(contract) let handler: Capability<auth(Execute) &{TransactionHandler}>\n\n        /// Type identifier of the transaction handler\n        access(all) let handlerTypeIdentifier: String\n        access(all) let handlerAddress: Address\n\n        /// Optional data that can be passed to the handler\n        access(contract) let data: AnyStruct?\n\n        access(contract) init(\n            id: UInt64,\n            handler: Capability<auth(Execute) &{TransactionHandler}>,\n            scheduledTimestamp: UFix64,\n            data: AnyStruct?,\n            priority: Priority,\n            executionEffort: UInt64,\n            fees: UFix64,\n        ) {\n            self.id = id\n            self.handler = handler\n            self.data = data\n            self.priority = priority\n            self.executionEffort = executionEffort\n            self.fees = fees\n            self.status = Status.Scheduled\n            let handlerRef = handler.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n            self.handlerAddress = handler.address\n            self.handlerTypeIdentifier = handlerRef.getType().identifier\n            self.scheduledTimestamp = scheduledTimestamp\n        }\n\n        /// setStatus updates the status of the transaction.\n        /// It panics if the transaction status is already finalized.\n        access(contract) fun setStatus(newStatus: Status) {\n            pre {\n                newStatus != Status.Unknown: \"Invalid status: New status cannot be Unknown\"\n                self.status != Status.Executed && self.status != Status.Canceled:\n                    \"Invalid status: Transaction with id \\(self.id) is already finalized\"\n                newStatus == Status.Executed ? self.status == Status.Scheduled : true:\n                    \"Invalid status: Transaction with id \\(self.id) can only be set as Executed if it is Scheduled\"\n                newStatus == Status.Canceled ? self.status == Status.Scheduled : true:\n                    \"Invalid status: Transaction with id \\(self.id) can only be set as Canceled if it is Scheduled\"\n            }\n\n            self.status = newStatus\n        }\n\n        /// setScheduledTimestamp updates the scheduled timestamp of the transaction.\n        /// It panics if the transaction status is already finalized.\n        access(contract) fun setScheduledTimestamp(newTimestamp: UFix64) {\n            pre {\n                self.status != Status.Executed && self.status != Status.Canceled:\n                    \"Invalid status: Transaction with id \\(self.id) is already finalized\"\n            }\n            self.scheduledTimestamp = newTimestamp\n        }\n\n        /// payAndRefundFees withdraws fees from the transaction based on the refund multiplier.\n        /// It deposits any leftover fees to the FlowFees vault to be used to pay node operator rewards\n        /// like any other transaction on the Flow network.\n        access(contract) fun payAndRefundFees(refundMultiplier: UFix64): @FlowToken.Vault {\n            pre {\n                refundMultiplier >= 0.0 && refundMultiplier <= 1.0:\n                    \"Invalid refund multiplier: The multiplier must be between 0.0 and 1.0 but got \\(refundMultiplier)\"\n            }\n            if refundMultiplier == 0.0 {\n                FlowFees.deposit(from: <-FlowTransactionScheduler.withdrawFees(amount: self.fees))\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            } else {\n                let amountToReturn = self.fees * refundMultiplier\n                let amountToKeep = self.fees - amountToReturn\n                let feesToReturn <- FlowTransactionScheduler.withdrawFees(amount: amountToReturn)\n                FlowFees.deposit(from: <-FlowTransactionScheduler.withdrawFees(amount: amountToKeep))\n                return <-feesToReturn\n            }\n        }\n\n        /// getData copies and returns the data field\n        access(contract) view fun getData(): AnyStruct? {\n            return self.data\n        }\n\n        /// borrowHandler returns an un-entitled reference to the transaction handler\n        /// This allows users to query metadata views about the handler\n        /// @return: An un-entitled reference to the transaction handler\n        access(all) view fun borrowHandler(): &{TransactionHandler} {\n            return self.handler.borrow() as? &{TransactionHandler}\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n        }\n    }\n\n    /// Struct interface representing all the base configuration details in the Scheduler contract\n    /// that is used for governing the protocol\n    /// This is an interface to allow for the configuration details to be updated in the future\n    access(all) struct interface SchedulerConfig {\n\n        /// maximum effort that can be used for any transaction\n        access(all) var maximumIndividualEffort: UInt64\n\n        /// minimum execution effort is the minimum effort that can be \n        /// used for any transaction\n        access(all) var minimumExecutionEffort: UInt64\n\n        /// slot total effort limit is the maximum effort that can be \n        /// cumulatively allocated to one timeslot by all priorities\n        access(all) var slotTotalEffortLimit: UInt64\n\n        /// slot shared effort limit is the maximum effort \n        /// that can be allocated to high and medium priority \n        /// transactions combined after their exclusive effort reserves have been filled\n        access(all) var slotSharedEffortLimit: UInt64\n\n        /// priority effort reserve is the amount of effort that is \n        /// reserved exclusively for each priority\n        access(all) var priorityEffortReserve: {Priority: UInt64}\n\n        /// priority effort limit is the maximum cumulative effort per priority in a timeslot\n        access(all) var priorityEffortLimit: {Priority: UInt64}\n\n        /// max data size is the maximum data size that can be stored for a transaction\n        access(all) var maxDataSizeMB: UFix64\n\n        /// priority fee multipliers are values we use to calculate the added \n        /// processing fee for each priority\n        access(all) var priorityFeeMultipliers: {Priority: UFix64}\n\n        /// refund multiplier is the portion of the fees that are refunded when any transaction is cancelled\n        access(all) var refundMultiplier: UFix64\n\n        /// canceledTransactionsLimit is the maximum number of canceled transactions\n        /// to keep in the canceledTransactions array\n        access(all) var canceledTransactionsLimit: UInt\n\n        /// collectionEffortLimit is the maximum effort that can be used for all transactions in a collection\n        access(all) var collectionEffortLimit: UInt64\n\n        /// collectionTransactionsLimit is the maximum number of transactions that can be processed in a collection\n        access(all) var collectionTransactionsLimit: Int\n\n        access(all) init(\n            maximumIndividualEffort: UInt64,\n            minimumExecutionEffort: UInt64,\n            slotSharedEffortLimit: UInt64,\n            priorityEffortReserve: {Priority: UInt64},\n            lowPriorityEffortLimit: UInt64,\n            maxDataSizeMB: UFix64,\n            priorityFeeMultipliers: {Priority: UFix64},\n            refundMultiplier: UFix64,\n            canceledTransactionsLimit: UInt,\n            collectionEffortLimit: UInt64,\n            collectionTransactionsLimit: Int,\n            txRemovalLimit: UInt\n        ) {\n            post {\n                self.refundMultiplier >= 0.0 && self.refundMultiplier <= 1.0:\n                    \"Invalid refund multiplier: The multiplier must be between 0.0 and 1.0 but got \\(refundMultiplier)\"\n                self.priorityFeeMultipliers[Priority.Low]! >= 1.0:\n                    \"Invalid priority fee multiplier: Low priority multiplier must be greater than or equal to 1.0 but got \\(self.priorityFeeMultipliers[Priority.Low]!)\"\n                self.priorityFeeMultipliers[Priority.Medium]! > self.priorityFeeMultipliers[Priority.Low]!:\n                    \"Invalid priority fee multiplier: Medium priority multiplier must be greater than or equal to \\(priorityFeeMultipliers[Priority.Low]!) but got \\(priorityFeeMultipliers[Priority.Medium]!)\"\n                self.priorityFeeMultipliers[Priority.High]! > self.priorityFeeMultipliers[Priority.Medium]!:\n                    \"Invalid priority fee multiplier: High priority multiplier must be greater than or equal to \\(priorityFeeMultipliers[Priority.Medium]!) but got \\(priorityFeeMultipliers[Priority.High]!)\"\n                self.priorityEffortLimit[Priority.High]! >= self.priorityEffortReserve[Priority.High]!:\n                    \"Invalid priority effort limit: High priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.High]!)\"\n                self.priorityEffortLimit[Priority.Medium]! >= self.priorityEffortReserve[Priority.Medium]!:\n                    \"Invalid priority effort limit: Medium priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.Medium]!)\"\n                self.priorityEffortLimit[Priority.Low]! >= self.priorityEffortReserve[Priority.Low]!:\n                    \"Invalid priority effort limit: Low priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.Low]!)\"\n                self.priorityEffortReserve[Priority.Low]! == 0:\n                    \"Invalid priority effort reserve: Low priority effort reserve must be 0\"\n                self.collectionTransactionsLimit >= 0:\n                    \"Invalid collection transactions limit: Collection transactions limit must be greater than or equal to 0 but got \\(collectionTransactionsLimit)\"\n                self.canceledTransactionsLimit >= 1:\n                    \"Invalid canceled transactions limit: Canceled transactions limit must be greater than or equal to 1 but got \\(canceledTransactionsLimit)\"\n                self.collectionEffortLimit > self.slotTotalEffortLimit:\n                    \"Invalid collection effort limit: Collection effort limit must be greater than \\(self.slotTotalEffortLimit) but got \\(self.collectionEffortLimit)\"\n            }\n        }\n\n        access(all) view fun getTxRemovalLimit(): UInt\n    }\n\n    /// Concrete implementation of the SchedulerConfig interface\n    /// This struct is used to store the configuration details in the Scheduler contract\n    access(all) struct Config: SchedulerConfig {\n        access(all) var maximumIndividualEffort: UInt64\n        access(all) var minimumExecutionEffort: UInt64\n        access(all) var slotTotalEffortLimit: UInt64\n        access(all) var slotSharedEffortLimit: UInt64\n        access(all) var priorityEffortReserve: {Priority: UInt64}\n        access(all) var priorityEffortLimit: {Priority: UInt64}\n        access(all) var maxDataSizeMB: UFix64\n        access(all) var priorityFeeMultipliers: {Priority: UFix64}\n        access(all) var refundMultiplier: UFix64\n        access(all) var canceledTransactionsLimit: UInt\n        access(all) var collectionEffortLimit: UInt64\n        access(all) var collectionTransactionsLimit: Int\n\n        access(all) init(   \n            maximumIndividualEffort: UInt64,\n            minimumExecutionEffort: UInt64,\n            slotSharedEffortLimit: UInt64,\n            priorityEffortReserve: {Priority: UInt64},\n            lowPriorityEffortLimit: UInt64,\n            maxDataSizeMB: UFix64,\n            priorityFeeMultipliers: {Priority: UFix64},\n            refundMultiplier: UFix64,\n            canceledTransactionsLimit: UInt,\n            collectionEffortLimit: UInt64,\n            collectionTransactionsLimit: Int,\n            txRemovalLimit: UInt\n        ) {\n            self.maximumIndividualEffort = maximumIndividualEffort\n            self.minimumExecutionEffort = minimumExecutionEffort\n            self.slotTotalEffortLimit = slotSharedEffortLimit + priorityEffortReserve[Priority.High]! + priorityEffortReserve[Priority.Medium]!\n            self.slotSharedEffortLimit = slotSharedEffortLimit\n            self.priorityEffortReserve = priorityEffortReserve\n            self.priorityEffortLimit = {\n                Priority.High: priorityEffortReserve[Priority.High]! + slotSharedEffortLimit,\n                Priority.Medium: priorityEffortReserve[Priority.Medium]! + slotSharedEffortLimit,\n                Priority.Low: lowPriorityEffortLimit\n            }\n            self.maxDataSizeMB = maxDataSizeMB\n            self.priorityFeeMultipliers = priorityFeeMultipliers\n            self.refundMultiplier = refundMultiplier\n            self.canceledTransactionsLimit = canceledTransactionsLimit\n            self.collectionEffortLimit = collectionEffortLimit\n            self.collectionTransactionsLimit = collectionTransactionsLimit\n        }\n\n        access(all) view fun getTxRemovalLimit(): UInt {\n            return FlowTransactionScheduler.account.storage.copy<UInt>(from: /storage/txRemovalLimit)\n                ?? 200\n        }\n    }\n\n\n    /// SortedTimestamps maintains timestamps sorted in ascending order for efficient processing\n    /// It encapsulates all operations related to maintaining and querying sorted timestamps\n    access(all) struct SortedTimestamps {\n        /// Internal sorted array of timestamps\n        access(self) var timestamps: [UFix64]\n\n        access(all) init() {\n            self.timestamps = []\n        }\n\n        /// Add a timestamp to the sorted array maintaining sorted order\n        access(all) fun add(timestamp: UFix64) {\n\n            var insertIndex = 0\n            for i, ts in self.timestamps {\n                if timestamp < ts {\n                    insertIndex = i\n                    break\n                } else if timestamp == ts {\n                    return\n                }\n                insertIndex = i + 1\n            }\n            self.timestamps.insert(at: insertIndex, timestamp)\n        }\n\n        /// Remove a timestamp from the sorted array\n        access(all) fun remove(timestamp: UFix64) {\n\n            let index = self.timestamps.firstIndex(of: timestamp)\n            if index != nil {\n                self.timestamps.remove(at: index!)\n            }\n        }\n\n        /// Get all timestamps that are in the past (less than or equal to current timestamp)\n        access(all) fun getBefore(current: UFix64): [UFix64] {\n            let pastTimestamps: [UFix64] = []\n            for timestamp in self.timestamps {\n                if timestamp <= current {\n                    pastTimestamps.append(timestamp)\n                } else {\n                    break  // No need to check further since array is sorted\n                }\n            }\n            return pastTimestamps\n        }\n\n        /// Check if there are any timestamps that need processing\n        /// Returns true if processing is needed, false for early exit\n        access(all) fun hasBefore(current: UFix64): Bool {\n            return self.timestamps.length > 0 && self.timestamps[0] <= current\n        }\n\n        /// Get the whole array of timestamps\n        access(all) fun getAll(): [UFix64] {\n            return self.timestamps\n        }\n    }\n\n    /// Resources\n\n    /// Shared scheduler is a resource that is used as a singleton in the scheduler contract and contains \n    /// all the functionality to schedule, process and execute transactions as well as the internal state. \n    access(all) resource SharedScheduler {\n        /// nextID contains the next transaction ID to be assigned\n        /// This the ID is monotonically increasing and is used to identify each transaction\n        access(contract) var nextID: UInt64\n\n        /// transactions is a map of transaction IDs to TransactionData structs\n        access(contract) var transactions: {UInt64: TransactionData}\n\n        /// slot queue is a map of timestamps to Priorities to transaction IDs and their execution efforts\n        access(contract) var slotQueue: {UFix64: {Priority: {UInt64: UInt64}}}\n\n        /// slot used effort is a map of timestamps map of priorities and \n        /// efforts that has been used for the timeslot\n        access(contract) var slotUsedEffort: {UFix64: {Priority: UInt64}}\n\n        /// sorted timestamps manager for efficient processing\n        access(contract) var sortedTimestamps: SortedTimestamps\n    \n        /// canceled transactions keeps a record of canceled transaction IDs up to a canceledTransactionsLimit\n        access(contract) var canceledTransactions: [UInt64]\n\n        /// Struct that contains all the configuration details for the transaction scheduler protocol\n        /// Can be updated by the owner of the contract\n        access(contract) var config: {SchedulerConfig}\n\n        access(all) init() {\n            self.nextID = 1\n            self.canceledTransactions = [0 as UInt64]\n            \n            self.transactions = {}\n            self.slotUsedEffort = {}\n            self.slotQueue = {}\n            self.sortedTimestamps = SortedTimestamps()\n            \n            /* Default slot efforts and limits look like this:\n\n                Timestamp Slot (17.5kee)\n                \n                           \n                  High Only             High: 15kee max\n                    10kee               (10 exclusive + 5 shared)\n                          \n                |        |\n                 |  Shared Pool         |\n                |  (High+Medium)        |\n                |      5kee            |\n                |        |\n                           Medium: 7.5kee max  \n                  Medium Only           (2.5 exclusive + 5 shared)\n                    2.5kee               \n                          \n                   Low: 2.5kee max\n                  Low (if space left)   (execution time only)\n                        2.5kee           \n                  \n                \n            */\n\n            let sharedEffortLimit: UInt64 = 5_000\n            let highPriorityEffortReserve: UInt64 = 10_000\n            let mediumPriorityEffortReserve: UInt64 = 2_500\n\n            self.config = Config(\n                maximumIndividualEffort: 9999,\n                minimumExecutionEffort: 100,\n                slotSharedEffortLimit: sharedEffortLimit,\n                priorityEffortReserve: {\n                    Priority.High: highPriorityEffortReserve,\n                    Priority.Medium: mediumPriorityEffortReserve,\n                    Priority.Low: 0\n                },\n                lowPriorityEffortLimit: 2_500,\n                maxDataSizeMB: 0.001,\n                priorityFeeMultipliers: {\n                    Priority.High: 10.0,\n                    Priority.Medium: 5.0,\n                    Priority.Low: 2.0\n                },\n                refundMultiplier: 0.5,\n                canceledTransactionsLimit: 1000,\n                collectionEffortLimit: 500_000, // Maximum effort for all transactions in a collection\n                collectionTransactionsLimit: 150, // Maximum number of transactions in a collection\n                txRemovalLimit: 200\n            )\n        }\n\n        /// Gets a copy of the struct containing all the configuration details\n        /// of the Scheduler resource\n        access(contract) view fun getConfig(): {SchedulerConfig} {\n            return self.config\n        }\n\n        /// sets all the configuration details for the Scheduler resource\n        access(UpdateConfig) fun setConfig(newConfig: {SchedulerConfig}, txRemovalLimit: UInt) {\n            self.config = newConfig\n            FlowTransactionScheduler.account.storage.load<UInt>(from: /storage/txRemovalLimit)\n            FlowTransactionScheduler.account.storage.save(txRemovalLimit, to: /storage/txRemovalLimit)\n            emit ConfigUpdated()\n        }\n\n        /// getTransaction returns a copy of the specified transaction\n        access(contract) view fun getTransaction(id: UInt64): TransactionData? {\n            return self.transactions[id]\n        }\n\n        /// borrowTransaction borrows a reference to the specified transaction\n        access(contract) view fun borrowTransaction(id: UInt64): &TransactionData? {\n            return &self.transactions[id]\n        }\n\n        /// getCanceledTransactions returns a copy of the canceled transactions array\n        access(contract) view fun getCanceledTransactions(): [UInt64] {\n            return self.canceledTransactions\n        }\n\n        /// getTransactionsForTimeframe returns a dictionary of transactions scheduled within a specified time range,\n        /// organized by timestamp and priority with arrays of transaction IDs.\n        /// WARNING: If you provide a time range that is too large, the function will likely fail to complete\n        /// because the function will run out of gas. Keep the time range small.\n        ///\n        /// @param startTimestamp: The start timestamp (inclusive) for the time range\n        /// @param endTimestamp: The end timestamp (inclusive) for the time range\n        /// @return {UFix64: {Priority: [UInt64]}}: A dictionary mapping timestamps to priorities to arrays of transaction IDs\n        access(contract) fun getTransactionsForTimeframe(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: {UInt8: [UInt64]}} {\n            var transactionsInTimeframe: {UFix64: {UInt8: [UInt64]}} = {}\n            \n            // Validate input parameters\n            if startTimestamp > endTimestamp {\n                return transactionsInTimeframe\n            }\n            \n            // Get all timestamps that fall within the specified range\n            let allTimestampsBeforeEnd = self.sortedTimestamps.getBefore(current: endTimestamp)\n            \n            for timestamp in allTimestampsBeforeEnd {\n                // Check if this timestamp falls within our range\n                if timestamp < startTimestamp { continue }\n                \n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                \n                var timestampTransactions: {UInt8: [UInt64]} = {}\n                \n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    var priorityTransactions: [UInt64] = []\n                        \n                    for id in transactionIDs.keys {\n                        priorityTransactions.append(id)\n                    }\n                        \n                    if priorityTransactions.length > 0 {\n                        timestampTransactions[priority.rawValue] = priorityTransactions\n                    }\n                }\n                \n                if timestampTransactions.keys.length > 0 {\n                    transactionsInTimeframe[timestamp] = timestampTransactions\n                }\n                \n            }\n            \n            return transactionsInTimeframe\n        }\n\n        /// calculate fee by converting execution effort to a fee in Flow tokens.\n        /// @param executionEffort: The execution effort of the transaction\n        /// @param priority: The priority of the transaction\n        /// @param dataSizeMB: The size of the data that was passed when the transaction was originally scheduled\n        /// @return UFix64: The fee in Flow tokens that is required to pay for the transaction\n        access(contract) fun calculateFee(executionEffort: UInt64, priority: Priority, dataSizeMB: UFix64): UFix64 {\n            // Use the official FlowFees calculation\n            let baseFee = FlowFees.computeFees(inclusionEffort: 1.0, executionEffort: UFix64(executionEffort)/100000000.0)\n            \n            // Scale the execution fee by the multiplier for the priority\n            let scaledExecutionFee = baseFee * self.config.priorityFeeMultipliers[priority]!\n\n            // Calculate the FLOW required to pay for storage of the transaction data\n            let storageFee = FlowStorageFees.storageCapacityToFlow(dataSizeMB)\n            \n            return scaledExecutionFee + storageFee\n        }\n\n        /// getNextIDAndIncrement returns the next ID and increments the ID counter\n        access(self) fun getNextIDAndIncrement(): UInt64 {\n            let nextID = self.nextID\n            self.nextID = self.nextID + 1\n            return nextID\n        }\n\n        /// get status of the scheduled transaction\n        /// @param id: The ID of the transaction to get the status of\n        /// @return Status: The status of the transaction, if the transaction is not found Unknown is returned.\n        access(contract) view fun getStatus(id: UInt64): Status? {\n            // if the transaction ID is greater than the next ID, it is not scheduled yet and has never existed\n            if id == 0 as UInt64 || id >= self.nextID {\n                return nil\n            }\n\n            // This should always return Scheduled or Executed\n            if let tx = self.borrowTransaction(id: id) {\n                return tx.status\n            }\n\n            // if the transaction was canceled and it is still not pruned from \n            // list return canceled status\n            if self.canceledTransactions.contains(id) {\n                return Status.Canceled\n            }\n\n            // if transaction ID is after first canceled ID it must be executed \n            // otherwise it would have been canceled and part of this list\n            let firstCanceledID = self.canceledTransactions[0]\n            if id > firstCanceledID {\n                return Status.Executed\n            }\n\n            // the transaction list was pruned and the transaction status might be \n            // either canceled or execute so we return unknown\n            return Status.Unknown\n        }\n\n        /// schedule is the primary entry point for scheduling a new transaction within the scheduler contract. \n        /// If scheduling the transaction is not possible either due to invalid arguments or due to \n        /// unavailable slots, the function panics. \n        //\n        /// The schedule function accepts the following arguments:\n        /// @param: transaction: A capability to a resource in storage that implements the transaction handler \n        ///    interface. This handler will be invoked at execution time and will receive the specified data payload.\n        /// @param: timestamp: Specifies the earliest block timestamp at which the transaction is eligible for execution \n        ///    (Unix timestamp so fractional seconds values are ignored). It must be set in the future.\n        /// @param: priority: An enum value (`High`, `Medium`, or `Low`) that influences the scheduling behavior and determines \n        ///    how soon after the timestamp the transaction will be executed.\n        /// @param: executionEffort: Defines the maximum computational resources allocated to the transaction. This also determines \n        ///    the fee charged. Unused execution effort is not refunded.\n        /// @param: fees: A Vault resource containing sufficient funds to cover the required execution effort.\n        access(contract) fun schedule(\n            handlerCap: Capability<auth(Execute) &{TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): @ScheduledTransaction {\n\n            // Use the estimate function to validate inputs\n            let estimate = self.estimate(\n                data: data,\n                timestamp: timestamp,\n                priority: priority,\n                executionEffort: executionEffort\n            )\n\n            // Estimate returns an error for low priority transactions\n            // so need to check that the error is fine\n            // because low priority transactions are allowed in schedule\n            if estimate.error != nil && estimate.timestamp == nil {\n                panic(estimate.error!)\n            }\n\n            assert (\n                fees.balance >= estimate.flowFee!,\n                message: \"Insufficient fees: The Fee balance of \\(fees.balance) is not sufficient to pay the required amount of \\(estimate.flowFee!) for execution of the transaction.\"\n            )\n\n            let transactionID = self.getNextIDAndIncrement()\n            let transactionData = TransactionData(\n                id: transactionID,\n                handler: handlerCap,\n                scheduledTimestamp: estimate.timestamp!,\n                data: data,\n                priority: priority,\n                executionEffort: executionEffort,\n                fees: fees.balance,\n            )\n\n            // Deposit the fees to the service account's vault\n            FlowTransactionScheduler.depositFees(from: <-fees)\n\n            let handlerRef = handlerCap.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n\n            let handlerPublicPath = handlerRef.resolveView(Type<PublicPath>()) as? PublicPath\n\n            emit Scheduled(\n                id: transactionData.id,\n                priority: transactionData.priority.rawValue,\n                timestamp: transactionData.scheduledTimestamp,\n                executionEffort: transactionData.executionEffort,\n                fees: transactionData.fees,\n                transactionHandlerOwner: transactionData.handler.address,\n                transactionHandlerTypeIdentifier: transactionData.handlerTypeIdentifier,\n                transactionHandlerUUID: handlerRef.uuid,\n                transactionHandlerPublicPath: handlerPublicPath\n            )\n\n            // Add the transaction to the slot queue and update the internal state\n            self.addTransaction(slot: estimate.timestamp!, txData: transactionData)\n            \n            return <-create ScheduledTransaction(\n                id: transactionID, \n                timestamp: estimate.timestamp!,\n                handlerTypeIdentifier: transactionData.handlerTypeIdentifier\n            )\n        }\n\n        /// The estimate function calculates the required fee in Flow and expected execution timestamp for \n        /// a transaction based on the requested timestamp, priority, and execution effort. \n        //\n        /// If the provided arguments are invalid or the transaction cannot be scheduled (e.g., due to \n        /// insufficient computation effort or unavailable time slots) the estimate function\n        /// returns an EstimatedScheduledTransaction struct with a non-nil error message.\n        ///        \n        /// This helps developers ensure sufficient funding and preview the expected scheduling window, \n        /// reducing the risk of unnecessary cancellations.\n        ///\n        /// @param data: The data that was passed when the transaction was originally scheduled\n        /// @param timestamp: The requested timestamp for the transaction\n        /// @param priority: The priority of the transaction\n        /// @param executionEffort: The execution effort of the transaction\n        /// @return EstimatedScheduledTransaction: A struct containing the estimated fee, timestamp, and error message\n        access(contract) fun estimate(\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: Priority,\n            executionEffort: UInt64\n        ): EstimatedScheduledTransaction {\n            // Remove fractional values from the timestamp\n            let sanitizedTimestamp = UFix64(UInt64(timestamp))\n\n            if sanitizedTimestamp <= getCurrentBlock().timestamp {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid timestamp: \\(sanitizedTimestamp) is in the past, current timestamp: \\(getCurrentBlock().timestamp)\"\n                        )\n            }\n\n            if executionEffort > self.config.maximumIndividualEffort {\n                return EstimatedScheduledTransaction(\n                    flowFee: nil,\n                    timestamp: nil,\n                    error: \"Invalid execution effort: \\(executionEffort) is greater than the maximum transaction effort of \\(self.config.maximumIndividualEffort)\"\n                )\n            }\n\n            if executionEffort > self.config.priorityEffortLimit[priority]! {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is greater than the priority's max effort of \\(self.config.priorityEffortLimit[priority]!)\"\n                        )\n            }\n\n            if executionEffort < self.config.minimumExecutionEffort {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is less than the minimum execution effort of \\(self.config.minimumExecutionEffort)\"\n                        )\n            }\n\n            let dataSizeMB = FlowTransactionScheduler.getSizeOfData(data)\n            if dataSizeMB > self.config.maxDataSizeMB {\n                return EstimatedScheduledTransaction(\n                    flowFee: nil,\n                    timestamp: nil,\n                    error: \"Invalid data size: \\(dataSizeMB) is greater than the maximum data size of \\(self.config.maxDataSizeMB)MB\"\n                )\n            }\n\n            let fee = self.calculateFee(executionEffort: executionEffort, priority: priority, dataSizeMB: dataSizeMB)\n\n            let scheduledTimestamp = self.calculateScheduledTimestamp(\n                timestamp: sanitizedTimestamp, \n                priority: priority, \n                executionEffort: executionEffort\n            )\n\n            if scheduledTimestamp == nil {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is greater than the priority's available effort for the requested timestamp.\"\n                        )\n            }\n\n            if priority == Priority.Low {\n                return EstimatedScheduledTransaction(\n                            flowFee: fee,\n                            timestamp: scheduledTimestamp,\n                            error: \"Invalid Priority: Cannot estimate for Low Priority transactions. They will be included in the first block with available space after their requested timestamp.\"\n                        )\n            }\n\n            return EstimatedScheduledTransaction(flowFee: fee, timestamp: scheduledTimestamp, error: nil)\n        }\n\n        /// calculateScheduledTimestamp calculates the timestamp at which a transaction \n        /// can be scheduled. It takes into account the priority of the transaction and \n        /// the execution effort.\n        /// - If the transaction is high priority, it returns the timestamp if there is enough \n        ///    space or nil if there is no space left.\n        /// - If the transaction is medium or low priority and there is space left in the requested timestamp,\n        ///   it returns the requested timestamp. If there is not enough space, it finds the next timestamp with space.\n        ///\n        /// @param timestamp: The requested timestamp for the transaction\n        /// @param priority: The priority of the transaction\n        /// @param executionEffort: The execution effort of the transaction\n        /// @return UFix64?: The timestamp at which the transaction can be scheduled, or nil if there is no space left for a high priority transaction\n        access(contract) view fun calculateScheduledTimestamp(\n            timestamp: UFix64, \n            priority: Priority, \n            executionEffort: UInt64\n        ): UFix64? {\n\n            let used = self.slotUsedEffort[timestamp]\n            // if nothing is scheduled at this timestamp, we can schedule at provided timestamp\n            if used == nil { \n                return timestamp\n            }\n            \n            let available = self.getSlotAvailableEffort(timestamp: timestamp, priority: priority)\n            // if theres enough space, we can tentatively schedule at provided timestamp\n            if executionEffort <= available {\n                return timestamp\n            }\n            \n            if priority == Priority.High {\n                // high priority demands scheduling at exact timestamp or failing\n                return nil\n            }\n\n            // if there is no space left for medium or low priority we search for next available timestamp\n            // todo: check how big the callstack can grow and if we should avoid recursion\n            // todo: we should refactor this into loops, because we could need to recurse 100s of times\n            return self.calculateScheduledTimestamp(\n                timestamp: timestamp + 1.0, \n                priority: priority, \n                executionEffort: executionEffort\n            )\n        }\n\n        /// slot available effort returns the amount of effort that is available for a given timestamp and priority.\n        access(contract) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n\n            // Remove fractional values from the timestamp\n            let sanitizedTimestamp = UFix64(UInt64(timestamp))\n\n            // Get the theoretical maximum allowed for the priority including shared\n            let priorityLimit = self.config.priorityEffortLimit[priority]!\n            \n            // If nothing has been claimed for the requested timestamp,\n            // return the full amount\n            if !self.slotUsedEffort.containsKey(sanitizedTimestamp) {\n                return priorityLimit\n            }\n\n            // Get the mapping of how much effort has been used\n            // for each priority for the timestamp\n            let slotPriorityEffortsUsed = self.slotUsedEffort[sanitizedTimestamp]!\n\n            // Get the exclusive reserves for each priority\n            let highReserve = self.config.priorityEffortReserve[Priority.High]!\n            let mediumReserve = self.config.priorityEffortReserve[Priority.Medium]!\n\n            // Get how much effort has been used for each priority\n            let highUsed = slotPriorityEffortsUsed[Priority.High] ?? 0\n            let mediumUsed = slotPriorityEffortsUsed[Priority.Medium] ?? 0\n\n            // If it is low priority, return whatever effort is remaining\n            // under the low priority effort limit, subtracting the currently used effort for low priority\n            if priority == Priority.Low {\n                let highPlusMediumUsed = highUsed + mediumUsed\n                let totalEffortRemaining = self.config.slotTotalEffortLimit.saturatingSubtract(highPlusMediumUsed)\n                let lowEffortRemaining = totalEffortRemaining < priorityLimit ? totalEffortRemaining : priorityLimit\n                let lowUsed = slotPriorityEffortsUsed[Priority.Low] ?? 0\n                return lowEffortRemaining.saturatingSubtract(lowUsed)\n            }\n            \n            // Get how much shared effort has been used for each priority\n            // Ensure the results are always zero or positive\n            let highSharedUsed: UInt64 = highUsed.saturatingSubtract(highReserve)\n            let mediumSharedUsed: UInt64 = mediumUsed.saturatingSubtract(mediumReserve)\n\n            // Get the theoretical total shared amount between priorities\n            let totalShared = (self.config.slotTotalEffortLimit.saturatingSubtract(highReserve)).saturatingSubtract(mediumReserve)\n\n            // Get the amount of shared effort currently available\n            let highPlusMediumSharedUsed = highSharedUsed + mediumSharedUsed\n            // prevent underflow\n            let sharedAvailable = totalShared.saturatingSubtract(highPlusMediumSharedUsed)\n\n            // we calculate available by calculating available shared effort and \n            // adding any unused reserves for that priority\n            let reserve = self.config.priorityEffortReserve[priority]!\n            let used = slotPriorityEffortsUsed[priority] ?? 0\n            let unusedReserve: UInt64 = reserve.saturatingSubtract(used)\n            let available = sharedAvailable + unusedReserve\n            \n            return available\n        }\n\n         /// add transaction to the queue and updates all the internal state as well as emit an event\n        access(self) fun addTransaction(slot: UFix64, txData: TransactionData) {\n\n            // If nothing is in the queue for this slot, initialize the slot\n            if self.slotQueue[slot] == nil {\n                self.slotQueue[slot] = {}\n\n                // This also means that the used effort record for this slot has not been initialized\n                self.slotUsedEffort[slot] = {\n                    Priority.High: 0,\n                    Priority.Medium: 0,\n                    Priority.Low: 0\n                }\n\n                self.sortedTimestamps.add(timestamp: slot)\n            }\n\n            // Add this transaction id to the slot\n            let slotQueue = self.slotQueue[slot]!\n            if let priorityQueue = slotQueue[txData.priority] {\n                priorityQueue[txData.id] = txData.executionEffort\n                slotQueue[txData.priority] = priorityQueue\n            } else {\n                slotQueue[txData.priority] = {\n                    txData.id: txData.executionEffort\n                }\n            }\n\n            self.slotQueue[slot] = slotQueue\n\n            // Add the execution effort for this transaction to the total for the slot's priority\n            let slotEfforts = self.slotUsedEffort[slot]!\n            var newPriorityEffort = slotEfforts[txData.priority]! + txData.executionEffort\n            slotEfforts[txData.priority] = newPriorityEffort\n            var newTotalEffort: UInt64 = 0\n            for priority in slotEfforts.keys {\n                newTotalEffort = newTotalEffort.saturatingAdd(slotEfforts[priority]!)\n            }\n            self.slotUsedEffort[slot] = slotEfforts\n            \n            // Need to potentially reschedule low priority transactions to make room for the new transaction\n            // Iterate through them and record which ones to reschedule until the total effort is less than the limit\n            let lowTransactionsToReschedule: [UInt64] = []\n            if newTotalEffort > self.config.slotTotalEffortLimit {\n                let lowPriorityTransactions = slotQueue[Priority.Low]!\n                for id in lowPriorityTransactions.keys {\n                    if newTotalEffort <= self.config.slotTotalEffortLimit {\n                        break\n                    }\n                    lowTransactionsToReschedule.append(id)\n                    newTotalEffort = newTotalEffort.saturatingSubtract(lowPriorityTransactions[id]!)\n                }\n            }\n\n            // Store the transaction in the transactions map\n            self.transactions[txData.id] = txData\n\n            // Reschedule low priority transactions if needed\n            self.rescheduleLowPriorityTransactions(slot: slot, transactions: lowTransactionsToReschedule)\n        }\n\n        /// rescheduleLowPriorityTransactions reschedules low priority transactions to make room for a new transaction\n        /// @param slot: The slot that the transactions are currently scheduled at\n        /// @param transactions: The transactions to reschedule\n        access(self) fun rescheduleLowPriorityTransactions(slot: UFix64, transactions: [UInt64]) {\n            for id in transactions {\n                let tx = self.borrowTransaction(id: id)\n                if tx == nil {\n                    emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while rescheduling low priority transactions\")\n                    continue\n                }\n\n                if tx!.priority != Priority.Low {\n                    emit CriticalIssue(message: \"Invalid Priority: Cannot reschedule transaction with id \\(id) because it is not low priority\")\n                    continue\n                }\n                \n                if tx!.scheduledTimestamp != slot {\n                    emit CriticalIssue(message: \"Invalid Timestamp: Cannot reschedule transaction with id \\(id) because it is not scheduled at the same slot as the new transaction\")\n                    continue\n                }\n\n                let newTimestamp = self.calculateScheduledTimestamp(\n                    timestamp: slot + 1.0,\n                    priority: Priority.Low,\n                    executionEffort: tx!.executionEffort\n                )!\n\n                let effort = tx!.executionEffort\n                let transactionData = self.removeTransaction(txData: tx!)\n\n                // Subtract the execution effort for this transaction from the slot's priority\n                let slotEfforts = self.slotUsedEffort[slot]!\n                slotEfforts[Priority.Low] = slotEfforts[Priority.Low]!.saturatingSubtract(effort)\n                self.slotUsedEffort[slot] = slotEfforts\n\n                // Update the transaction's scheduled timestamp and add it back to the slot queue\n                transactionData.setScheduledTimestamp(newTimestamp: newTimestamp)\n                self.addTransaction(slot: newTimestamp, txData: transactionData)\n            }\n        }\n\n        /// remove the transaction from the slot queue.\n        access(self) fun removeTransaction(txData: &TransactionData): TransactionData {\n\n            let transactionID = txData.id\n            let slot = txData.scheduledTimestamp\n            let transactionPriority = txData.priority\n\n            // remove transaction object\n            let transactionObject = self.transactions.remove(key: transactionID)!\n            \n            // garbage collect slots \n            if let transactionQueue = self.slotQueue[slot] {\n\n                if let priorityQueue = transactionQueue[transactionPriority] {\n                    priorityQueue[transactionID] = nil\n                    if priorityQueue.keys.length == 0 {\n                        transactionQueue.remove(key: transactionPriority)\n                    } else {\n                        transactionQueue[transactionPriority] = priorityQueue\n                    }\n\n                    self.slotQueue[slot] = transactionQueue\n                }\n\n                // if the slot is now empty remove it from the maps\n                if transactionQueue.keys.length == 0 {\n                    self.slotQueue.remove(key: slot)\n                    self.slotUsedEffort.remove(key: slot)\n\n                    self.sortedTimestamps.remove(timestamp: slot)\n                }\n            }\n\n            return transactionObject\n        }\n\n        /// pendingQueue creates a list of transactions that are ready for execution.\n        /// For transaction to be ready for execution it must be scheduled.\n        ///\n        /// The queue is sorted by timestamp and then by priority (high, medium, low).\n        /// The queue will contain transactions from all timestamps that are in the past.\n        /// Low priority transactions will only be added if there is effort available in the slot.  \n        /// The return value can be empty if there are no transactions ready for execution.\n        access(Process) fun pendingQueue(): [&TransactionData] {\n            let currentTimestamp = getCurrentBlock().timestamp\n            var pendingTransactions: [&TransactionData] = []\n\n            // total effort across different timestamps guards collection being over the effort limit\n            var collectionAvailableEffort = self.config.collectionEffortLimit\n            var transactionsAvailableCount = self.config.collectionTransactionsLimit\n\n            // Collect past timestamps efficiently from sorted array\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n\n            for timestamp in pastTimestamps {\n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                var high: [&TransactionData] = []\n                var medium: [&TransactionData] = []\n                var low: [&TransactionData] = []\n\n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    for id in transactionIDs.keys {\n                        let tx = self.borrowTransaction(id: id)\n                        if tx == nil {\n                            emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while preparing pending queue\")\n                            continue\n                        }\n                        \n                        // Only add scheduled transactions to the queue\n                        if tx!.status != Status.Scheduled {\n                            continue\n                        }\n\n                        // this is safeguard to prevent collection growing too large in case of block production slowdown\n                        if tx!.executionEffort >= collectionAvailableEffort || transactionsAvailableCount == 0 {\n                            emit CollectionLimitReached(\n                                collectionEffortLimit: transactionsAvailableCount == 0 ? nil : self.config.collectionEffortLimit,\n                                collectionTransactionsLimit: transactionsAvailableCount == 0 ? self.config.collectionTransactionsLimit : nil\n                            )\n                            break\n                        }\n\n                        collectionAvailableEffort = collectionAvailableEffort.saturatingSubtract(tx!.executionEffort)\n                        transactionsAvailableCount = transactionsAvailableCount - 1\n                    \n                        switch tx!.priority {\n                            case Priority.High:\n                                high.append(tx!)\n                            case Priority.Medium:\n                                medium.append(tx!)\n                            case Priority.Low:\n                                low.append(tx!)\n                        }\n                    }\n                }\n\n                pendingTransactions = pendingTransactions\n                    .concat(high)\n                    .concat(medium)\n                    .concat(low)\n            }\n\n            return pendingTransactions\n        }\n\n        /// removeExecutedTransactions removes all transactions that are marked as executed.\n        access(self) fun removeExecutedTransactions(_ currentTimestamp: UFix64) {\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n            var numRemoved = 0\n            let removalLimit = self.config.getTxRemovalLimit()\n\n            for timestamp in pastTimestamps {\n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                \n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    for id in transactionIDs.keys {\n\n                        numRemoved = numRemoved + 1\n\n                        if UInt(numRemoved) >= removalLimit {\n                            emit RemovalLimitReached()\n                            return\n                        }\n\n                        let tx = self.borrowTransaction(id: id)\n                        if tx == nil {\n                            emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while removing executed transactions\")\n                            continue\n                        }\n\n                        // Only remove executed transactions\n                        if tx!.status != Status.Executed {\n                            continue\n                        }\n\n                        // charge the full fee for transaction execution\n                        destroy tx!.payAndRefundFees(refundMultiplier: 0.0)\n\n                        self.removeTransaction(txData: tx!)\n                    }\n                }\n            }\n        }\n\n        /// process scheduled transactions and prepare them for execution. \n        ///\n        /// First, it removes transactions that have already been executed. \n        /// Then, it iterates over past timestamps in the queue and processes the transactions that are \n        /// eligible for execution. It also emits an event for each transaction that is processed.\n        ///\n        /// This function is only called by the FVM to process transactions.\n        access(Process) fun process() {\n            let currentTimestamp = getCurrentBlock().timestamp\n            // Early exit if no timestamps need processing\n            if !self.sortedTimestamps.hasBefore(current: currentTimestamp) {\n                return\n            }\n\n            self.removeExecutedTransactions(currentTimestamp)\n\n            let pendingTransactions = self.pendingQueue()\n\n            for tx in pendingTransactions {\n                // Only emit the pending execution event if the transaction handler capability is borrowable\n                // This is to prevent a situation where the transaction handler is not available\n                // In that case, the transaction is no longer valid because it cannot be executed\n                if let transactionHandler = tx.handler.borrow() {\n                    emit PendingExecution(\n                        id: tx.id,\n                        priority: tx.priority.rawValue,\n                        executionEffort: tx.executionEffort,\n                        fees: tx.fees,\n                        transactionHandlerOwner: tx.handler.address,\n                        transactionHandlerTypeIdentifier: transactionHandler.getType().identifier\n                    )\n                }\n\n                // after pending execution event is emitted we set the transaction as executed because we \n                // must rely on execution node to actually execute it. Execution of the transaction is \n                // done in a separate transaction that calls executeTransaction(id) function.\n                // Executing the transaction can not update the status of transaction or any other shared state,\n                // since that blocks concurrent transaction execution.\n                // Therefore an optimistic update to executed is made here to avoid race condition.\n                tx.setStatus(newStatus: Status.Executed)\n            }\n        }\n\n        /// cancel a scheduled transaction and return a portion of the fees that were paid.\n        ///\n        /// @param id: The ID of the transaction to cancel\n        /// @return: The fees to be returned to the caller\n        access(Cancel) fun cancel(id: UInt64): @FlowToken.Vault {\n            let tx = self.borrowTransaction(id: id) ?? \n                panic(\"Invalid ID: \\(id) transaction not found\")\n\n            assert(\n                tx.status == Status.Scheduled,\n                message: \"Transaction must be in a scheduled state in order to be canceled\"\n            )\n            \n            // Subtract the execution effort for this transaction from the slot's priority\n            let slotEfforts = self.slotUsedEffort[tx.scheduledTimestamp]!\n            slotEfforts[tx.priority] = slotEfforts[tx.priority]!.saturatingSubtract(tx.executionEffort)\n            self.slotUsedEffort[tx.scheduledTimestamp] = slotEfforts\n\n            let totalFees = tx.fees\n            let refundedFees <- tx.payAndRefundFees(refundMultiplier: self.config.refundMultiplier)\n\n            // if the transaction was canceled, add it to the canceled transactions array\n            // maintain sorted order by inserting at the correct position\n            var insertIndex = 0\n            for i, canceledID in self.canceledTransactions {\n                if id < canceledID {\n                    insertIndex = i\n                    break\n                }\n                insertIndex = i + 1\n            }\n            self.canceledTransactions.insert(at: insertIndex, id)\n            \n            // keep the array under the limit\n            if UInt(self.canceledTransactions.length) > self.config.canceledTransactionsLimit {\n                self.canceledTransactions.remove(at: 0)\n            }\n\n            emit Canceled(\n                id: tx.id,\n                priority: tx.priority.rawValue,\n                feesReturned: refundedFees.balance,\n                feesDeducted: totalFees - refundedFees.balance,\n                transactionHandlerOwner: tx.handler.address,\n                transactionHandlerTypeIdentifier: tx.handlerTypeIdentifier\n            )\n\n            self.removeTransaction(txData: tx)\n            \n            return <-refundedFees\n        }\n\n        /// execute transaction is a system function that is called by FVM to execute a transaction by ID.\n        /// The transaction must be found and in correct state or the function panics and this is a fatal error\n        ///\n        /// This function is only called by the FVM to execute transactions.\n        /// WARNING: this function should not change any shared state, it will be run concurrently and it must not be blocking.\n        access(Execute) fun executeTransaction(id: UInt64) {\n            let tx = self.borrowTransaction(id: id) ?? \n                panic(\"Invalid ID: Transaction with id \\(id) not found\")\n\n            assert (\n                tx.status == Status.Executed,\n                message: \"Invalid ID: Cannot execute transaction with id \\(id) because it has incorrect status \\(tx.status.rawValue)\"\n            )\n\n            let transactionHandler = tx.handler.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n\n            let handlerPublicPath = transactionHandler.resolveView(Type<PublicPath>()) as? PublicPath\n\n            emit Executed(\n                id: tx.id,\n                priority: tx.priority.rawValue,\n                executionEffort: tx.executionEffort,\n                transactionHandlerOwner: tx.handler.address,\n                transactionHandlerTypeIdentifier: transactionHandler.getType().identifier,\n                transactionHandlerUUID: transactionHandler.uuid,\n                transactionHandlerPublicPath: handlerPublicPath\n\n            )\n            \n            transactionHandler.executeTransaction(id: id, data: tx.getData())\n        }\n    }\n    \n    /// Deposit fees to this contract's account's vault\n    access(contract) fun depositFees(from: @FlowToken.Vault) {\n        let vaultRef = self.account.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n        vaultRef.deposit(from: <-from)\n    }\n\n    /// Withdraw fees from this contract's account's vault\n    access(contract) fun withdrawFees(amount: UFix64): @FlowToken.Vault {\n        let vaultRef = self.account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n            \n        return <-vaultRef.withdraw(amount: amount) as! @FlowToken.Vault\n    }\n\n    access(all) fun schedule(\n        handlerCap: Capability<auth(Execute) &{TransactionHandler}>,\n        data: AnyStruct?,\n        timestamp: UFix64,\n        priority: Priority,\n        executionEffort: UInt64,\n        fees: @FlowToken.Vault\n    ): @ScheduledTransaction {\n        return <-self.sharedScheduler.borrow()!.schedule(\n            handlerCap: handlerCap, \n            data: data, \n            timestamp: timestamp, \n            priority: priority, \n            executionEffort: executionEffort, \n            fees: <-fees\n        )\n    }\n\n    access(all) fun estimate(\n        data: AnyStruct?,\n        timestamp: UFix64,\n        priority: Priority,\n        executionEffort: UInt64\n    ): EstimatedScheduledTransaction {\n        return self.sharedScheduler.borrow()!\n            .estimate(\n                data: data, \n                timestamp: timestamp, \n                priority: priority, \n                executionEffort: executionEffort,\n            )\n    }\n\n    access(all) fun cancel(scheduledTx: @ScheduledTransaction): @FlowToken.Vault {\n        let id = scheduledTx.id\n        destroy scheduledTx\n        return <-self.sharedScheduler.borrow()!.cancel(id: id)\n    }\n\n    /// getTransactionData returns the transaction data for a given ID\n    /// This function can only get the data for a transaction that is currently scheduled or pending execution\n    /// because finalized transaction metadata is not stored in the contract\n    /// @param id: The ID of the transaction to get the data for\n    /// @return: The transaction data for the given ID\n    access(all) view fun getTransactionData(id: UInt64): TransactionData? {\n        return self.sharedScheduler.borrow()!.getTransaction(id: id)\n    }\n\n    /// borrowHandlerForID returns an un-entitled reference to the transaction handler for a given ID\n    /// The handler reference can be used to resolve views to get info about the handler and see where it is stored\n    /// @param id: The ID of the transaction to get the handler for\n    /// @return: An un-entitled reference to the transaction handler for the given ID\n    access(all) view fun borrowHandlerForID(_ id: UInt64): &{TransactionHandler}? {\n        return self.getTransactionData(id: id)?.borrowHandler()\n    }\n\n    /// getCanceledTransactions returns the IDs of the transactions that have been canceled\n    /// @return: The IDs of the transactions that have been canceled\n    access(all) view fun getCanceledTransactions(): [UInt64] {\n        return self.sharedScheduler.borrow()!.getCanceledTransactions()\n    }\n\n\n    access(all) view fun getStatus(id: UInt64): Status? {\n        return self.sharedScheduler.borrow()!.getStatus(id: id)\n    }\n\n    /// getTransactionsForTimeframe returns the IDs of the transactions that are scheduled for a given timeframe\n    /// @param startTimestamp: The start timestamp to get the IDs for\n    /// @param endTimestamp: The end timestamp to get the IDs for\n    /// @return: The IDs of the transactions that are scheduled for the given timeframe\n    access(all) fun getTransactionsForTimeframe(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: {UInt8: [UInt64]}} {\n        return self.sharedScheduler.borrow()!.getTransactionsForTimeframe(startTimestamp: startTimestamp, endTimestamp: endTimestamp)\n    }\n\n    access(all) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n        return self.sharedScheduler.borrow()!.getSlotAvailableEffort(timestamp: timestamp, priority: priority)\n    }\n\n    access(all) fun getConfig(): {SchedulerConfig} {\n        return self.sharedScheduler.borrow()!.getConfig()\n    }\n    \n    /// getSizeOfData takes a transaction's data\n    /// argument and stores it in the contract account's storage, \n    /// checking storage used before and after to see how large the data is in MB\n    /// If data is nil, the function returns 0.0\n    access(all) fun getSizeOfData(_ data: AnyStruct?): UFix64 {\n        if data == nil {\n            return 0.0\n        } else {\n            let type = data!.getType()\n            if type.isSubtype(of: Type<Number>()) \n            || type.isSubtype(of: Type<Bool>()) \n            || type.isSubtype(of: Type<Address>())\n            || type.isSubtype(of: Type<Character>())\n            || type.isSubtype(of: Type<Capability>())\n            {\n                return 0.0\n            }\n        }\n        let storagePath = /storage/dataTemp\n        let storageUsedBefore = self.account.storage.used\n        self.account.storage.save(data!, to: storagePath)\n        let storageUsedAfter = self.account.storage.used\n        self.account.storage.load<AnyStruct>(from: storagePath)\n\n        return FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(storageUsedAfter.saturatingSubtract(storageUsedBefore))\n    }\n\n    access(all) init() {\n        self.storagePath = /storage/sharedScheduler\n        let scheduler <- create SharedScheduler()\n        let oldScheduler <- self.account.storage.load<@AnyResource>(from: self.storagePath)\n        destroy oldScheduler\n        self.account.storage.save(<-scheduler, to: self.storagePath)\n        \n        self.sharedScheduler = self.account.capabilities.storage\n            .issue<auth(Cancel) &SharedScheduler>(self.storagePath)\n    }\n}",
      "valid_from": 131028293,
      "valid_to": 138786557,
      "created_at": "2025-10-29T15:08:19.511Z",
      "deployments": 3,
      "imported_by": [
        "A.17ae3b1b0b0d50db.DCATransactionHandler",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV2",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV3",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV4",
        "A.262cf58c0b9fbcff.PrizeVaultScheduler",
        "A.28eab429d0e72f0d.Counter",
        "A.28eab429d0e72f0d.Counter2",
        "A.28eab429d0e72f0d.Counter3",
        "A.28eab429d0e72f0d.Counter4",
        "A.28eab429d0e72f0d.Counter5",
        "A.4414755a2180da53.DAO",
        "A.651079a7b572ef10.PaymentCronTransactionHandler",
        "A.6a3c3dad7074bca5.PrizeVaultScheduler",
        "A.6d888f175c158410.DeFiActions",
        "A.6dec6e64a13b881e.FlowCron",
        "A.7d19efcd8e5b4a4a.TestFlowCallbackHandler",
        "A.a092c4aab33daeda.PrizeVaultScheduler",
        "A.aa56464d998070e8.OracleArbHandler",
        "A.b13b21a06b75536d.SwapKeepAliveHandler",
        "A.b13b21a06b75536d.SwapKeepAliveHandlerV2",
        "A.b1d63873c3cc9f79.FlowVaultsAutoBalancers",
        "A.b1d63873c3cc9f79.FlowYieldVaultsAutoBalancers",
        "A.b1d63873c3cc9f79.FlowYieldVaultsScheduler",
        "A.b1d63873c3cc9f79.FlowYieldVaultsSchedulerRegistry",
        "A.b1d63873c3cc9f79.FlowYieldVaultsSchedulerV1",
        "A.b1d63873c3cc9f79.FlowYieldVaultsStrategies",
        "A.b1d63873c3cc9f79.FlowYieldVaultsStrategiesV1_1",
        "A.b1d63873c3cc9f79.PMStrategies",
        "A.b1d63873c3cc9f79.PMStrategiesV1",
        "A.b2b7a4c7033eaa24.PrizeVaultScheduler",
        "A.b9973a32e6c52813.OracleArbHandler",
        "A.b9973a32e6c52813.RebalanceHandler",
        "A.ca7ee55e4fc3251a.CounterTransactionHandler",
        "A.ca7ee55e4fc3251a.DCAHandlerEVM",
        "A.ca7ee55e4fc3251a.DCAHandlerEVMV2",
        "A.ca7ee55e4fc3251a.DCAHandlerEVMV3",
        "A.ca7ee55e4fc3251a.DCAHandlerEVMV4",
        "A.ca7ee55e4fc3251a.DCATestHandler",
        "A.ca7ee55e4fc3251a.DCATransactionHandler",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMLoop",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMMinimal",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMSimple",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerMinimal",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerUnified",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerUnifiedSimple",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV2",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV2Loop",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV2Simple",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV3",
        "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils"
      ],
      "imported_count": 50,
      "import_count": 5,
      "tags": null
    },
    {
      "name": "FlowTransactionSchedulerUtils",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": null,
      "id": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils/130192622",
      "identifier": "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils",
      "transaction_hash": "f1a9a2ed605911077c823ae5d779c6d3e5b320a4c5fa24cceff3797af056b703",
      "status": "ok",
      "diff": "",
      "body": "import FlowTransactionScheduler from 0xe467b9dd11fa00df\nimport FlowToken from 0x1654653399040a61\n\n/// FlowTransactionSchedulerUtils provides utility functionality for working with scheduled transactions\n/// on the Flow blockchain. Currently, it only includes a Manager resource for managing scheduled transactions.\n///\n/// In the future, this contract will be updated to include more functionality \n/// to make it more convenient for working with scheduled transactions for various use cases.\n///\naccess(all) contract FlowTransactionSchedulerUtils {\n\n    /// Storage path for Manager resources\n    access(all) let managerStoragePath: StoragePath\n\n    /// Public path for Manager resources\n    access(all) let managerPublicPath: PublicPath\n\n    /// Entitlements\n    access(all) entitlement Owner\n\n    /// HandlerInfo is a struct that stores information about a single transaction handler\n    /// that has been used to schedule transactions.\n    /// It is stored in the manager's handlerInfos dictionary.\n    /// It stores the type identifier of the handler, the transaction IDs that have been scheduled for it,\n    /// and a capability to the handler.\n    /// The capability is used to borrow a reference to the handler when needed.\n    /// The transaction IDs are used to track the transactions that have been scheduled for the handler.\n    /// The type identifier is used to differentiate between handlers of the same type.\n    access(all) struct HandlerInfo {\n        /// The type identifier of the handler\n        access(all) let typeIdentifier: String\n\n        /// The transaction IDs that have been scheduled for the handler\n        access(all) let transactionIDs: [UInt64]\n\n        /// The capability to the handler\n        access(contract) let capability: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>\n\n        init(typeIdentifier: String, capability: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>) {\n            self.typeIdentifier = typeIdentifier\n            self.capability = capability\n            self.transactionIDs = []\n        }\n\n        /// Add a transaction ID to the handler's transaction IDs\n        /// @param id: The ID of the transaction to add\n        access(contract) fun addTransactionID(id: UInt64) {\n            self.transactionIDs.append(id)\n        }\n\n        /// Remove a transaction ID from the handler's transaction IDs\n        /// @param id: The ID of the transaction to remove\n        access(contract) fun removeTransactionID(id: UInt64) {\n            let index = self.transactionIDs.firstIndex(of: id)\n            if index != nil {\n                self.transactionIDs.remove(at: index!)\n            }\n        }\n\n        /// Borrow an un-entitled reference to the handler\n        /// @return: A reference to the handler, or nil if not found\n        access(contract) view fun borrow(): &{FlowTransactionScheduler.TransactionHandler}? {\n            return self.capability.borrow() as? &{FlowTransactionScheduler.TransactionHandler}\n        }\n    }\n\n    /// The Manager resource offers a convenient way for users and developers to\n    /// group, schedule, cancel, and query scheduled transactions through a single resource.\n    /// The Manager is defined as an interface to allow for multiple implementations of the manager\n    /// and to support upgrades that may be needed in the future to add additional storage fields and functionality.\n    /// \n    /// Key features:\n    /// - Organizes scheduled and executed transactions by handler type and timestamp\n    /// - Simplified scheduling interface that works with previously used transaction handlers\n    /// - Transaction tracking and querying capabilities by handler, timestamp, and ID\n    /// - Handler metadata and view resolution support\n    access(all) resource interface Manager {\n\n        /// Schedules a transaction by passing the arguments directly\n        /// to the FlowTransactionScheduler schedule function\n        /// This also should store the information about the transaction\n        /// and handler in the manager's fields\n        access(Owner) fun schedule(\n            handlerCap: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64\n\n        /// Schedules a transaction that uses a previously used handler\n        /// This should also store the information about the transaction\n        /// and handler in the manager's fields\n        access(Owner) fun scheduleByHandler(\n            handlerTypeIdentifier: String,\n            handlerUUID: UInt64?,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64\n\n        /// Cancels a scheduled transaction by its ID\n        /// This should also remove the information about the transaction from the manager's fields\n        access(Owner) fun cancel(id: UInt64): @FlowToken.Vault\n        \n        access(all) view fun getTransactionData(_ id: UInt64): FlowTransactionScheduler.TransactionData?\n        access(all) view fun borrowTransactionHandlerForID(_ id: UInt64): &{FlowTransactionScheduler.TransactionHandler}?\n        access(all) fun getHandlerTypeIdentifiers(): {String: [UInt64]}\n        access(all) view fun borrowHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): &{FlowTransactionScheduler.TransactionHandler}?\n        access(all) fun getHandlerViews(handlerTypeIdentifier: String, handlerUUID: UInt64?): [Type] \n        access(all) fun resolveHandlerView(handlerTypeIdentifier: String, handlerUUID: UInt64?, viewType: Type): AnyStruct?      \n        access(all) fun getHandlerViewsFromTransactionID(_ id: UInt64): [Type]\n        access(all) fun resolveHandlerViewFromTransactionID(_ id: UInt64, viewType: Type): AnyStruct? \n        access(all) view fun getTransactionIDs(): [UInt64]\n        access(all) view fun getTransactionIDsByHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): [UInt64]\n        access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64]\n        access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]}\n        access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status?\n    }\n\n    /// Manager resource is meant to provide users and developers with a simple way\n    /// to group the scheduled transactions that they own into one place to make it more\n    /// convenient to schedule/cancel transactions and get information about the transactions\n    /// that are managed.\n    /// It stores ScheduledTransaction resources in a dictionary and has other fields\n    /// to track the scheduled transactions by timestamp and handler\n    ///\n    access(all) resource ManagerV1: Manager {\n        /// Dictionary storing scheduled transactions by their ID\n        access(self) var scheduledTransactions: @{UInt64: FlowTransactionScheduler.ScheduledTransaction}\n\n        /// Sorted array of timestamps that this manager has transactions scheduled at\n        access(self) var sortedTimestamps: FlowTransactionScheduler.SortedTimestamps\n\n        /// Dictionary storing the IDs of the transactions scheduled at a given timestamp\n        access(self) let idsByTimestamp: {UFix64: [UInt64]}\n\n        /// Dictionary storing the handler UUIDs for transaction IDs\n        access(self) let handlerUUIDsByTransactionID: {UInt64: UInt64}\n\n        /// Dictionary storing the handlers that this manager has scheduled transactions for at one point\n        /// The field differentiates between handlers of the same type by their UUID because there can be multiple handlers of the same type\n        /// that perform the same functionality but maybe do it for different purposes\n        /// so it is important to differentiate between them in case the user needs to retrieve a specific handler\n        /// The metadata for each handler that potentially includes information about the handler's purpose\n        /// can be retrieved from the handler's reference via the getViews() and resolveView() functions\n        access(self) let handlerInfos: {String: {UInt64: HandlerInfo}}\n\n        init() {\n            self.scheduledTransactions <- {}\n            self.sortedTimestamps = FlowTransactionScheduler.SortedTimestamps()\n            self.idsByTimestamp = {}\n            self.handlerUUIDsByTransactionID = {}\n            self.handlerInfos = {}\n        }\n\n        /// scheduleByHandler schedules a transaction by a given handler that has been used before\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param data: Optional data to pass to the transaction when executed\n        /// @param timestamp: The timestamp when the transaction should be executed\n        /// @param priority: The priority of the transaction (High, Medium, or Low)\n        /// @param executionEffort: The execution effort for the transaction\n        /// @param fees: A FlowToken vault containing sufficient fees\n        /// @return: The ID of the scheduled transaction\n        access(Owner) fun scheduleByHandler(\n            handlerTypeIdentifier: String,\n            handlerUUID: UInt64?,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64 {\n            pre {\n                self.handlerInfos.containsKey(handlerTypeIdentifier): \"Invalid handler type identifier: Handler with type identifier \\(handlerTypeIdentifier) not found in manager\"\n                handlerUUID == nil || self.handlerInfos[handlerTypeIdentifier]!.containsKey(handlerUUID!): \"Invalid handler UUID: Handler with type identifier \\(handlerTypeIdentifier) and UUID \\(handlerUUID!) not found in manager\"\n            }\n            let handlers = self.handlerInfos[handlerTypeIdentifier]!\n            var id = handlerUUID\n            if handlerUUID == nil {\n                assert (\n                    handlers.keys.length == 1,\n                    message: \"Invalid handler UUID: Handler with type identifier \\(handlerTypeIdentifier) has more than one UUID, but no UUID was provided\"\n                )\n                id = handlers.keys[0]\n            }\n            return self.schedule(handlerCap: handlers[id!]!.capability, data: data, timestamp: timestamp, priority: priority, executionEffort: executionEffort, fees: <-fees)\n        }\n\n        /// Schedule a transaction and store it in the manager's dictionary\n        /// @param handlerCap: A capability to a resource that implements the TransactionHandler interface\n        /// @param data: Optional data to pass to the transaction when executed\n        /// @param timestamp: The timestamp when the transaction should be executed\n        /// @param priority: The priority of the transaction (High, Medium, or Low)\n        /// @param executionEffort: The execution effort for the transaction\n        /// @param fees: A FlowToken vault containing sufficient fees\n        /// @return: The ID of the scheduled transaction\n        access(Owner) fun schedule(\n            handlerCap: Capability<auth(FlowTransactionScheduler.Execute) &{FlowTransactionScheduler.TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: FlowTransactionScheduler.Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): UInt64 {\n            // Clean up any stale transactions before scheduling a new one\n            self.cleanup()\n\n            // Route to the main FlowTransactionScheduler\n            let scheduledTransaction <- FlowTransactionScheduler.schedule(\n                handlerCap: handlerCap,\n                data: data,\n                timestamp: timestamp,\n                priority: priority,\n                executionEffort: executionEffort,\n                fees: <-fees\n            )\n\n            // Store the handler capability in our dictionary for later retrieval\n            let id = scheduledTransaction.id\n            let handlerRef = handlerCap.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n            let handlerTypeIdentifier = handlerRef.getType().identifier\n            let handlerUUID = handlerRef.uuid\n\n            self.handlerUUIDsByTransactionID[id] = handlerUUID\n\n            // Store the handler capability in the handlers dictionary for later retrieval\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if let handlerInfo = handlers[handlerUUID] {\n                    handlerInfo.addTransactionID(id: id)\n                    handlers[handlerUUID] = handlerInfo\n                } else {\n                    let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                    handlerInfo.addTransactionID(id: id)\n                    handlers[handlerUUID] = handlerInfo\n                }\n                self.handlerInfos[handlerTypeIdentifier] = handlers\n            } else {\n                let handlerInfo = HandlerInfo(typeIdentifier: handlerTypeIdentifier, capability: handlerCap)\n                handlerInfo.addTransactionID(id: id)\n                let uuidDictionary: {UInt64: HandlerInfo} = {handlerUUID: handlerInfo}\n                self.handlerInfos[handlerTypeIdentifier] = uuidDictionary\n            }\n\n            // Store the transaction in the transactions dictionary\n            self.scheduledTransactions[scheduledTransaction.id] <-! scheduledTransaction\n\n            // Add the transaction to the sorted timestamps array\n            self.sortedTimestamps.add(timestamp: timestamp)\n\n            // Store the transaction in the ids by timestamp dictionary\n            if let ids = self.idsByTimestamp[timestamp] {\n                ids.append(id)\n                self.idsByTimestamp[timestamp] = ids\n            } else {\n                self.idsByTimestamp[timestamp] = [id]\n            }\n\n            return id\n        }\n\n        /// Cancel a scheduled transaction by its ID\n        /// @param id: The ID of the transaction to cancel\n        /// @return: A FlowToken vault containing the refunded fees\n        access(Owner) fun cancel(id: UInt64): @FlowToken.Vault {\n            // Remove the transaction from the transactions dictionary\n            let tx <- self.scheduledTransactions.remove(key: id)\n                ?? panic(\"Invalid ID: Transaction with ID \\(id) not found in manager\")\n\n            self.removeID(id: id, timestamp: tx.timestamp, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n\n            // Cancel the transaction through the main scheduler\n            let refundedFees <- FlowTransactionScheduler.cancel(scheduledTx: <-tx!)\n\n            return <-refundedFees\n        }\n\n        /// Remove an ID from the manager's fields\n        /// @param id: The ID of the transaction to remove\n        /// @param timestamp: The timestamp of the transaction to remove\n        /// @param handlerTypeIdentifier: The type identifier of the handler of the transaction to remove\n        access(self) fun removeID(id: UInt64, timestamp: UFix64, handlerTypeIdentifier: String) {\n\n            if let ids = self.idsByTimestamp[timestamp] {\n                let index = ids.firstIndex(of: id)\n                ids.remove(at: index!)\n                if ids.length == 0 {\n                    self.idsByTimestamp.remove(key: timestamp)\n                } else {\n                    self.idsByTimestamp[timestamp] = ids\n                }\n            }\n\n            let handlerUUID = self.handlerUUIDsByTransactionID.remove(key: id)\n                ?? panic(\"Invalid ID: Transaction with ID \\(id) not found in manager\")\n\n            // Remove the transaction ID from the handler info array\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if let handlerInfo = handlers[handlerUUID] {\n                    handlerInfo.removeTransactionID(id: id)\n                    handlers[handlerUUID] = handlerInfo\n                }\n                self.handlerInfos[handlerTypeIdentifier] = handlers\n            }\n        }\n\n        /// Clean up transactions that are no longer valid (return nil or Unknown status)\n        /// This removes and destroys transactions that have been executed, canceled, or are otherwise invalid\n        /// @return: The transactions that were cleaned up (removed from the manager)\n        access(Owner) fun cleanup(): [UInt64] {\n            let currentTimestamp = getCurrentBlock().timestamp\n            var transactionsToRemove: [UInt64] = []\n\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n            for timestamp in pastTimestamps {\n                let ids = self.idsByTimestamp[timestamp] ?? []\n                for id in ids {\n                    let status = FlowTransactionScheduler.getStatus(id: id)\n                    if status == nil || status == FlowTransactionScheduler.Status.Unknown {\n                        transactionsToRemove.append(id)\n                    }\n                }\n            }\n\n            // Then remove and destroy the identified transactions\n            for id in transactionsToRemove {\n                if let tx <- self.scheduledTransactions.remove(key: id) {\n                    self.removeID(id: id, timestamp: tx.timestamp, handlerTypeIdentifier: tx.handlerTypeIdentifier)\n                    destroy tx\n                }\n            }\n\n            return transactionsToRemove\n        }\n\n        /// Remove a handler capability from the manager\n        /// The specified handler must not have any transactions scheduled for it\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler\n        access(Owner) fun removeHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?) {\n            // Make sure the handler exists\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                var id = handlerUUID\n                // If no UUID is provided, there must be only one handler of the type\n                if handlerUUID == nil {\n                    if handlers.keys.length > 1 {\n                        // No-op if we don't know which UUID to remove\n                        return\n                    } else if handlers.keys.length == 0 {\n                        self.handlerInfos.remove(key: handlerTypeIdentifier)\n                        return\n                    }\n                    id = handlers.keys[0]\n                }\n                // Make sure the handler has no transactions scheduled for it\n                if let handlerInfo = handlers[id!] {\n                    if handlerInfo.transactionIDs.length > 0 {\n                        return\n                    }\n                }\n                // Remove the handler uuid from the handlers dictionary\n                handlers.remove(key: id!)\n\n                // If there are no more handlers of the type, remove the type from the handlers dictionary\n                if handlers.keys.length == 0 {\n                    self.handlerInfos.remove(key: handlerTypeIdentifier)\n                } else {\n                    self.handlerInfos[handlerTypeIdentifier] = handlers\n                }\n            }\n        }\n\n        /// Get transaction data by its ID\n        /// @param id: The ID of the transaction to retrieve\n        /// @return: The transaction data from FlowTransactionScheduler, or nil if not found\n        access(all) view fun getTransactionData(_ id: UInt64): FlowTransactionScheduler.TransactionData? {\n            if self.scheduledTransactions.containsKey(id) {\n                return FlowTransactionScheduler.getTransactionData(id: id)\n            }\n            return nil\n        }\n\n        /// Get an un-entitled reference to a transaction handler of a given ID\n        /// @param id: The ID of the transaction to retrieve\n        /// @return: A reference to the transaction handler, or nil if not found\n        access(all) view fun borrowTransactionHandlerForID(_ id: UInt64): &{FlowTransactionScheduler.TransactionHandler}? {\n            let txData = self.getTransactionData(id)\n            return txData?.borrowHandler()\n        }\n\n        /// Get all the handler type identifiers that the manager has scheduled transactions for\n        /// @return: A dictionary of all handler type identifiers and their UUIDs\n        access(all) fun getHandlerTypeIdentifiers(): {String: [UInt64]} {\n            var handlerTypeIdentifiers: {String: [UInt64]} = {}\n            for handlerTypeIdentifier in self.handlerInfos.keys {\n                let handlerUUIDs: [UInt64] = []\n                let handlerTypes = self.handlerInfos[handlerTypeIdentifier]!\n                for uuid in handlerTypes.keys {\n                    let handlerInfo = handlerTypes[uuid]!\n                    if !handlerInfo.capability.check() {\n                        continue\n                    }\n                    handlerUUIDs.append(uuid)\n                }\n                handlerTypeIdentifiers[handlerTypeIdentifier] = handlerUUIDs\n            }\n            return handlerTypeIdentifiers\n        }\n\n        /// Get an un-entitled reference to a handler by a given type identifier\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @return: An un-entitled reference to the handler, or nil if not found\n        access(all) view fun borrowHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): &{FlowTransactionScheduler.TransactionHandler}? {\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if handlerUUID != nil {\n                    if let handlerInfo = handlers[handlerUUID!] {\n                        return handlerInfo.borrow()\n                    } \n                } else if handlers.keys.length == 1 {\n                    // If no uuid is provided, we can just default to the only handler uuid\n                    return handlers[handlers.keys[0]]!.borrow()\n                }\n            }\n            return nil\n        }\n\n        /// Get all the views that a handler implements\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @return: An array of all views\n        access(all) fun getHandlerViews(handlerTypeIdentifier: String, handlerUUID: UInt64?): [Type] {\n            if let handler = self.borrowHandler(handlerTypeIdentifier: handlerTypeIdentifier, handlerUUID: handlerUUID) {\n                return handler.getViews()\n            }\n            return []\n        }\n\n        /// Resolve a view for a handler by a given type identifier\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @param handlerUUID: The UUID of the handler, if nil, there must be only one handler of the type, otherwise nil will be returned\n        /// @param viewType: The type of the view to resolve\n        /// @return: The resolved view, or nil if not found\n        access(all) fun resolveHandlerView(handlerTypeIdentifier: String, handlerUUID: UInt64?, viewType: Type): AnyStruct? {\n            if let handler = self.borrowHandler(handlerTypeIdentifier: handlerTypeIdentifier, handlerUUID: handlerUUID) {\n                return handler.resolveView(viewType)\n            }\n            return nil\n        }\n\n        /// Get all the views that a handler implements from a given transaction ID\n        /// @param transactionId: The ID of the transaction\n        /// @return: An array of all views\n        access(all) fun getHandlerViewsFromTransactionID(_ id: UInt64): [Type] {\n            if let handler = self.borrowTransactionHandlerForID(id) {\n                return handler.getViews()\n            }\n            return []\n        }\n\n        /// Resolve a view for a handler from a given transaction ID\n        /// @param transactionId: The ID of the transaction\n        /// @param viewType: The type of the view to resolve\n        /// @return: The resolved view, or nil if not found\n        access(all) fun resolveHandlerViewFromTransactionID(_ id: UInt64, viewType: Type): AnyStruct? {\n            if let handler = self.borrowTransactionHandlerForID(id) {\n                return handler.resolveView(viewType)\n            }\n            return nil\n        }\n\n        /// Get all transaction IDs stored in the manager\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDs(): [UInt64] {\n            return self.scheduledTransactions.keys\n        }\n\n        /// Get all transaction IDs stored in the manager by a given handler\n        /// @param handlerTypeIdentifier: The type identifier of the handler\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDsByHandler(handlerTypeIdentifier: String, handlerUUID: UInt64?): [UInt64] {\n            if let handlers = self.handlerInfos[handlerTypeIdentifier] {\n                if handlerUUID != nil {\n                    if let handlerInfo = handlers[handlerUUID!] {\n                        return handlerInfo.transactionIDs\n                    } \n                } else if handlers.keys.length == 1 {\n                    // If no uuid is provided, we can just default to the only handler uuid\n                    return handlers[handlers.keys[0]]!.transactionIDs\n                }\n            }\n            return []\n        }\n\n        /// Get all transaction IDs stored in the manager by a given timestamp\n        /// @param timestamp: The timestamp\n        /// @return: An array of all transaction IDs\n        access(all) view fun getTransactionIDsByTimestamp(_ timestamp: UFix64): [UInt64] {\n            return self.idsByTimestamp[timestamp] ?? []\n        }\n\n        /// Get all the timestamps and IDs from a given range of timestamps\n        /// @param startTimestamp: The start timestamp\n        /// @param endTimestamp: The end timestamp\n        /// @return: A dictionary of timestamps and IDs\n        access(all) fun getTransactionIDsByTimestampRange(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: [UInt64]} {\n            var transactionsInTimeframe: {UFix64: [UInt64]} = {}\n            \n            // Validate input parameters\n            if startTimestamp > endTimestamp {\n                return transactionsInTimeframe\n            }\n            \n            // Get all timestamps that fall within the specified range\n            let allTimestampsBeforeEnd = self.sortedTimestamps.getBefore(current: endTimestamp)\n            \n            for timestamp in allTimestampsBeforeEnd {\n                // Check if this timestamp falls within our range\n                if timestamp < startTimestamp { continue }\n                \n                var timestampTransactions: [UInt64] = self.idsByTimestamp[timestamp] ?? []\n                \n                if timestampTransactions.length > 0 {\n                    transactionsInTimeframe[timestamp] = timestampTransactions\n                }\n            }\n            \n            return transactionsInTimeframe\n        }\n\n        /// Get the status of a transaction by its ID\n        /// @param id: The ID of the transaction\n        /// @return: The status of the transaction, or Status.Unknown if not found in manager\n        access(all) view fun getTransactionStatus(id: UInt64): FlowTransactionScheduler.Status? {\n            if self.scheduledTransactions.containsKey(id) {\n                return FlowTransactionScheduler.getStatus(id: id)\n            }\n            return FlowTransactionScheduler.Status.Unknown\n        }\n    }\n\n    /// Create a new Manager instance\n    /// @return: A new Manager resource\n    access(all) fun createManager(): @{Manager} {\n        return <-create ManagerV1()\n    }\n\n    access(all) init() {\n        self.managerStoragePath = /storage/flowTransactionSchedulerManager\n        self.managerPublicPath = /public/flowTransactionSchedulerManager\n    }\n\n    /// Get a public reference to a manager at the given address\n    /// @param address: The address of the manager\n    /// @return: A public reference to the manager\n    access(all) view fun borrowManager(at: Address): &{Manager}? {\n        return getAccount(at).capabilities.borrow<&{Manager}>(self.managerPublicPath)\n    }\n\n    /********************************************\n    \n    Scheduled Transactions Metadata Views\n    \n    ***********************************************/\n\n}",
      "valid_from": 130192622,
      "valid_to": 135783128,
      "created_at": "2025-10-21T15:10:09.754715Z",
      "deployments": 3,
      "imported_by": [
        "A.17ae3b1b0b0d50db.DCATransactionHandler",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV2",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV3",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV4",
        "A.254b32edc33e5bc3.aiSportsSwapperTransactionHandler",
        "A.262cf58c0b9fbcff.PrizeVaultScheduler",
        "A.46df6b5eeec6103a.aiSportsSwapperTransactionHandler",
        "A.46df6b5eeec6103a.FastbreakVaultsCloserTransactionHandler",
        "A.651079a7b572ef10.PaymentCronTransactionHandler",
        "A.b13b21a06b75536d.SwapKeepAliveHandler",
        "A.b2b7a4c7033eaa24.PrizeVaultScheduler",
        "A.ca7ee55e4fc3251a.DCAHandlerEVMV2",
        "A.ca7ee55e4fc3251a.DCAHandlerEVMV3",
        "A.ca7ee55e4fc3251a.DCAHandlerEVMV4",
        "A.ca7ee55e4fc3251a.DCATestHandler",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMLoop",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerUnified",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV2",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV2Loop",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV3"
      ],
      "imported_count": 20,
      "import_count": 2,
      "tags": null
    },
    {
      "name": "FlowTransactionScheduler",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": null,
      "id": "A.e467b9dd11fa00df.FlowTransactionScheduler/130192448",
      "identifier": "A.e467b9dd11fa00df.FlowTransactionScheduler",
      "transaction_hash": "2e4c7aedbe40c591023d70264adb927c62c13c45a73d9a1e11d5ef9220d6195b",
      "status": "ok",
      "diff": "",
      "body": "import FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\nimport FlowFees from 0xf919ee77447b7497\nimport FlowStorageFees from 0xe467b9dd11fa00df\nimport ViewResolver from 0x1d7e57aa55817448\n\n/// FlowTransactionScheduler enables smart contracts to schedule autonomous execution in the future.\n///\n/// This contract implements FLIP 330's scheduled transaction system, allowing contracts to \"wake up\" and execute\n/// logic at predefined times without external triggers. \n///\n/// Scheduled transactions are prioritized (High/Medium/Low) with different execution guarantees and fee multipliers: \n///   - High priority guarantees first-block execution,\n///   - Medium priority provides best-effort scheduling,\n///   - Low priority executes opportunistically when capacity allows after the time it was scheduled. \n///\n/// The system uses time slots with execution effort limits to manage network resources,\n/// ensuring predictable performance while enabling novel autonomous blockchain patterns like recurring\n/// payments, automated arbitrage, and time-based contract logic.\naccess(all) contract FlowTransactionScheduler {\n\n    /// singleton instance used to store all scheduled transaction data\n    /// and route all scheduled transaction functionality\n    access(self) var sharedScheduler: Capability<auth(Cancel) &SharedScheduler>\n\n    /// storage path for the singleton scheduler resource\n    access(all) let storagePath: StoragePath\n\n    /// Enums\n\n    /// Priority\n    access(all) enum Priority: UInt8 {\n        access(all) case High\n        access(all) case Medium\n        access(all) case Low\n    }\n\n    /// Status\n    access(all) enum Status: UInt8 {\n        /// unknown statuses are used for handling historic scheduled transactions with null statuses\n        access(all) case Unknown\n        /// mutable status\n        access(all) case Scheduled\n        /// finalized statuses\n        access(all) case Executed\n        access(all) case Canceled\n    }\n\n    /// Events\n\n    /// Emitted when a transaction is scheduled\n    access(all) event Scheduled(\n        id: UInt64,\n        priority: UInt8,\n        timestamp: UFix64,\n        executionEffort: UInt64,\n        fees: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String,\n        transactionHandlerUUID: UInt64,\n        \n        // The public path of the transaction handler that can be used to resolve views\n        // DISCLAIMER: There is no guarantee that the public path is accurate\n        transactionHandlerPublicPath: PublicPath?\n    )\n\n    /// Emitted when a scheduled transaction's scheduled timestamp is reached and it is ready for execution\n    access(all) event PendingExecution(\n        id: UInt64,\n        priority: UInt8,\n        executionEffort: UInt64,\n        fees: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String\n    )\n\n    /// Emitted when a scheduled transaction is executed by the FVM\n    access(all) event Executed(\n        id: UInt64,\n        priority: UInt8,\n        executionEffort: UInt64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String,\n        transactionHandlerUUID: UInt64,\n\n        // The public path of the transaction handler that can be used to resolve views\n        // DISCLAIMER: There is no guarantee that the public path is accurate\n        transactionHandlerPublicPath: PublicPath?\n    )\n\n    /// Emitted when a scheduled transaction is canceled by the creator of the transaction\n    access(all) event Canceled(\n        id: UInt64,\n        priority: UInt8,\n        feesReturned: UFix64,\n        feesDeducted: UFix64,\n        transactionHandlerOwner: Address,\n        transactionHandlerTypeIdentifier: String\n    )\n\n    /// Emitted when a collection limit is reached\n    /// The limit that was reached is non-nil and is the limit that was reached\n    /// The other limit that was not reached is nil\n    access(all) event CollectionLimitReached(\n        collectionEffortLimit: UInt64?,\n        collectionTransactionsLimit: Int?\n    )\n\n    /// Emitted when the limit on the number of transactions that can be removed in process() is reached\n    access(all) event RemovalLimitReached()\n\n    // Emitted when one or more of the configuration details fields are updated\n    // Event listeners can listen to this and query the new configuration\n    // if they need to\n    access(all) event ConfigUpdated()\n\n    // Emitted when a critical issue is encountered\n    access(all) event CriticalIssue(message: String)\n\n    /// Entitlements\n    access(all) entitlement Execute\n    access(all) entitlement Process\n    access(all) entitlement Cancel\n    access(all) entitlement UpdateConfig\n\n    /// Interfaces\n\n    /// TransactionHandler is an interface that defines a single method executeTransaction that \n    /// must be implemented by the resource that contains the logic to be executed by the scheduled transaction.\n    /// An authorized capability to this resource is provided when scheduling a transaction.\n    /// The transaction scheduler uses this capability to execute the transaction when its scheduled timestamp arrives.\n    access(all) resource interface TransactionHandler: ViewResolver.Resolver {\n\n        access(all) view fun getViews(): [Type] {\n            return []\n        }\n\n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            return nil\n        }\n\n        /// Executes the implemented transaction logic\n        ///\n        /// @param id: The id of the scheduled transaction (this can be useful for any internal tracking)\n        /// @param data: The data that was passed when the transaction was originally scheduled\n        /// that may be useful for the execution of the transaction logic\n        access(Execute) fun executeTransaction(id: UInt64, data: AnyStruct?)\n    }\n\n    /// Structs\n\n    /// ScheduledTransaction is the resource that the user receives after scheduling a transaction.\n    /// It allows them to get the status of their transaction and can be passed back\n    /// to the scheduler contract to cancel the transaction if it has not yet been executed. \n    access(all) resource ScheduledTransaction {\n        access(all) let id: UInt64\n        access(all) let timestamp: UFix64\n        access(all) let handlerTypeIdentifier: String\n\n        access(all) view fun status(): Status? {\n            return FlowTransactionScheduler.sharedScheduler.borrow()!.getStatus(id: self.id)\n        }\n\n        init(\n            id: UInt64, \n            timestamp: UFix64,\n            handlerTypeIdentifier: String\n        ) {\n            self.id = id\n            self.timestamp = timestamp\n            self.handlerTypeIdentifier = handlerTypeIdentifier\n        }\n\n        // event emitted when the resource is destroyed\n        access(all) event ResourceDestroyed(id: UInt64 = self.id, timestamp: UFix64 = self.timestamp, handlerTypeIdentifier: String = self.handlerTypeIdentifier)\n    }\n\n    /// EstimatedScheduledTransaction contains data for estimating transaction scheduling.\n    access(all) struct EstimatedScheduledTransaction {\n        /// flowFee is the estimated fee in Flow for the transaction to be scheduled\n        access(all) let flowFee: UFix64?\n        /// timestamp is estimated timestamp that the transaction will be executed at\n        access(all) let timestamp: UFix64?\n        /// error is an optional error message if the transaction cannot be scheduled\n        access(all) let error: String?\n\n        access(contract) view init(flowFee: UFix64?, timestamp: UFix64?, error: String?) {\n            self.flowFee = flowFee\n            self.timestamp = timestamp\n            self.error = error\n        }\n    }\n\n    /// Transaction data is a representation of a scheduled transaction\n    /// It is the source of truth for an individual transaction and stores the\n    /// capability to the handler that contains the logic that will be executed by the transaction.\n    access(all) struct TransactionData {\n        access(all) let id: UInt64\n        access(all) let priority: Priority\n        access(all) let executionEffort: UInt64\n        access(all) var status: Status\n\n        /// Fee amount to pay for the transaction\n        access(all) let fees: UFix64\n\n        /// The timestamp that the transaction is scheduled for\n        /// For medium priority transactions, it may be different than the requested timestamp\n        /// For low priority transactions, it is the requested timestamp,\n        /// but the timestamp where the transaction is actually executed may be different\n        access(all) var scheduledTimestamp: UFix64\n\n        /// Capability to the logic that the transaction will execute\n        access(contract) let handler: Capability<auth(Execute) &{TransactionHandler}>\n\n        /// Type identifier of the transaction handler\n        access(all) let handlerTypeIdentifier: String\n        access(all) let handlerAddress: Address\n\n        /// Optional data that can be passed to the handler\n        access(contract) let data: AnyStruct?\n\n        access(contract) init(\n            id: UInt64,\n            handler: Capability<auth(Execute) &{TransactionHandler}>,\n            scheduledTimestamp: UFix64,\n            data: AnyStruct?,\n            priority: Priority,\n            executionEffort: UInt64,\n            fees: UFix64,\n        ) {\n            self.id = id\n            self.handler = handler\n            self.data = data\n            self.priority = priority\n            self.executionEffort = executionEffort\n            self.fees = fees\n            self.status = Status.Scheduled\n            let handlerRef = handler.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n            self.handlerAddress = handler.address\n            self.handlerTypeIdentifier = handlerRef.getType().identifier\n            self.scheduledTimestamp = scheduledTimestamp\n        }\n\n        /// setStatus updates the status of the transaction.\n        /// It panics if the transaction status is already finalized.\n        access(contract) fun setStatus(newStatus: Status) {\n            pre {\n                newStatus != Status.Unknown: \"Invalid status: New status cannot be Unknown\"\n                self.status != Status.Executed && self.status != Status.Canceled:\n                    \"Invalid status: Transaction with id \\(self.id) is already finalized\"\n                newStatus == Status.Executed ? self.status == Status.Scheduled : true:\n                    \"Invalid status: Transaction with id \\(self.id) can only be set as Executed if it is Scheduled\"\n                newStatus == Status.Canceled ? self.status == Status.Scheduled : true:\n                    \"Invalid status: Transaction with id \\(self.id) can only be set as Canceled if it is Scheduled\"\n            }\n\n            self.status = newStatus\n        }\n\n        /// setScheduledTimestamp updates the scheduled timestamp of the transaction.\n        /// It panics if the transaction status is already finalized.\n        access(contract) fun setScheduledTimestamp(newTimestamp: UFix64) {\n            pre {\n                self.status != Status.Executed && self.status != Status.Canceled:\n                    \"Invalid status: Transaction with id \\(self.id) is already finalized\"\n            }\n            self.scheduledTimestamp = newTimestamp\n        }\n\n        /// payAndRefundFees withdraws fees from the transaction based on the refund multiplier.\n        /// It deposits any leftover fees to the FlowFees vault to be used to pay node operator rewards\n        /// like any other transaction on the Flow network.\n        access(contract) fun payAndRefundFees(refundMultiplier: UFix64): @FlowToken.Vault {\n            pre {\n                refundMultiplier >= 0.0 && refundMultiplier <= 1.0:\n                    \"Invalid refund multiplier: The multiplier must be between 0.0 and 1.0 but got \\(refundMultiplier)\"\n            }\n            if refundMultiplier == 0.0 {\n                FlowFees.deposit(from: <-FlowTransactionScheduler.withdrawFees(amount: self.fees))\n                return <-FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n            } else {\n                let amountToReturn = self.fees * refundMultiplier\n                let amountToKeep = self.fees - amountToReturn\n                let feesToReturn <- FlowTransactionScheduler.withdrawFees(amount: amountToReturn)\n                FlowFees.deposit(from: <-FlowTransactionScheduler.withdrawFees(amount: amountToKeep))\n                return <-feesToReturn\n            }\n        }\n\n        /// getData copies and returns the data field\n        access(contract) view fun getData(): AnyStruct? {\n            return self.data\n        }\n\n        /// borrowHandler returns an un-entitled reference to the transaction handler\n        /// This allows users to query metadata views about the handler\n        /// @return: An un-entitled reference to the transaction handler\n        access(all) view fun borrowHandler(): &{TransactionHandler} {\n            return self.handler.borrow() as? &{TransactionHandler}\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n        }\n    }\n\n    /// Struct interface representing all the base configuration details in the Scheduler contract\n    /// that is used for governing the protocol\n    /// This is an interface to allow for the configuration details to be updated in the future\n    access(all) struct interface SchedulerConfig {\n\n        /// maximum effort that can be used for any transaction\n        access(all) var maximumIndividualEffort: UInt64\n\n        /// minimum execution effort is the minimum effort that can be \n        /// used for any transaction\n        access(all) var minimumExecutionEffort: UInt64\n\n        /// slot total effort limit is the maximum effort that can be \n        /// cumulatively allocated to one timeslot by all priorities\n        access(all) var slotTotalEffortLimit: UInt64\n\n        /// slot shared effort limit is the maximum effort \n        /// that can be allocated to high and medium priority \n        /// transactions combined after their exclusive effort reserves have been filled\n        access(all) var slotSharedEffortLimit: UInt64\n\n        /// priority effort reserve is the amount of effort that is \n        /// reserved exclusively for each priority\n        access(all) var priorityEffortReserve: {Priority: UInt64}\n\n        /// priority effort limit is the maximum cumulative effort per priority in a timeslot\n        access(all) var priorityEffortLimit: {Priority: UInt64}\n\n        /// max data size is the maximum data size that can be stored for a transaction\n        access(all) var maxDataSizeMB: UFix64\n\n        /// priority fee multipliers are values we use to calculate the added \n        /// processing fee for each priority\n        access(all) var priorityFeeMultipliers: {Priority: UFix64}\n\n        /// refund multiplier is the portion of the fees that are refunded when any transaction is cancelled\n        access(all) var refundMultiplier: UFix64\n\n        /// canceledTransactionsLimit is the maximum number of canceled transactions\n        /// to keep in the canceledTransactions array\n        access(all) var canceledTransactionsLimit: UInt\n\n        /// collectionEffortLimit is the maximum effort that can be used for all transactions in a collection\n        access(all) var collectionEffortLimit: UInt64\n\n        /// collectionTransactionsLimit is the maximum number of transactions that can be processed in a collection\n        access(all) var collectionTransactionsLimit: Int\n\n        access(all) init(\n            maximumIndividualEffort: UInt64,\n            minimumExecutionEffort: UInt64,\n            slotSharedEffortLimit: UInt64,\n            priorityEffortReserve: {Priority: UInt64},\n            lowPriorityEffortLimit: UInt64,\n            maxDataSizeMB: UFix64,\n            priorityFeeMultipliers: {Priority: UFix64},\n            refundMultiplier: UFix64,\n            canceledTransactionsLimit: UInt,\n            collectionEffortLimit: UInt64,\n            collectionTransactionsLimit: Int,\n            txRemovalLimit: UInt\n        ) {\n            post {\n                self.refundMultiplier >= 0.0 && self.refundMultiplier <= 1.0:\n                    \"Invalid refund multiplier: The multiplier must be between 0.0 and 1.0 but got \\(refundMultiplier)\"\n                self.priorityFeeMultipliers[Priority.Low]! >= 1.0:\n                    \"Invalid priority fee multiplier: Low priority multiplier must be greater than or equal to 1.0 but got \\(self.priorityFeeMultipliers[Priority.Low]!)\"\n                self.priorityFeeMultipliers[Priority.Medium]! > self.priorityFeeMultipliers[Priority.Low]!:\n                    \"Invalid priority fee multiplier: Medium priority multiplier must be greater than or equal to \\(priorityFeeMultipliers[Priority.Low]!) but got \\(priorityFeeMultipliers[Priority.Medium]!)\"\n                self.priorityFeeMultipliers[Priority.High]! > self.priorityFeeMultipliers[Priority.Medium]!:\n                    \"Invalid priority fee multiplier: High priority multiplier must be greater than or equal to \\(priorityFeeMultipliers[Priority.Medium]!) but got \\(priorityFeeMultipliers[Priority.High]!)\"\n                self.priorityEffortLimit[Priority.High]! >= self.priorityEffortReserve[Priority.High]!:\n                    \"Invalid priority effort limit: High priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.High]!)\"\n                self.priorityEffortLimit[Priority.Medium]! >= self.priorityEffortReserve[Priority.Medium]!:\n                    \"Invalid priority effort limit: Medium priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.Medium]!)\"\n                self.priorityEffortLimit[Priority.Low]! >= self.priorityEffortReserve[Priority.Low]!:\n                    \"Invalid priority effort limit: Low priority effort limit must be greater than or equal to the priority effort reserve of \\(priorityEffortReserve[Priority.Low]!)\"\n                self.priorityEffortReserve[Priority.Low]! == 0:\n                    \"Invalid priority effort reserve: Low priority effort reserve must be 0\"\n                self.collectionTransactionsLimit >= 0:\n                    \"Invalid collection transactions limit: Collection transactions limit must be greater than or equal to 0 but got \\(collectionTransactionsLimit)\"\n                self.canceledTransactionsLimit >= 1:\n                    \"Invalid canceled transactions limit: Canceled transactions limit must be greater than or equal to 1 but got \\(canceledTransactionsLimit)\"\n                self.collectionEffortLimit > self.slotTotalEffortLimit:\n                    \"Invalid collection effort limit: Collection effort limit must be greater than \\(self.slotTotalEffortLimit) but got \\(self.collectionEffortLimit)\"\n            }\n        }\n\n        access(all) view fun getTxRemovalLimit(): UInt\n    }\n\n    /// Concrete implementation of the SchedulerConfig interface\n    /// This struct is used to store the configuration details in the Scheduler contract\n    access(all) struct Config: SchedulerConfig {\n        access(all) var maximumIndividualEffort: UInt64\n        access(all) var minimumExecutionEffort: UInt64\n        access(all) var slotTotalEffortLimit: UInt64\n        access(all) var slotSharedEffortLimit: UInt64\n        access(all) var priorityEffortReserve: {Priority: UInt64}\n        access(all) var priorityEffortLimit: {Priority: UInt64}\n        access(all) var maxDataSizeMB: UFix64\n        access(all) var priorityFeeMultipliers: {Priority: UFix64}\n        access(all) var refundMultiplier: UFix64\n        access(all) var canceledTransactionsLimit: UInt\n        access(all) var collectionEffortLimit: UInt64\n        access(all) var collectionTransactionsLimit: Int\n\n        access(all) init(   \n            maximumIndividualEffort: UInt64,\n            minimumExecutionEffort: UInt64,\n            slotSharedEffortLimit: UInt64,\n            priorityEffortReserve: {Priority: UInt64},\n            lowPriorityEffortLimit: UInt64,\n            maxDataSizeMB: UFix64,\n            priorityFeeMultipliers: {Priority: UFix64},\n            refundMultiplier: UFix64,\n            canceledTransactionsLimit: UInt,\n            collectionEffortLimit: UInt64,\n            collectionTransactionsLimit: Int,\n            txRemovalLimit: UInt\n        ) {\n            self.maximumIndividualEffort = maximumIndividualEffort\n            self.minimumExecutionEffort = minimumExecutionEffort\n            self.slotTotalEffortLimit = slotSharedEffortLimit + priorityEffortReserve[Priority.High]! + priorityEffortReserve[Priority.Medium]!\n            self.slotSharedEffortLimit = slotSharedEffortLimit\n            self.priorityEffortReserve = priorityEffortReserve\n            self.priorityEffortLimit = {\n                Priority.High: priorityEffortReserve[Priority.High]! + slotSharedEffortLimit,\n                Priority.Medium: priorityEffortReserve[Priority.Medium]! + slotSharedEffortLimit,\n                Priority.Low: lowPriorityEffortLimit\n            }\n            self.maxDataSizeMB = maxDataSizeMB\n            self.priorityFeeMultipliers = priorityFeeMultipliers\n            self.refundMultiplier = refundMultiplier\n            self.canceledTransactionsLimit = canceledTransactionsLimit\n            self.collectionEffortLimit = collectionEffortLimit\n            self.collectionTransactionsLimit = collectionTransactionsLimit\n            FlowTransactionScheduler.account.storage.load<UInt>(from: /storage/txRemovalLimit)\n            FlowTransactionScheduler.account.storage.save(txRemovalLimit, to: /storage/txRemovalLimit)\n        }\n\n        access(all) view fun getTxRemovalLimit(): UInt {\n            return FlowTransactionScheduler.account.storage.copy<UInt>(from: /storage/txRemovalLimit)\n                ?? 200\n        }\n    }\n\n\n    /// SortedTimestamps maintains timestamps sorted in ascending order for efficient processing\n    /// It encapsulates all operations related to maintaining and querying sorted timestamps\n    access(all) struct SortedTimestamps {\n        /// Internal sorted array of timestamps\n        access(self) var timestamps: [UFix64]\n\n        access(all) init() {\n            self.timestamps = []\n        }\n\n        /// Add a timestamp to the sorted array maintaining sorted order\n        access(all) fun add(timestamp: UFix64) {\n\n            var insertIndex = 0\n            for i, ts in self.timestamps {\n                if timestamp < ts {\n                    insertIndex = i\n                    break\n                } else if timestamp == ts {\n                    return\n                }\n                insertIndex = i + 1\n            }\n            self.timestamps.insert(at: insertIndex, timestamp)\n        }\n\n        /// Remove a timestamp from the sorted array\n        access(all) fun remove(timestamp: UFix64) {\n\n            let index = self.timestamps.firstIndex(of: timestamp)\n            if index != nil {\n                self.timestamps.remove(at: index!)\n            }\n        }\n\n        /// Get all timestamps that are in the past (less than or equal to current timestamp)\n        access(all) fun getBefore(current: UFix64): [UFix64] {\n            let pastTimestamps: [UFix64] = []\n            for timestamp in self.timestamps {\n                if timestamp <= current {\n                    pastTimestamps.append(timestamp)\n                } else {\n                    break  // No need to check further since array is sorted\n                }\n            }\n            return pastTimestamps\n        }\n\n        /// Check if there are any timestamps that need processing\n        /// Returns true if processing is needed, false for early exit\n        access(all) fun hasBefore(current: UFix64): Bool {\n            return self.timestamps.length > 0 && self.timestamps[0] <= current\n        }\n\n        /// Get the whole array of timestamps\n        access(all) fun getAll(): [UFix64] {\n            return self.timestamps\n        }\n    }\n\n    /// Resources\n\n    /// Shared scheduler is a resource that is used as a singleton in the scheduler contract and contains \n    /// all the functionality to schedule, process and execute transactions as well as the internal state. \n    access(all) resource SharedScheduler {\n        /// nextID contains the next transaction ID to be assigned\n        /// This the ID is monotonically increasing and is used to identify each transaction\n        access(contract) var nextID: UInt64\n\n        /// transactions is a map of transaction IDs to TransactionData structs\n        access(contract) var transactions: {UInt64: TransactionData}\n\n        /// slot queue is a map of timestamps to Priorities to transaction IDs and their execution efforts\n        access(contract) var slotQueue: {UFix64: {Priority: {UInt64: UInt64}}}\n\n        /// slot used effort is a map of timestamps map of priorities and \n        /// efforts that has been used for the timeslot\n        access(contract) var slotUsedEffort: {UFix64: {Priority: UInt64}}\n\n        /// sorted timestamps manager for efficient processing\n        access(contract) var sortedTimestamps: SortedTimestamps\n    \n        /// canceled transactions keeps a record of canceled transaction IDs up to a canceledTransactionsLimit\n        access(contract) var canceledTransactions: [UInt64]\n\n        /// Struct that contains all the configuration details for the transaction scheduler protocol\n        /// Can be updated by the owner of the contract\n        access(contract) var config: {SchedulerConfig}\n\n        access(all) init() {\n            self.nextID = 1\n            self.canceledTransactions = [0 as UInt64]\n            \n            self.transactions = {}\n            self.slotUsedEffort = {}\n            self.slotQueue = {}\n            self.sortedTimestamps = SortedTimestamps()\n            \n            /* Default slot efforts and limits look like this:\n\n                Timestamp Slot (17.5kee)\n                \n                           \n                  High Only             High: 15kee max\n                    10kee               (10 exclusive + 5 shared)\n                          \n                |        |\n                 |  Shared Pool         |\n                |  (High+Medium)        |\n                |      5kee            |\n                |        |\n                           Medium: 7.5kee max  \n                  Medium Only           (2.5 exclusive + 5 shared)\n                    2.5kee               \n                          \n                   Low: 2.5kee max\n                  Low (if space left)   (execution time only)\n                        2.5kee           \n                  \n                \n            */\n\n            let sharedEffortLimit: UInt64 = 5_000\n            let highPriorityEffortReserve: UInt64 = 10_000\n            let mediumPriorityEffortReserve: UInt64 = 2_500\n\n            self.config = Config(\n                maximumIndividualEffort: 9999,\n                minimumExecutionEffort: 100,\n                slotSharedEffortLimit: sharedEffortLimit,\n                priorityEffortReserve: {\n                    Priority.High: highPriorityEffortReserve,\n                    Priority.Medium: mediumPriorityEffortReserve,\n                    Priority.Low: 0\n                },\n                lowPriorityEffortLimit: 2_500,\n                maxDataSizeMB: 0.001,\n                priorityFeeMultipliers: {\n                    Priority.High: 10.0,\n                    Priority.Medium: 5.0,\n                    Priority.Low: 2.0\n                },\n                refundMultiplier: 0.5,\n                canceledTransactionsLimit: 1000,\n                collectionEffortLimit: 500_000, // Maximum effort for all transactions in a collection\n                collectionTransactionsLimit: 150, // Maximum number of transactions in a collection\n                txRemovalLimit: 200\n            )\n        }\n\n        /// Gets a copy of the struct containing all the configuration details\n        /// of the Scheduler resource\n        access(contract) view fun getConfig(): {SchedulerConfig} {\n            return self.config\n        }\n\n        /// sets all the configuration details for the Scheduler resource\n        access(UpdateConfig) fun setConfig(newConfig: {SchedulerConfig}) {\n            self.config = newConfig\n            emit ConfigUpdated()\n        }\n\n        /// getTransaction returns a copy of the specified transaction\n        access(contract) view fun getTransaction(id: UInt64): TransactionData? {\n            return self.transactions[id]\n        }\n\n        /// borrowTransaction borrows a reference to the specified transaction\n        access(contract) view fun borrowTransaction(id: UInt64): &TransactionData? {\n            return &self.transactions[id]\n        }\n\n        /// getCanceledTransactions returns a copy of the canceled transactions array\n        access(contract) view fun getCanceledTransactions(): [UInt64] {\n            return self.canceledTransactions\n        }\n\n        /// getTransactionsForTimeframe returns a dictionary of transactions scheduled within a specified time range,\n        /// organized by timestamp and priority with arrays of transaction IDs.\n        /// WARNING: If you provide a time range that is too large, the function will likely fail to complete\n        /// because the function will run out of gas. Keep the time range small.\n        ///\n        /// @param startTimestamp: The start timestamp (inclusive) for the time range\n        /// @param endTimestamp: The end timestamp (inclusive) for the time range\n        /// @return {UFix64: {Priority: [UInt64]}}: A dictionary mapping timestamps to priorities to arrays of transaction IDs\n        access(contract) fun getTransactionsForTimeframe(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: {UInt8: [UInt64]}} {\n            var transactionsInTimeframe: {UFix64: {UInt8: [UInt64]}} = {}\n            \n            // Validate input parameters\n            if startTimestamp > endTimestamp {\n                return transactionsInTimeframe\n            }\n            \n            // Get all timestamps that fall within the specified range\n            let allTimestampsBeforeEnd = self.sortedTimestamps.getBefore(current: endTimestamp)\n            \n            for timestamp in allTimestampsBeforeEnd {\n                // Check if this timestamp falls within our range\n                if timestamp < startTimestamp { continue }\n                \n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                \n                var timestampTransactions: {UInt8: [UInt64]} = {}\n                \n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    var priorityTransactions: [UInt64] = []\n                        \n                    for id in transactionIDs.keys {\n                        priorityTransactions.append(id)\n                    }\n                        \n                    if priorityTransactions.length > 0 {\n                        timestampTransactions[priority.rawValue] = priorityTransactions\n                    }\n                }\n                \n                if timestampTransactions.keys.length > 0 {\n                    transactionsInTimeframe[timestamp] = timestampTransactions\n                }\n                \n            }\n            \n            return transactionsInTimeframe\n        }\n\n        /// calculate fee by converting execution effort to a fee in Flow tokens.\n        /// @param executionEffort: The execution effort of the transaction\n        /// @param priority: The priority of the transaction\n        /// @param dataSizeMB: The size of the data that was passed when the transaction was originally scheduled\n        /// @return UFix64: The fee in Flow tokens that is required to pay for the transaction\n        access(contract) fun calculateFee(executionEffort: UInt64, priority: Priority, dataSizeMB: UFix64): UFix64 {\n            // Use the official FlowFees calculation\n            let baseFee = FlowFees.computeFees(inclusionEffort: 1.0, executionEffort: UFix64(executionEffort)/100000000.0)\n            \n            // Scale the execution fee by the multiplier for the priority\n            let scaledExecutionFee = baseFee * self.config.priorityFeeMultipliers[priority]!\n\n            // Calculate the FLOW required to pay for storage of the transaction data\n            let storageFee = FlowStorageFees.storageCapacityToFlow(dataSizeMB)\n            \n            return scaledExecutionFee + storageFee\n        }\n\n        /// getNextIDAndIncrement returns the next ID and increments the ID counter\n        access(self) fun getNextIDAndIncrement(): UInt64 {\n            let nextID = self.nextID\n            self.nextID = self.nextID + 1\n            return nextID\n        }\n\n        /// get status of the scheduled transaction\n        /// @param id: The ID of the transaction to get the status of\n        /// @return Status: The status of the transaction, if the transaction is not found Unknown is returned.\n        access(contract) view fun getStatus(id: UInt64): Status? {\n            // if the transaction ID is greater than the next ID, it is not scheduled yet and has never existed\n            if id == 0 as UInt64 || id >= self.nextID {\n                return nil\n            }\n\n            // This should always return Scheduled or Executed\n            if let tx = self.borrowTransaction(id: id) {\n                return tx.status\n            }\n\n            // if the transaction was canceled and it is still not pruned from \n            // list return canceled status\n            if self.canceledTransactions.contains(id) {\n                return Status.Canceled\n            }\n\n            // if transaction ID is after first canceled ID it must be executed \n            // otherwise it would have been canceled and part of this list\n            let firstCanceledID = self.canceledTransactions[0]\n            if id > firstCanceledID {\n                return Status.Executed\n            }\n\n            // the transaction list was pruned and the transaction status might be \n            // either canceled or execute so we return unknown\n            return Status.Unknown\n        }\n\n        /// schedule is the primary entry point for scheduling a new transaction within the scheduler contract. \n        /// If scheduling the transaction is not possible either due to invalid arguments or due to \n        /// unavailable slots, the function panics. \n        //\n        /// The schedule function accepts the following arguments:\n        /// @param: transaction: A capability to a resource in storage that implements the transaction handler \n        ///    interface. This handler will be invoked at execution time and will receive the specified data payload.\n        /// @param: timestamp: Specifies the earliest block timestamp at which the transaction is eligible for execution \n        ///    (Unix timestamp so fractional seconds values are ignored). It must be set in the future.\n        /// @param: priority: An enum value (`High`, `Medium`, or `Low`) that influences the scheduling behavior and determines \n        ///    how soon after the timestamp the transaction will be executed.\n        /// @param: executionEffort: Defines the maximum computational resources allocated to the transaction. This also determines \n        ///    the fee charged. Unused execution effort is not refunded.\n        /// @param: fees: A Vault resource containing sufficient funds to cover the required execution effort.\n        access(contract) fun schedule(\n            handlerCap: Capability<auth(Execute) &{TransactionHandler}>,\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: Priority,\n            executionEffort: UInt64,\n            fees: @FlowToken.Vault\n        ): @ScheduledTransaction {\n\n            // Use the estimate function to validate inputs\n            let estimate = self.estimate(\n                data: data,\n                timestamp: timestamp,\n                priority: priority,\n                executionEffort: executionEffort\n            )\n\n            // Estimate returns an error for low priority transactions\n            // so need to check that the error is fine\n            // because low priority transactions are allowed in schedule\n            if estimate.error != nil && estimate.timestamp == nil {\n                panic(estimate.error!)\n            }\n\n            assert (\n                fees.balance >= estimate.flowFee!,\n                message: \"Insufficient fees: The Fee balance of \\(fees.balance) is not sufficient to pay the required amount of \\(estimate.flowFee!) for execution of the transaction.\"\n            )\n\n            let transactionID = self.getNextIDAndIncrement()\n            let transactionData = TransactionData(\n                id: transactionID,\n                handler: handlerCap,\n                scheduledTimestamp: estimate.timestamp!,\n                data: data,\n                priority: priority,\n                executionEffort: executionEffort,\n                fees: fees.balance,\n            )\n\n            // Deposit the fees to the service account's vault\n            FlowTransactionScheduler.depositFees(from: <-fees)\n\n            let handlerRef = handlerCap.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n\n            let handlerPublicPath = handlerRef.resolveView(Type<PublicPath>()) as? PublicPath\n\n            emit Scheduled(\n                id: transactionData.id,\n                priority: transactionData.priority.rawValue,\n                timestamp: transactionData.scheduledTimestamp,\n                executionEffort: transactionData.executionEffort,\n                fees: transactionData.fees,\n                transactionHandlerOwner: transactionData.handler.address,\n                transactionHandlerTypeIdentifier: transactionData.handlerTypeIdentifier,\n                transactionHandlerUUID: handlerRef.uuid,\n                transactionHandlerPublicPath: handlerPublicPath\n            )\n\n            // Add the transaction to the slot queue and update the internal state\n            self.addTransaction(slot: estimate.timestamp!, txData: transactionData)\n            \n            return <-create ScheduledTransaction(\n                id: transactionID, \n                timestamp: estimate.timestamp!,\n                handlerTypeIdentifier: transactionData.handlerTypeIdentifier\n            )\n        }\n\n        /// The estimate function calculates the required fee in Flow and expected execution timestamp for \n        /// a transaction based on the requested timestamp, priority, and execution effort. \n        //\n        /// If the provided arguments are invalid or the transaction cannot be scheduled (e.g., due to \n        /// insufficient computation effort or unavailable time slots) the estimate function\n        /// returns an EstimatedScheduledTransaction struct with a non-nil error message.\n        ///        \n        /// This helps developers ensure sufficient funding and preview the expected scheduling window, \n        /// reducing the risk of unnecessary cancellations.\n        ///\n        /// @param data: The data that was passed when the transaction was originally scheduled\n        /// @param timestamp: The requested timestamp for the transaction\n        /// @param priority: The priority of the transaction\n        /// @param executionEffort: The execution effort of the transaction\n        /// @return EstimatedScheduledTransaction: A struct containing the estimated fee, timestamp, and error message\n        access(contract) fun estimate(\n            data: AnyStruct?,\n            timestamp: UFix64,\n            priority: Priority,\n            executionEffort: UInt64\n        ): EstimatedScheduledTransaction {\n            // Remove fractional values from the timestamp\n            let sanitizedTimestamp = UFix64(UInt64(timestamp))\n\n            if sanitizedTimestamp <= getCurrentBlock().timestamp {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid timestamp: \\(sanitizedTimestamp) is in the past, current timestamp: \\(getCurrentBlock().timestamp)\"\n                        )\n            }\n\n            if executionEffort > self.config.maximumIndividualEffort {\n                return EstimatedScheduledTransaction(\n                    flowFee: nil,\n                    timestamp: nil,\n                    error: \"Invalid execution effort: \\(executionEffort) is greater than the maximum transaction effort of \\(self.config.maximumIndividualEffort)\"\n                )\n            }\n\n            if executionEffort > self.config.priorityEffortLimit[priority]! {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is greater than the priority's max effort of \\(self.config.priorityEffortLimit[priority]!)\"\n                        )\n            }\n\n            if executionEffort < self.config.minimumExecutionEffort {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is less than the minimum execution effort of \\(self.config.minimumExecutionEffort)\"\n                        )\n            }\n\n            let dataSizeMB = FlowTransactionScheduler.getSizeOfData(data)\n            if dataSizeMB > self.config.maxDataSizeMB {\n                return EstimatedScheduledTransaction(\n                    flowFee: nil,\n                    timestamp: nil,\n                    error: \"Invalid data size: \\(dataSizeMB) is greater than the maximum data size of \\(self.config.maxDataSizeMB)MB\"\n                )\n            }\n\n            let fee = self.calculateFee(executionEffort: executionEffort, priority: priority, dataSizeMB: dataSizeMB)\n\n            let scheduledTimestamp = self.calculateScheduledTimestamp(\n                timestamp: sanitizedTimestamp, \n                priority: priority, \n                executionEffort: executionEffort\n            )\n\n            if scheduledTimestamp == nil {\n                return EstimatedScheduledTransaction(\n                            flowFee: nil,\n                            timestamp: nil,\n                            error: \"Invalid execution effort: \\(executionEffort) is greater than the priority's available effort for the requested timestamp.\"\n                        )\n            }\n\n            if priority == Priority.Low {\n                return EstimatedScheduledTransaction(\n                            flowFee: fee,\n                            timestamp: scheduledTimestamp,\n                            error: \"Invalid Priority: Cannot estimate for Low Priority transactions. They will be included in the first block with available space after their requested timestamp.\"\n                        )\n            }\n\n            return EstimatedScheduledTransaction(flowFee: fee, timestamp: scheduledTimestamp, error: nil)\n        }\n\n        /// calculateScheduledTimestamp calculates the timestamp at which a transaction \n        /// can be scheduled. It takes into account the priority of the transaction and \n        /// the execution effort.\n        /// - If the transaction is high priority, it returns the timestamp if there is enough \n        ///    space or nil if there is no space left.\n        /// - If the transaction is medium or low priority and there is space left in the requested timestamp,\n        ///   it returns the requested timestamp. If there is not enough space, it finds the next timestamp with space.\n        ///\n        /// @param timestamp: The requested timestamp for the transaction\n        /// @param priority: The priority of the transaction\n        /// @param executionEffort: The execution effort of the transaction\n        /// @return UFix64?: The timestamp at which the transaction can be scheduled, or nil if there is no space left for a high priority transaction\n        access(contract) view fun calculateScheduledTimestamp(\n            timestamp: UFix64, \n            priority: Priority, \n            executionEffort: UInt64\n        ): UFix64? {\n\n            let used = self.slotUsedEffort[timestamp]\n            // if nothing is scheduled at this timestamp, we can schedule at provided timestamp\n            if used == nil { \n                return timestamp\n            }\n            \n            let available = self.getSlotAvailableEffort(timestamp: timestamp, priority: priority)\n            // if theres enough space, we can tentatively schedule at provided timestamp\n            if executionEffort <= available {\n                return timestamp\n            }\n            \n            if priority == Priority.High {\n                // high priority demands scheduling at exact timestamp or failing\n                return nil\n            }\n\n            // if there is no space left for medium or low priority we search for next available timestamp\n            // todo: check how big the callstack can grow and if we should avoid recursion\n            // todo: we should refactor this into loops, because we could need to recurse 100s of times\n            return self.calculateScheduledTimestamp(\n                timestamp: timestamp + 1.0, \n                priority: priority, \n                executionEffort: executionEffort\n            )\n        }\n\n        /// slot available effort returns the amount of effort that is available for a given timestamp and priority.\n        access(contract) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n\n            // Remove fractional values from the timestamp\n            let sanitizedTimestamp = UFix64(UInt64(timestamp))\n\n            // Get the theoretical maximum allowed for the priority including shared\n            let priorityLimit = self.config.priorityEffortLimit[priority]!\n            \n            // If nothing has been claimed for the requested timestamp,\n            // return the full amount\n            if !self.slotUsedEffort.containsKey(sanitizedTimestamp) {\n                return priorityLimit\n            }\n\n            // Get the mapping of how much effort has been used\n            // for each priority for the timestamp\n            let slotPriorityEffortsUsed = self.slotUsedEffort[sanitizedTimestamp]!\n\n            // Get the exclusive reserves for each priority\n            let highReserve = self.config.priorityEffortReserve[Priority.High]!\n            let mediumReserve = self.config.priorityEffortReserve[Priority.Medium]!\n\n            // Get how much effort has been used for each priority\n            let highUsed = slotPriorityEffortsUsed[Priority.High] ?? 0\n            let mediumUsed = slotPriorityEffortsUsed[Priority.Medium] ?? 0\n\n            // If it is low priority, return whatever effort is remaining\n            // under the low priority effort limit, subtracting the currently used effort for low priority\n            if priority == Priority.Low {\n                let highPlusMediumUsed = highUsed + mediumUsed\n                let totalEffortRemaining = self.config.slotTotalEffortLimit.saturatingSubtract(highPlusMediumUsed)\n                let lowEffortRemaining = totalEffortRemaining < priorityLimit ? totalEffortRemaining : priorityLimit\n                let lowUsed = slotPriorityEffortsUsed[Priority.Low] ?? 0\n                return lowEffortRemaining.saturatingSubtract(lowUsed)\n            }\n            \n            // Get how much shared effort has been used for each priority\n            // Ensure the results are always zero or positive\n            let highSharedUsed: UInt64 = highUsed.saturatingSubtract(highReserve)\n            let mediumSharedUsed: UInt64 = mediumUsed.saturatingSubtract(mediumReserve)\n\n            // Get the theoretical total shared amount between priorities\n            let totalShared = (self.config.slotTotalEffortLimit.saturatingSubtract(highReserve)).saturatingSubtract(mediumReserve)\n\n            // Get the amount of shared effort currently available\n            let highPlusMediumSharedUsed = highSharedUsed + mediumSharedUsed\n            // prevent underflow\n            let sharedAvailable = totalShared.saturatingSubtract(highPlusMediumSharedUsed)\n\n            // we calculate available by calculating available shared effort and \n            // adding any unused reserves for that priority\n            let reserve = self.config.priorityEffortReserve[priority]!\n            let used = slotPriorityEffortsUsed[priority] ?? 0\n            let unusedReserve: UInt64 = reserve.saturatingSubtract(used)\n            let available = sharedAvailable + unusedReserve\n            \n            return available\n        }\n\n         /// add transaction to the queue and updates all the internal state as well as emit an event\n        access(self) fun addTransaction(slot: UFix64, txData: TransactionData) {\n\n            // If nothing is in the queue for this slot, initialize the slot\n            if self.slotQueue[slot] == nil {\n                self.slotQueue[slot] = {}\n\n                // This also means that the used effort record for this slot has not been initialized\n                self.slotUsedEffort[slot] = {\n                    Priority.High: 0,\n                    Priority.Medium: 0,\n                    Priority.Low: 0\n                }\n\n                self.sortedTimestamps.add(timestamp: slot)\n            }\n\n            // Add this transaction id to the slot\n            let slotQueue = self.slotQueue[slot]!\n            if let priorityQueue = slotQueue[txData.priority] {\n                priorityQueue[txData.id] = txData.executionEffort\n                slotQueue[txData.priority] = priorityQueue\n            } else {\n                slotQueue[txData.priority] = {\n                    txData.id: txData.executionEffort\n                }\n            }\n\n            self.slotQueue[slot] = slotQueue\n\n            // Add the execution effort for this transaction to the total for the slot's priority\n            let slotEfforts = self.slotUsedEffort[slot]!\n            var newPriorityEffort = slotEfforts[txData.priority]! + txData.executionEffort\n            slotEfforts[txData.priority] = newPriorityEffort\n            var newTotalEffort: UInt64 = 0\n            for priority in slotEfforts.keys {\n                newTotalEffort = newTotalEffort.saturatingAdd(slotEfforts[priority]!)\n            }\n            self.slotUsedEffort[slot] = slotEfforts\n            \n            // Need to potentially reschedule low priority transactions to make room for the new transaction\n            // Iterate through them and record which ones to reschedule until the total effort is less than the limit\n            let lowTransactionsToReschedule: [UInt64] = []\n            if newTotalEffort > self.config.slotTotalEffortLimit {\n                let lowPriorityTransactions = slotQueue[Priority.Low]!\n                for id in lowPriorityTransactions.keys {\n                    if newTotalEffort <= self.config.slotTotalEffortLimit {\n                        break\n                    }\n                    lowTransactionsToReschedule.append(id)\n                    newTotalEffort = newTotalEffort.saturatingSubtract(lowPriorityTransactions[id]!)\n                }\n            }\n\n            // Store the transaction in the transactions map\n            self.transactions[txData.id] = txData\n\n            // Reschedule low priority transactions if needed\n            self.rescheduleLowPriorityTransactions(slot: slot, transactions: lowTransactionsToReschedule)\n        }\n\n        /// rescheduleLowPriorityTransactions reschedules low priority transactions to make room for a new transaction\n        /// @param slot: The slot that the transactions are currently scheduled at\n        /// @param transactions: The transactions to reschedule\n        access(self) fun rescheduleLowPriorityTransactions(slot: UFix64, transactions: [UInt64]) {\n            for id in transactions {\n                let tx = self.borrowTransaction(id: id)\n                if tx == nil {\n                    emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while rescheduling low priority transactions\")\n                    continue\n                }\n\n                if tx!.priority != Priority.Low {\n                    emit CriticalIssue(message: \"Invalid Priority: Cannot reschedule transaction with id \\(id) because it is not low priority\")\n                    continue\n                }\n                \n                if tx!.scheduledTimestamp != slot {\n                    emit CriticalIssue(message: \"Invalid Timestamp: Cannot reschedule transaction with id \\(id) because it is not scheduled at the same slot as the new transaction\")\n                    continue\n                }\n\n                let newTimestamp = self.calculateScheduledTimestamp(\n                    timestamp: slot + 1.0,\n                    priority: Priority.Low,\n                    executionEffort: tx!.executionEffort\n                )!\n\n                let effort = tx!.executionEffort\n                let transactionData = self.removeTransaction(txData: tx!)\n\n                // Subtract the execution effort for this transaction from the slot's priority\n                let slotEfforts = self.slotUsedEffort[slot]!\n                slotEfforts[Priority.Low] = slotEfforts[Priority.Low]!.saturatingSubtract(effort)\n                self.slotUsedEffort[slot] = slotEfforts\n\n                // Update the transaction's scheduled timestamp and add it back to the slot queue\n                transactionData.setScheduledTimestamp(newTimestamp: newTimestamp)\n                self.addTransaction(slot: newTimestamp, txData: transactionData)\n            }\n        }\n\n        /// remove the transaction from the slot queue.\n        access(self) fun removeTransaction(txData: &TransactionData): TransactionData {\n\n            let transactionID = txData.id\n            let slot = txData.scheduledTimestamp\n            let transactionPriority = txData.priority\n\n            // remove transaction object\n            let transactionObject = self.transactions.remove(key: transactionID)!\n            \n            // garbage collect slots \n            if let transactionQueue = self.slotQueue[slot] {\n\n                if let priorityQueue = transactionQueue[transactionPriority] {\n                    priorityQueue[transactionID] = nil\n                    if priorityQueue.keys.length == 0 {\n                        transactionQueue.remove(key: transactionPriority)\n                    } else {\n                        transactionQueue[transactionPriority] = priorityQueue\n                    }\n\n                    self.slotQueue[slot] = transactionQueue\n                }\n\n                // if the slot is now empty remove it from the maps\n                if transactionQueue.keys.length == 0 {\n                    self.slotQueue.remove(key: slot)\n                    self.slotUsedEffort.remove(key: slot)\n\n                    self.sortedTimestamps.remove(timestamp: slot)\n                }\n            }\n\n            return transactionObject\n        }\n\n        /// pendingQueue creates a list of transactions that are ready for execution.\n        /// For transaction to be ready for execution it must be scheduled.\n        ///\n        /// The queue is sorted by timestamp and then by priority (high, medium, low).\n        /// The queue will contain transactions from all timestamps that are in the past.\n        /// Low priority transactions will only be added if there is effort available in the slot.  \n        /// The return value can be empty if there are no transactions ready for execution.\n        access(Process) fun pendingQueue(): [&TransactionData] {\n            let currentTimestamp = getCurrentBlock().timestamp\n            var pendingTransactions: [&TransactionData] = []\n\n            // total effort across different timestamps guards collection being over the effort limit\n            var collectionAvailableEffort = self.config.collectionEffortLimit\n            var transactionsAvailableCount = self.config.collectionTransactionsLimit\n\n            // Collect past timestamps efficiently from sorted array\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n\n            for timestamp in pastTimestamps {\n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                var high: [&TransactionData] = []\n                var medium: [&TransactionData] = []\n                var low: [&TransactionData] = []\n\n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    for id in transactionIDs.keys {\n                        let tx = self.borrowTransaction(id: id)\n                        if tx == nil {\n                            emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while preparing pending queue\")\n                            continue\n                        }\n                        \n                        // Only add scheduled transactions to the queue\n                        if tx!.status != Status.Scheduled {\n                            continue\n                        }\n\n                        // this is safeguard to prevent collection growing too large in case of block production slowdown\n                        if tx!.executionEffort >= collectionAvailableEffort || transactionsAvailableCount == 0 {\n                            emit CollectionLimitReached(\n                                collectionEffortLimit: transactionsAvailableCount == 0 ? nil : self.config.collectionEffortLimit,\n                                collectionTransactionsLimit: transactionsAvailableCount == 0 ? self.config.collectionTransactionsLimit : nil\n                            )\n                            break\n                        }\n\n                        collectionAvailableEffort = collectionAvailableEffort.saturatingSubtract(tx!.executionEffort)\n                        transactionsAvailableCount = transactionsAvailableCount - 1\n                    \n                        switch tx!.priority {\n                            case Priority.High:\n                                high.append(tx!)\n                            case Priority.Medium:\n                                medium.append(tx!)\n                            case Priority.Low:\n                                low.append(tx!)\n                        }\n                    }\n                }\n\n                pendingTransactions = pendingTransactions\n                    .concat(high)\n                    .concat(medium)\n                    .concat(low)\n            }\n\n            return pendingTransactions\n        }\n\n        /// removeExecutedTransactions removes all transactions that are marked as executed.\n        access(self) fun removeExecutedTransactions(_ currentTimestamp: UFix64) {\n            let pastTimestamps = self.sortedTimestamps.getBefore(current: currentTimestamp)\n            var numRemoved = 0\n            let removalLimit = self.config.getTxRemovalLimit()\n\n            for timestamp in pastTimestamps {\n                let transactionPriorities = self.slotQueue[timestamp] ?? {}\n                \n                for priority in transactionPriorities.keys {\n                    let transactionIDs = transactionPriorities[priority] ?? {}\n                    for id in transactionIDs.keys {\n\n                        numRemoved = numRemoved + 1\n\n                        if UInt(numRemoved) >= removalLimit {\n                            emit RemovalLimitReached()\n                            return\n                        }\n\n                        let tx = self.borrowTransaction(id: id)\n                        if tx == nil {\n                            emit CriticalIssue(message: \"Invalid ID: \\(id) transaction not found while removing executed transactions\")\n                            continue\n                        }\n\n                        // Only remove executed transactions\n                        if tx!.status != Status.Executed {\n                            continue\n                        }\n\n                        // charge the full fee for transaction execution\n                        destroy tx!.payAndRefundFees(refundMultiplier: 0.0)\n\n                        self.removeTransaction(txData: tx!)\n                    }\n                }\n            }\n        }\n\n        /// process scheduled transactions and prepare them for execution. \n        ///\n        /// First, it removes transactions that have already been executed. \n        /// Then, it iterates over past timestamps in the queue and processes the transactions that are \n        /// eligible for execution. It also emits an event for each transaction that is processed.\n        ///\n        /// This function is only called by the FVM to process transactions.\n        access(Process) fun process() {\n            let currentTimestamp = getCurrentBlock().timestamp\n            // Early exit if no timestamps need processing\n            if !self.sortedTimestamps.hasBefore(current: currentTimestamp) {\n                return\n            }\n\n            self.removeExecutedTransactions(currentTimestamp)\n\n            let pendingTransactions = self.pendingQueue()\n\n            for tx in pendingTransactions {\n                // Only emit the pending execution event if the transaction handler capability is borrowable\n                // This is to prevent a situation where the transaction handler is not available\n                // In that case, the transaction is no longer valid because it cannot be executed\n                if let transactionHandler = tx.handler.borrow() {\n                    emit PendingExecution(\n                        id: tx.id,\n                        priority: tx.priority.rawValue,\n                        executionEffort: tx.executionEffort,\n                        fees: tx.fees,\n                        transactionHandlerOwner: tx.handler.address,\n                        transactionHandlerTypeIdentifier: transactionHandler.getType().identifier\n                    )\n                }\n\n                // after pending execution event is emitted we set the transaction as executed because we \n                // must rely on execution node to actually execute it. Execution of the transaction is \n                // done in a separate transaction that calls executeTransaction(id) function.\n                // Executing the transaction can not update the status of transaction or any other shared state,\n                // since that blocks concurrent transaction execution.\n                // Therefore an optimistic update to executed is made here to avoid race condition.\n                tx.setStatus(newStatus: Status.Executed)\n            }\n        }\n\n        /// cancel a scheduled transaction and return a portion of the fees that were paid.\n        ///\n        /// @param id: The ID of the transaction to cancel\n        /// @return: The fees to be returned to the caller\n        access(Cancel) fun cancel(id: UInt64): @FlowToken.Vault {\n            let tx = self.borrowTransaction(id: id) ?? \n                panic(\"Invalid ID: \\(id) transaction not found\")\n\n            assert(\n                tx.status == Status.Scheduled,\n                message: \"Transaction must be in a scheduled state in order to be canceled\"\n            )\n            \n            // Subtract the execution effort for this transaction from the slot's priority\n            let slotEfforts = self.slotUsedEffort[tx.scheduledTimestamp]!\n            slotEfforts[tx.priority] = slotEfforts[tx.priority]!.saturatingSubtract(tx.executionEffort)\n            self.slotUsedEffort[tx.scheduledTimestamp] = slotEfforts\n\n            let totalFees = tx.fees\n            let refundedFees <- tx.payAndRefundFees(refundMultiplier: self.config.refundMultiplier)\n\n            // if the transaction was canceled, add it to the canceled transactions array\n            // maintain sorted order by inserting at the correct position\n            var insertIndex = 0\n            for i, canceledID in self.canceledTransactions {\n                if id < canceledID {\n                    insertIndex = i\n                    break\n                }\n                insertIndex = i + 1\n            }\n            self.canceledTransactions.insert(at: insertIndex, id)\n            \n            // keep the array under the limit\n            if UInt(self.canceledTransactions.length) > self.config.canceledTransactionsLimit {\n                self.canceledTransactions.remove(at: 0)\n            }\n\n            emit Canceled(\n                id: tx.id,\n                priority: tx.priority.rawValue,\n                feesReturned: refundedFees.balance,\n                feesDeducted: totalFees - refundedFees.balance,\n                transactionHandlerOwner: tx.handler.address,\n                transactionHandlerTypeIdentifier: tx.handlerTypeIdentifier\n            )\n\n            self.removeTransaction(txData: tx)\n            \n            return <-refundedFees\n        }\n\n        /// execute transaction is a system function that is called by FVM to execute a transaction by ID.\n        /// The transaction must be found and in correct state or the function panics and this is a fatal error\n        ///\n        /// This function is only called by the FVM to execute transactions.\n        /// WARNING: this function should not change any shared state, it will be run concurrently and it must not be blocking.\n        access(Execute) fun executeTransaction(id: UInt64) {\n            let tx = self.borrowTransaction(id: id) ?? \n                panic(\"Invalid ID: Transaction with id \\(id) not found\")\n\n            assert (\n                tx.status == Status.Executed,\n                message: \"Invalid ID: Cannot execute transaction with id \\(id) because it has incorrect status \\(tx.status.rawValue)\"\n            )\n\n            let transactionHandler = tx.handler.borrow()\n                ?? panic(\"Invalid transaction handler: Could not borrow a reference to the transaction handler\")\n\n            let handlerPublicPath = transactionHandler.resolveView(Type<PublicPath>()) as? PublicPath\n\n            emit Executed(\n                id: tx.id,\n                priority: tx.priority.rawValue,\n                executionEffort: tx.executionEffort,\n                transactionHandlerOwner: tx.handler.address,\n                transactionHandlerTypeIdentifier: transactionHandler.getType().identifier,\n                transactionHandlerUUID: transactionHandler.uuid,\n                transactionHandlerPublicPath: handlerPublicPath\n\n            )\n            \n            transactionHandler.executeTransaction(id: id, data: tx.getData())\n        }\n    }\n    \n    /// Deposit fees to this contract's account's vault\n    access(contract) fun depositFees(from: @FlowToken.Vault) {\n        let vaultRef = self.account.storage.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n        vaultRef.deposit(from: <-from)\n    }\n\n    /// Withdraw fees from this contract's account's vault\n    access(contract) fun withdrawFees(amount: UFix64): @FlowToken.Vault {\n        let vaultRef = self.account.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n            \n        return <-vaultRef.withdraw(amount: amount) as! @FlowToken.Vault\n    }\n\n    access(all) fun schedule(\n        handlerCap: Capability<auth(Execute) &{TransactionHandler}>,\n        data: AnyStruct?,\n        timestamp: UFix64,\n        priority: Priority,\n        executionEffort: UInt64,\n        fees: @FlowToken.Vault\n    ): @ScheduledTransaction {\n        return <-self.sharedScheduler.borrow()!.schedule(\n            handlerCap: handlerCap, \n            data: data, \n            timestamp: timestamp, \n            priority: priority, \n            executionEffort: executionEffort, \n            fees: <-fees\n        )\n    }\n\n    access(all) fun estimate(\n        data: AnyStruct?,\n        timestamp: UFix64,\n        priority: Priority,\n        executionEffort: UInt64\n    ): EstimatedScheduledTransaction {\n        return self.sharedScheduler.borrow()!\n            .estimate(\n                data: data, \n                timestamp: timestamp, \n                priority: priority, \n                executionEffort: executionEffort,\n            )\n    }\n\n    access(all) fun cancel(scheduledTx: @ScheduledTransaction): @FlowToken.Vault {\n        let id = scheduledTx.id\n        destroy scheduledTx\n        return <-self.sharedScheduler.borrow()!.cancel(id: id)\n    }\n\n    /// getTransactionData returns the transaction data for a given ID\n    /// This function can only get the data for a transaction that is currently scheduled or pending execution\n    /// because finalized transaction metadata is not stored in the contract\n    /// @param id: The ID of the transaction to get the data for\n    /// @return: The transaction data for the given ID\n    access(all) view fun getTransactionData(id: UInt64): TransactionData? {\n        return self.sharedScheduler.borrow()!.getTransaction(id: id)\n    }\n\n    /// borrowHandlerForID returns an un-entitled reference to the transaction handler for a given ID\n    /// The handler reference can be used to resolve views to get info about the handler and see where it is stored\n    /// @param id: The ID of the transaction to get the handler for\n    /// @return: An un-entitled reference to the transaction handler for the given ID\n    access(all) view fun borrowHandlerForID(_ id: UInt64): &{TransactionHandler}? {\n        return self.getTransactionData(id: id)?.borrowHandler()\n    }\n\n    /// getCanceledTransactions returns the IDs of the transactions that have been canceled\n    /// @return: The IDs of the transactions that have been canceled\n    access(all) view fun getCanceledTransactions(): [UInt64] {\n        return self.sharedScheduler.borrow()!.getCanceledTransactions()\n    }\n\n\n    access(all) view fun getStatus(id: UInt64): Status? {\n        return self.sharedScheduler.borrow()!.getStatus(id: id)\n    }\n\n    /// getTransactionsForTimeframe returns the IDs of the transactions that are scheduled for a given timeframe\n    /// @param startTimestamp: The start timestamp to get the IDs for\n    /// @param endTimestamp: The end timestamp to get the IDs for\n    /// @return: The IDs of the transactions that are scheduled for the given timeframe\n    access(all) fun getTransactionsForTimeframe(startTimestamp: UFix64, endTimestamp: UFix64): {UFix64: {UInt8: [UInt64]}} {\n        return self.sharedScheduler.borrow()!.getTransactionsForTimeframe(startTimestamp: startTimestamp, endTimestamp: endTimestamp)\n    }\n\n    access(all) view fun getSlotAvailableEffort(timestamp: UFix64, priority: Priority): UInt64 {\n        return self.sharedScheduler.borrow()!.getSlotAvailableEffort(timestamp: timestamp, priority: priority)\n    }\n\n    access(all) fun getConfig(): {SchedulerConfig} {\n        return self.sharedScheduler.borrow()!.getConfig()\n    }\n    \n    /// getSizeOfData takes a transaction's data\n    /// argument and stores it in the contract account's storage, \n    /// checking storage used before and after to see how large the data is in MB\n    /// If data is nil, the function returns 0.0\n    access(all) fun getSizeOfData(_ data: AnyStruct?): UFix64 {\n        if data == nil {\n            return 0.0\n        } else {\n            let type = data!.getType()\n            if type.isSubtype(of: Type<Number>()) \n            || type.isSubtype(of: Type<Bool>()) \n            || type.isSubtype(of: Type<Address>())\n            || type.isSubtype(of: Type<Character>())\n            || type.isSubtype(of: Type<Capability>())\n            {\n                return 0.0\n            }\n        }\n        let storagePath = /storage/dataTemp\n        let storageUsedBefore = self.account.storage.used\n        self.account.storage.save(data!, to: storagePath)\n        let storageUsedAfter = self.account.storage.used\n        self.account.storage.load<AnyStruct>(from: storagePath)\n\n        return FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(storageUsedAfter.saturatingSubtract(storageUsedBefore))\n    }\n\n    access(all) init() {\n        self.storagePath = /storage/sharedScheduler\n        let scheduler <- create SharedScheduler()\n        let oldScheduler <- self.account.storage.load<@AnyResource>(from: self.storagePath)\n        destroy oldScheduler\n        self.account.storage.save(<-scheduler, to: self.storagePath)\n        \n        self.sharedScheduler = self.account.capabilities.storage\n            .issue<auth(Cancel) &SharedScheduler>(self.storagePath)\n    }\n}",
      "valid_from": 130192448,
      "valid_to": 131028292,
      "created_at": "2025-10-21T15:07:50.207344Z",
      "deployments": 3,
      "imported_by": [
        "A.136a10c590912ef8.FlowMateScheduledActionsHandler",
        "A.254b32edc33e5bc3.aiSportsSwapperTransactionHandler",
        "A.3d4488a67d9b07e1.PinPin",
        "A.46df6b5eeec6103a.aiSportsSwapperTransactionHandler",
        "A.46df6b5eeec6103a.FastbreakVaultsCloserTransactionHandler",
        "A.d3a68836521ed4ca.SimpleScheduledTransactionsTestContract",
        "A.e467b9dd11fa00df.FlowTransactionSchedulerUtils"
      ],
      "imported_count": 7,
      "import_count": 5,
      "tags": null
    },
    {
      "name": "Migration",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.Migration/103961478",
      "id": "A.e467b9dd11fa00df.Migration/112945692",
      "identifier": "A.e467b9dd11fa00df.Migration",
      "transaction_hash": "bcbe9d730b21faf629d92b0a19238a76ca5ad225cdb125907ad8d81ae65c6339",
      "status": "ok",
      "diff": "--- e82215a3cd5edde90ae6ea8d5bd21d375e8deed339576d19b5be6acb3534ba3e.103961478\n+++ bcbe9d730b21faf629d92b0a19238a76ca5ad225cdb125907ad8d81ae65c6339.112945692\n@@ -1,6 +1,3 @@\n-\n-import AccountV2Migration from 0xe467b9dd11fa00df\n-\n access(all)\n contract Migration {\n \n@@ -27,6 +24,6 @@\n \n     access(contract)\n     fun migrate() {\n-        AccountV2Migration.migrateNextBatch()\n+        // NO-OP\n     }\n }\n",
      "body": "access(all)\ncontract Migration {\n\n    access(all)\n    resource Admin {\n\n        access(all)\n        fun migrate() {\n            Migration.migrate()\n        }\n    }\n\n    access(all)\n    let adminStoragePath: StoragePath\n\n    init() {\n        self.adminStoragePath = /storage/migrationAdmin\n\n        self.account.storage.save(\n            <-create Admin(),\n            to: self.adminStoragePath\n        )\n    }\n\n    access(contract)\n    fun migrate() {\n        // NO-OP\n    }\n}\n",
      "valid_from": 112945692,
      "valid_to": null,
      "created_at": "2025-05-13T15:06:27.590975Z",
      "deployments": 3,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 0,
      "tags": null
    },
    {
      "name": "EVM",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.EVM/103959965",
      "id": "A.e467b9dd11fa00df.EVM/109924822",
      "identifier": "A.e467b9dd11fa00df.EVM",
      "transaction_hash": "6d98f0fc24b2c24e41f558c405bc8d25ab5e945e2565101ef0be285cd8ccad8a",
      "status": "ok",
      "diff": "--- a8f81d7de1598f3698051660c18c7b489e11735e1c8812f61a504c86552211fc.103959965\n+++ 6d98f0fc24b2c24e41f558c405bc8d25ab5e945e2565101ef0be285cd8ccad8a.109924822\n@@ -499,6 +499,25 @@\n             ) as! Result\n         }\n \n+        /// Calls a contract function with the given data.\n+        /// The execution is limited by the given amount of gas.\n+        /// The transaction state changes are not persisted.\n+        access(all)\n+        fun dryCall(\n+            to: EVMAddress,\n+            data: [UInt8],\n+            gasLimit: UInt64,\n+            value: Balance,\n+        ): Result {\n+            return InternalEVM.dryCall(\n+                from: self.addressBytes,\n+                to: to.bytes,\n+                data: data,\n+                gasLimit: gasLimit,\n+                value: value.attoflow\n+            ) as! Result\n+        }\n+\n         /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n         /// the bridge request\n         access(all)\n@@ -601,6 +620,26 @@\n         ) as! Result\n     }\n \n+    /// Calls a contract function with the given data.\n+    /// The execution is limited by the given amount of gas.\n+    /// The transaction state changes are not persisted.\n+    access(all)\n+    fun dryCall(\n+        from: EVMAddress,\n+        to: EVMAddress,\n+        data: [UInt8],\n+        gasLimit: UInt64,\n+        value: Balance,\n+    ): Result {\n+        return InternalEVM.dryCall(\n+            from: from.bytes,\n+            to: to.bytes,\n+            data: data,\n+            gasLimit: gasLimit,\n+            value: value.attoflow\n+        ) as! Result\n+    }\n+\n     /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n     /// and deposits the gas fees into the provided coinbase address.\n     /// An invalid transaction is not executed and not included in the block.\n",
      "body": "import Crypto\nimport NonFungibleToken from 0x1d7e57aa55817448\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FlowToken from 0x1654653399040a61\n\naccess(all)\ncontract EVM {\n\n    // Entitlements enabling finer-grained access control on a CadenceOwnedAccount\n    access(all) entitlement Validate\n    access(all) entitlement Withdraw\n    access(all) entitlement Call\n    access(all) entitlement Deploy\n    access(all) entitlement Owner\n    access(all) entitlement Bridge\n\n    /// Block executed event is emitted when a new block is created,\n    /// which always happens when a transaction is executed.\n    access(all)\n    event BlockExecuted(\n        // height or number of the block\n        height: UInt64,\n        // hash of the block\n        hash: [UInt8; 32],\n        // timestamp of the block creation\n        timestamp: UInt64,\n        // total Flow supply\n        totalSupply: Int,\n        // all gas used in the block by transactions included\n        totalGasUsed: UInt64,\n        // parent block hash\n        parentHash: [UInt8; 32],\n        // root hash of all the transaction receipts\n        receiptRoot: [UInt8; 32],\n        // root hash of all the transaction hashes\n        transactionHashRoot: [UInt8; 32],\n        /// value returned for PREVRANDAO opcode\n        prevrandao: [UInt8; 32],\n    )\n\n    /// Transaction executed event is emitted every time a transaction\n    /// is executed by the EVM (even if failed).\n    access(all)\n    event TransactionExecuted(\n        // hash of the transaction\n        hash: [UInt8; 32],\n        // index of the transaction in a block\n        index: UInt16,\n        // type of the transaction\n        type: UInt8,\n        // RLP encoded transaction payload\n        payload: [UInt8],\n        // code indicating a specific validation (201-300) or execution (301-400) error\n        errorCode: UInt16,\n        // a human-readable message about the error (if any)\n        errorMessage: String,\n        // the amount of gas transaction used\n        gasConsumed: UInt64,\n        // if transaction was a deployment contains a newly deployed contract address\n        contractAddress: String,\n        // RLP encoded logs\n        logs: [UInt8],\n        // block height in which transaction was included\n        blockHeight: UInt64,\n        /// captures the hex encoded data that is returned from\n        /// the evm. For contract deployments\n        /// it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        returnedData: [UInt8],\n        /// captures the input and output of the calls (rlp encoded) to the extra\n        /// precompiled contracts (e.g. Cadence Arch) during the transaction execution.\n        /// This data helps to replay the transactions without the need to\n        /// have access to the full cadence state data.\n        precompiledCalls: [UInt8],\n        /// stateUpdateChecksum provides a mean to validate\n        /// the updates to the storage when re-executing a transaction off-chain.\n        stateUpdateChecksum: [UInt8; 4]\n    )\n\n    access(all)\n    event CadenceOwnedAccountCreated(address: String)\n\n    /// FLOWTokensDeposited is emitted when FLOW tokens is bridged\n    /// into the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// Similar to the FungibleToken.Deposited event\n    /// this event includes a depositedUUID that captures the\n    /// uuid of the source vault.\n    access(all)\n    event FLOWTokensDeposited(\n        address: String,\n        amount: UFix64,\n        depositedUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// FLOWTokensWithdrawn is emitted when FLOW tokens are bridged\n    /// out of the EVM environment. Note that this event is not emitted\n    /// for transfer of flow tokens between two EVM addresses.\n    /// similar to the FungibleToken.Withdrawn events\n    /// this event includes a withdrawnUUID that captures the\n    /// uuid of the returning vault.\n    access(all)\n    event FLOWTokensWithdrawn(\n        address: String,\n        amount: UFix64,\n        withdrawnUUID: UInt64,\n        balanceAfterInAttoFlow: UInt\n    )\n\n    /// BridgeAccessorUpdated is emitted when the BridgeAccessor Capability\n    /// is updated in the stored BridgeRouter along with identifying\n    /// information about both.\n    access(all)\n    event BridgeAccessorUpdated(\n        routerType: Type,\n        routerUUID: UInt64,\n        routerAddress: Address,\n        accessorType: Type,\n        accessorUUID: UInt64,\n        accessorAddress: Address\n    )\n\n    /// EVMAddress is an EVM-compatible address\n    access(all)\n    struct EVMAddress {\n\n        /// Bytes of the address\n        access(all)\n        let bytes: [UInt8; 20]\n\n        /// Constructs a new EVM address from the given byte representation\n        view init(bytes: [UInt8; 20]) {\n            self.bytes = bytes\n        }\n\n        /// Balance of the address\n        access(all)\n        view fun balance(): Balance {\n            let balance = InternalEVM.balance(\n                address: self.bytes\n            )\n            return Balance(attoflow: balance)\n        }\n\n        /// Nonce of the address\n        access(all)\n        fun nonce(): UInt64 {\n            return InternalEVM.nonce(\n                address: self.bytes\n            )\n        }\n\n        /// Code of the address\n        access(all)\n        fun code(): [UInt8] {\n            return InternalEVM.code(\n                address: self.bytes\n            )\n        }\n\n        /// CodeHash of the address\n        access(all)\n        fun codeHash(): [UInt8] {\n            return InternalEVM.codeHash(\n                address: self.bytes\n            )\n        }\n\n        /// Deposits the given vault into the EVM account with the given address\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            let amount = from.balance\n            if amount == 0.0 {\n                panic(\"calling deposit function with an empty vault is not allowed\")\n            }\n            let depositedUUID = from.uuid\n            InternalEVM.deposit(\n                from: <-from,\n                to: self.bytes\n            )\n            emit FLOWTokensDeposited(\n                address: self.toString(),\n                amount: amount,\n                depositedUUID: depositedUUID,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n        }\n\n        /// Serializes the address to a hex string without the 0x prefix\n        /// Future implementations should pass data to InternalEVM for native serialization\n        access(all)\n        view fun toString(): String {\n            return String.encodeHex(self.bytes.toVariableSized())\n        }\n\n        /// Compares the address with another address\n        access(all)\n        view fun equals(_ other: EVMAddress): Bool {\n            return self.bytes == other.bytes\n        }\n    }\n\n    /// EVMBytes is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes` type\n    access(all)\n    struct EVMBytes {\n\n        /// Byte array representing the `bytes` value\n        access(all)\n        let value: [UInt8]\n\n        view init(value: [UInt8]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes4 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes4` type\n    access(all)\n    struct EVMBytes4 {\n\n        /// Byte array representing the `bytes4` value\n        access(all)\n        let value: [UInt8; 4]\n\n        view init(value: [UInt8; 4]) {\n            self.value = value\n        }\n    }\n\n    /// EVMBytes32 is a type wrapper used for ABI encoding/decoding into\n    /// Solidity `bytes32` type\n    access(all)\n    struct EVMBytes32 {\n\n        /// Byte array representing the `bytes32` value\n        access(all)\n        let value: [UInt8; 32]\n\n        view init(value: [UInt8; 32]) {\n            self.value = value\n        }\n    }\n\n    /// Converts a hex string to an EVM address if the string is a valid hex string\n    /// Future implementations should pass data to InternalEVM for native deserialization\n    access(all)\n    fun addressFromString(_ asHex: String): EVMAddress {\n        pre {\n            asHex.length == 40 || asHex.length == 42: \"Invalid hex string length for an EVM address\"\n        }\n        // Strip the 0x prefix if it exists\n        var withoutPrefix = (asHex[1] == \"x\" ? asHex.slice(from: 2, upTo: asHex.length) : asHex).toLower()\n        let bytes = withoutPrefix.decodeHex().toConstantSized<[UInt8; 20]>()!\n        return EVMAddress(bytes: bytes)\n    }\n\n    access(all)\n    struct Balance {\n\n        /// The balance in atto-FLOW\n        /// Atto-FLOW is the smallest denomination of FLOW (1e18 FLOW)\n        /// that is used to store account balances inside EVM\n        /// similar to the way WEI is used to store ETH divisible to 18 decimal places.\n        access(all)\n        var attoflow: UInt\n\n        /// Constructs a new balance\n        access(all)\n        view init(attoflow: UInt) {\n            self.attoflow = attoflow\n        }\n\n        /// Sets the balance by a UFix64 (8 decimal points), the format\n        /// that is used in Cadence to store FLOW tokens.\n        access(all)\n        fun setFLOW(flow: UFix64){\n            self.attoflow = InternalEVM.castToAttoFLOW(balance: flow)\n        }\n\n        /// Casts the balance to a UFix64 (rounding down)\n        /// Warning! casting a balance to a UFix64 which supports a lower level of precision\n        /// (8 decimal points in compare to 18) might result in rounding down error.\n        /// Use the toAttoFlow function if you care need more accuracy.\n        access(all)\n        view fun inFLOW(): UFix64 {\n            return InternalEVM.castToFLOW(balance: self.attoflow)\n        }\n\n        /// Returns the balance in Atto-FLOW\n        access(all)\n        view fun inAttoFLOW(): UInt {\n            return self.attoflow\n        }\n\n        /// Returns true if the balance is zero\n        access(all)\n        fun isZero(): Bool {\n            return self.attoflow == 0\n        }\n    }\n\n    /// reports the status of evm execution.\n    access(all) enum Status: UInt8 {\n        /// is (rarely) returned when status is unknown\n        /// and something has gone very wrong.\n        access(all) case unknown\n\n        /// is returned when execution of an evm transaction/call\n        /// has failed at the validation step (e.g. nonce mismatch).\n        /// An invalid transaction/call is rejected to be executed\n        /// or be included in a block.\n        access(all) case invalid\n\n        /// is returned when execution of an evm transaction/call\n        /// has been successful but the vm has reported an error as\n        /// the outcome of execution (e.g. running out of gas).\n        /// A failed tx/call is included in a block.\n        /// Note that resubmission of a failed transaction would\n        /// result in invalid status in the second attempt, given\n        /// the nonce would be come invalid.\n        access(all) case failed\n\n        /// is returned when execution of an evm transaction/call\n        /// has been successful and no error is reported by the vm.\n        access(all) case successful\n    }\n\n    /// reports the outcome of evm transaction/call execution attempt\n    access(all) struct Result {\n        /// status of the execution\n        access(all)\n        let status: Status\n\n        /// error code (error code zero means no error)\n        access(all)\n        let errorCode: UInt64\n\n        /// error message\n        access(all)\n        let errorMessage: String\n\n        /// returns the amount of gas metered during\n        /// evm execution\n        access(all)\n        let gasUsed: UInt64\n\n        /// returns the data that is returned from\n        /// the evm for the call. For coa.deploy\n        /// calls it returns the code deployed to\n        /// the address provided in the contractAddress field.\n        /// in case of revert, the smart contract custom error message\n        /// is also returned here (see EIP-140 for more details).\n        access(all)\n        let data: [UInt8]\n\n        /// returns the newly deployed contract address\n        /// if the transaction caused such a deployment\n        /// otherwise the value is nil.\n        access(all)\n        let deployedContract: EVMAddress?\n\n        init(\n            status: Status,\n            errorCode: UInt64,\n            errorMessage: String,\n            gasUsed: UInt64,\n            data: [UInt8],\n            contractAddress: [UInt8; 20]?\n        ) {\n            self.status = status\n            self.errorCode = errorCode\n            self.errorMessage = errorMessage\n            self.gasUsed = gasUsed\n            self.data = data\n\n            if let addressBytes = contractAddress {\n                self.deployedContract = EVMAddress(bytes: addressBytes)\n            } else {\n                self.deployedContract = nil\n            }\n        }\n    }\n\n    access(all)\n    resource interface Addressable {\n        /// The EVM address\n        access(all)\n        view fun address(): EVMAddress\n    }\n\n    access(all)\n    resource CadenceOwnedAccount: Addressable {\n\n        access(self)\n        var addressBytes: [UInt8; 20]\n\n        init() {\n            // address is initially set to zero\n            // but updated through initAddress later\n            // we have to do this since we need resource id (uuid)\n            // to calculate the EVM address for this cadence owned account\n            self.addressBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        }\n\n        access(contract)\n        fun initAddress(addressBytes: [UInt8; 20]) {\n           // only allow set address for the first time\n           // check address is empty\n            for item in self.addressBytes {\n                assert(item == 0, message: \"address byte is not empty\")\n            }\n           self.addressBytes = addressBytes\n        }\n\n        /// The EVM address of the cadence owned account\n        access(all)\n        view fun address(): EVMAddress {\n            // Always create a new EVMAddress instance\n            return EVMAddress(bytes: self.addressBytes)\n        }\n\n        /// Get balance of the cadence owned account\n        access(all)\n        view fun balance(): Balance {\n            return self.address().balance()\n        }\n\n        /// Deposits the given vault into the cadence owned account's balance\n        access(all)\n        fun deposit(from: @FlowToken.Vault) {\n            self.address().deposit(from: <-from)\n        }\n\n        /// The EVM address of the cadence owned account behind an entitlement, acting as proof of access\n        access(Owner | Validate)\n        view fun protectedAddress(): EVMAddress {\n            return self.address()\n        }\n\n        /// Withdraws the balance from the cadence owned account's balance\n        /// Note that amounts smaller than 10nF (10e-8) can't be withdrawn\n        /// given that Flow Token Vaults use UFix64s to store balances.\n        /// If the given balance conversion to UFix64 results in\n        /// rounding error, this function would fail.\n        access(Owner | Withdraw)\n        fun withdraw(balance: Balance): @FlowToken.Vault {\n            if balance.isZero() {\n                panic(\"calling withdraw function with zero balance is not allowed\")\n            }\n            let vault <- InternalEVM.withdraw(\n                from: self.addressBytes,\n                amount: balance.attoflow\n            ) as! @FlowToken.Vault\n            emit FLOWTokensWithdrawn(\n                address: self.address().toString(),\n                amount: balance.inFLOW(),\n                withdrawnUUID: vault.uuid,\n                balanceAfterInAttoFlow: self.balance().attoflow\n            )\n            return <-vault\n        }\n\n        /// Deploys a contract to the EVM environment.\n        /// Returns the result which contains address of\n        /// the newly deployed contract\n        access(Owner | Deploy)\n        fun deploy(\n            code: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.deploy(\n                from: self.addressBytes,\n                code: code,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a function with the given data.\n        /// The execution is limited by the given amount of gas\n        access(Owner | Call)\n        fun call(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance\n        ): Result {\n            return InternalEVM.call(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Calls a contract function with the given data.\n        /// The execution is limited by the given amount of gas.\n        /// The transaction state changes are not persisted.\n        access(all)\n        fun dryCall(\n            to: EVMAddress,\n            data: [UInt8],\n            gasLimit: UInt64,\n            value: Balance,\n        ): Result {\n            return InternalEVM.dryCall(\n                from: self.addressBytes,\n                to: to.bytes,\n                data: data,\n                gasLimit: gasLimit,\n                value: value.attoflow\n            ) as! Result\n        }\n\n        /// Bridges the given NFT to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n        /// the bridge request\n        access(all)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositNFT(nft: <-nft, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given NFT from the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n        /// the bridge request. Note: the caller should own the requested NFT in EVM\n        access(Owner | Bridge)\n        fun withdrawNFT(\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT} {\n            return <- EVM.borrowBridgeAccessor().withdrawNFT(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                id: id,\n                feeProvider: feeProvider\n            )\n        }\n\n        /// Bridges the given Vault to the EVM environment, requiring a Provider from which to withdraw a fee to fulfill\n        /// the bridge request\n        access(all)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ) {\n            EVM.borrowBridgeAccessor().depositTokens(vault: <-vault, to: self.address(), feeProvider: feeProvider)\n        }\n\n        /// Bridges the given fungible tokens from the EVM environment, requiring a Provider from which to withdraw a\n        /// fee to fulfill the bridge request. Note: the caller should own the requested tokens & sufficient balance of\n        /// requested tokens in EVM\n        access(Owner | Bridge)\n        fun withdrawTokens(\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault} {\n            return <- EVM.borrowBridgeAccessor().withdrawTokens(\n                caller: &self as auth(Call) &CadenceOwnedAccount,\n                type: type,\n                amount: amount,\n                feeProvider: feeProvider\n            )\n        }\n    }\n\n    /// Creates a new cadence owned account\n    access(all)\n    fun createCadenceOwnedAccount(): @CadenceOwnedAccount {\n        let acc <-create CadenceOwnedAccount()\n        let addr = InternalEVM.createCadenceOwnedAccount(uuid: acc.uuid)\n        acc.initAddress(addressBytes: addr)\n\n        emit CadenceOwnedAccountCreated(address: acc.address().toString())\n        return <-acc\n    }\n\n    /// Runs an a RLP-encoded EVM transaction, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    access(all)\n    fun run(tx: [UInt8], coinbase: EVMAddress): Result {\n        return InternalEVM.run(\n                tx: tx,\n                coinbase: coinbase.bytes\n        ) as! Result\n    }\n\n    /// mustRun runs the transaction using EVM.run yet it\n    /// rollback if the tx execution status is unknown or invalid.\n    /// Note that this method does not rollback if transaction\n    /// is executed but an vm error is reported as the outcome\n    /// of the execution (status: failed).\n    access(all)\n    fun mustRun(tx: [UInt8], coinbase: EVMAddress): Result {\n        let runResult = self.run(tx: tx, coinbase: coinbase)\n        assert(\n            runResult.status == Status.failed || runResult.status == Status.successful,\n            message: \"tx is not valid for execution\"\n        )\n        return runResult\n    }\n\n    /// Simulates running unsigned RLP-encoded transaction using\n    /// the from address as the signer.\n    /// The transaction state changes are not persisted.\n    /// This is useful for gas estimation or calling view contract functions.\n    access(all)\n    fun dryRun(tx: [UInt8], from: EVMAddress): Result {\n        return InternalEVM.dryRun(\n            tx: tx,\n            from: from.bytes,\n        ) as! Result\n    }\n\n    /// Calls a contract function with the given data.\n    /// The execution is limited by the given amount of gas.\n    /// The transaction state changes are not persisted.\n    access(all)\n    fun dryCall(\n        from: EVMAddress,\n        to: EVMAddress,\n        data: [UInt8],\n        gasLimit: UInt64,\n        value: Balance,\n    ): Result {\n        return InternalEVM.dryCall(\n            from: from.bytes,\n            to: to.bytes,\n            data: data,\n            gasLimit: gasLimit,\n            value: value.attoflow\n        ) as! Result\n    }\n\n    /// Runs a batch of RLP-encoded EVM transactions, deducts the gas fees,\n    /// and deposits the gas fees into the provided coinbase address.\n    /// An invalid transaction is not executed and not included in the block.\n    access(all)\n    fun batchRun(txs: [[UInt8]], coinbase: EVMAddress): [Result] {\n        return InternalEVM.batchRun(\n            txs: txs,\n            coinbase: coinbase.bytes,\n        ) as! [Result]\n    }\n\n    access(all)\n    fun encodeABI(_ values: [AnyStruct]): [UInt8] {\n        return InternalEVM.encodeABI(values)\n    }\n\n    access(all)\n    fun decodeABI(types: [Type], data: [UInt8]): [AnyStruct] {\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    access(all)\n    fun encodeABIWithSignature(\n        _ signature: String,\n        _ values: [AnyStruct]\n    ): [UInt8] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n        let arguments = InternalEVM.encodeABI(values)\n\n        return methodID.concat(arguments)\n    }\n\n    access(all)\n    fun decodeABIWithSignature(\n        _ signature: String,\n        types: [Type],\n        data: [UInt8]\n    ): [AnyStruct] {\n        let methodID = HashAlgorithm.KECCAK_256.hash(\n            signature.utf8\n        ).slice(from: 0, upTo: 4)\n\n        for byte in methodID {\n            if byte != data.removeFirst() {\n                panic(\"signature mismatch\")\n            }\n        }\n\n        return InternalEVM.decodeABI(types: types, data: data)\n    }\n\n    /// ValidationResult returns the result of COA ownership proof validation\n    access(all)\n    struct ValidationResult {\n        access(all)\n        let isValid: Bool\n\n        access(all)\n        let problem: String?\n\n        init(isValid: Bool, problem: String?) {\n            self.isValid = isValid\n            self.problem = problem\n        }\n    }\n\n    /// validateCOAOwnershipProof validates a COA ownership proof\n    access(all)\n    fun validateCOAOwnershipProof(\n        address: Address,\n        path: PublicPath,\n        signedData: [UInt8],\n        keyIndices: [UInt64],\n        signatures: [[UInt8]],\n        evmAddress: [UInt8; 20]\n    ): ValidationResult {\n        // make signature set first\n        // check number of signatures matches number of key indices\n        if keyIndices.length != signatures.length {\n            return ValidationResult(\n                isValid: false,\n                problem: \"key indices size doesn't match the signatures\"\n            )\n        }\n\n        // fetch account\n        let acc = getAccount(address)\n\n        var signatureSet: [Crypto.KeyListSignature] = []\n        let keyList = Crypto.KeyList()\n        var keyListLength = 0\n        let seenAccountKeyIndices: {Int: Int} = {}\n        for signatureIndex, signature in signatures{\n            // index of the key on the account\n            let accountKeyIndex = Int(keyIndices[signatureIndex]!)\n            // index of the key in the key list\n            var keyListIndex = 0\n\n            if !seenAccountKeyIndices.containsKey(accountKeyIndex) {\n                // fetch account key with accountKeyIndex\n                if let key = acc.keys.get(keyIndex: accountKeyIndex) {\n                    if key.isRevoked {\n                        return ValidationResult(\n                            isValid: false,\n                            problem: \"account key is revoked\"\n                        )\n                    }\n\n                    keyList.add(\n                      key.publicKey,\n                      hashAlgorithm: key.hashAlgorithm,\n                      // normalization factor. We need to divide by 1000 because the\n                      // `Crypto.KeyList.verify()` function expects the weight to be\n                      // in the range [0, 1]. 1000 is the key weight threshold.\n                      weight: key.weight / 1000.0,\n                   )\n\n                   keyListIndex = keyListLength\n                   keyListLength = keyListLength + 1\n                   seenAccountKeyIndices[accountKeyIndex] = keyListIndex\n                } else {\n                    return ValidationResult(\n                        isValid: false,\n                        problem: \"invalid key index\"\n                    )\n                }\n            } else {\n               // if we have already seen this accountKeyIndex, use the keyListIndex\n               // that was previously assigned to it\n               // `Crypto.KeyList.verify()` knows how to handle duplicate keys\n               keyListIndex = seenAccountKeyIndices[accountKeyIndex]!\n            }\n\n            signatureSet.append(Crypto.KeyListSignature(\n               keyIndex: keyListIndex,\n               signature: signature\n            ))\n        }\n\n        let isValid = keyList.verify(\n            signatureSet: signatureSet,\n            signedData: signedData,\n            domainSeparationTag: \"FLOW-V0.0-user\"\n        )\n\n        if !isValid{\n            return ValidationResult(\n                isValid: false,\n                problem: \"the given signatures are not valid or provide enough weight\"\n            )\n        }\n\n        let coaRef = acc.capabilities.borrow<&EVM.CadenceOwnedAccount>(path)\n        if coaRef == nil {\n             return ValidationResult(\n                 isValid: false,\n                 problem: \"could not borrow bridge account's resource\"\n             )\n        }\n\n        // verify evm address matching\n        var addr = coaRef!.address()\n        for index, item in coaRef!.address().bytes {\n            if item != evmAddress[index] {\n                return ValidationResult(\n                    isValid: false,\n                    problem: \"evm address mismatch\"\n                )\n            }\n        }\n\n        return ValidationResult(\n            isValid: true,\n            problem: nil\n        )\n    }\n\n    /// Block returns information about the latest executed block.\n    access(all)\n    struct EVMBlock {\n        access(all)\n        let height: UInt64\n\n        access(all)\n        let hash: String\n\n        access(all)\n        let totalSupply: Int\n\n        access(all)\n        let timestamp: UInt64\n\n        init(height: UInt64, hash: String, totalSupply: Int, timestamp: UInt64) {\n            self.height = height\n            self.hash = hash\n            self.totalSupply = totalSupply\n            self.timestamp = timestamp\n        }\n    }\n\n    /// Returns the latest executed block.\n    access(all)\n    fun getLatestBlock(): EVMBlock {\n        return InternalEVM.getLatestBlock() as! EVMBlock\n    }\n\n    /// Interface for a resource which acts as an entrypoint to the VM bridge\n    access(all)\n    resource interface BridgeAccessor {\n\n        /// Endpoint enabling the bridging of an NFT to EVM\n        access(Bridge)\n        fun depositNFT(\n            nft: @{NonFungibleToken.NFT},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of an NFT from EVM\n        access(Bridge)\n        fun withdrawNFT(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            id: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{NonFungibleToken.NFT}\n\n        /// Endpoint enabling the bridging of a fungible token vault to EVM\n        access(Bridge)\n        fun depositTokens(\n            vault: @{FungibleToken.Vault},\n            to: EVMAddress,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n\n        /// Endpoint enabling the bridging of fungible tokens from EVM\n        access(Bridge)\n        fun withdrawTokens(\n            caller: auth(Call) &CadenceOwnedAccount,\n            type: Type,\n            amount: UInt256,\n            feeProvider: auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        ): @{FungibleToken.Vault}\n    }\n\n    /// Interface which captures a Capability to the bridge Accessor, saving it within the BridgeRouter resource\n    access(all)\n    resource interface BridgeRouter {\n\n        /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n        access(Bridge) view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor}\n\n        /// Sets the BridgeAccessor Capability in the BridgeRouter\n        access(Bridge) fun setBridgeAccessor(_ accessor: Capability<auth(Bridge) &{BridgeAccessor}>) {\n            pre {\n                accessor.check(): \"Invalid BridgeAccessor Capability provided\"\n                emit BridgeAccessorUpdated(\n                    routerType: self.getType(),\n                    routerUUID: self.uuid,\n                    routerAddress: self.owner?.address ?? panic(\"Router must have an owner to be identified\"),\n                    accessorType: accessor.borrow()!.getType(),\n                    accessorUUID: accessor.borrow()!.uuid,\n                    accessorAddress: accessor.address\n                )\n            }\n        }\n    }\n\n    /// Returns a reference to the BridgeAccessor designated for internal bridge requests\n    access(self)\n    view fun borrowBridgeAccessor(): auth(Bridge) &{BridgeAccessor} {\n        return self.account.storage.borrow<auth(Bridge) &{BridgeRouter}>(from: /storage/evmBridgeRouter)\n            ?.borrowBridgeAccessor()\n            ?? panic(\"Could not borrow reference to the EVM bridge\")\n    }\n\n    /// The Heartbeat resource controls the block production.\n    /// It is stored in the storage and used in the Flow protocol to call the heartbeat function once per block.\n    access(all)\n    resource Heartbeat {\n        /// heartbeat calls commit block proposals and forms new blocks including all the\n        /// recently executed transactions.\n        /// The Flow protocol makes sure to call this function once per block as a system call.\n        access(all)\n        fun heartbeat() {\n            InternalEVM.commitBlockProposal()\n        }\n    }\n\n    /// setupHeartbeat creates a heartbeat resource and saves it to storage.\n    /// The function is called once during the contract initialization.\n    ///\n    /// The heartbeat resource is used to control the block production,\n    /// and used in the Flow protocol to call the heartbeat function once per block.\n    ///\n    /// The function can be called by anyone, but only once:\n    /// the function will fail if the resource already exists.\n    ///\n    /// The resulting resource is stored in the account storage,\n    /// and is only accessible by the account, not the caller of the function.\n    access(all)\n    fun setupHeartbeat() {\n        self.account.storage.save(<-create Heartbeat(), to: /storage/EVMHeartbeat)\n    }\n\n    init() {\n        self.setupHeartbeat()\n    }\n}\n",
      "valid_from": 109924822,
      "valid_to": 137392357,
      "created_at": "2025-04-15T15:19:58.057812Z",
      "deployments": 13,
      "imported_by": [
        "A.04f5ae6bef48c1fc.ERC4626PriceOracles",
        "A.04f5ae6bef48c1fc.ERC4626SinkConnectors",
        "A.04f5ae6bef48c1fc.ERC4626SwapConnectors",
        "A.04f5ae6bef48c1fc.ERC4626Utils",
        "A.0a2fbb92a8ae5c6d.Sk8tibles",
        "A.0e5b1dececaca3a8.UniswapV2SwapConnectors",
        "A.0e965592ae044bcb.BridgedAccountContract",
        "A.15a918087ab12d86.TokenListHelper",
        "A.15d2d18157769313.BridgedAccountContract",
        "A.17ae3b1b0b0d50db.DCATransactionHandler",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV2",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV3",
        "A.17ae3b1b0b0d50db.DCATransactionHandlerV4",
        "A.17ae3b1b0b0d50db.EVMTokenRegistry",
        "A.17ae3b1b0b0d50db.UniswapV2SwapperConnector",
        "A.17ae3b1b0b0d50db.UniswapV2SwapperConnectorV2",
        "A.17ae3b1b0b0d50db.UniswapV3SwapperConnector",
        "A.17ae3b1b0b0d50db.UniswapV3SwapperConnectorV2",
        "A.17ae3b1b0b0d50db.UniswapV3SwapperConnectorV3",
        "A.1a771b21fcceadc2.EVMNativeFLOWConnectors",
        "A.1a771b21fcceadc2.EVMTokenConnectors",
        "A.1e4aa0b87d10b141.EVMVMBridgedNFT_0c4583f2fa24d233015ca58219c5093a5b64f4d7",
        "A.1e4aa0b87d10b141.EVMVMBridgedNFT_12c05208f23ac839f22d1ce854f15b3b082fbd72",
        "A.1e4aa0b87d10b141.EVMVMBridgedNFT_63f52bc3d41f4faa3584b4e99db7ea8922a3d4b2",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_00f4ce400130c9383115f3858f9ca54677426583",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_10448481630fb6d20b597e5b3d7e42dcb1247c8a",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_1feb32f966dcc4a192eecd8918657884319f80c3",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_6a64e027e3f6a94acbdcf39cf0cbb4bead5f5ecb",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_717dae2baf7656be9a9b01dee31d571a9d4c9579",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_7296ebca325e835eb6c1b690484cf6fb4c396d2c",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_8bd75008361517df04aa3ea033f03ba33c0c0a66",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_99af3eea856556646c98c8b9b2548fe815240750",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_9b565507858812e8b5ffbfbde9b200a3bc2e8f76",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_c52e820d2d6207d18667a97e2c6ac22eb26e803c",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_cbf9a7753f9d2d0e8141ebb36d99f87acef98597",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_e8b7423b80f9af33480d365171c7ceda3586aa35",
        "A.1e4aa0b87d10b141.EVMVMBridgedToken_f45cbe30bd953590c9917799142edb05be3f293f",
        "A.1e4aa0b87d10b141.FlowEVMBridge",
        "A.1e4aa0b87d10b141.FlowEVMBridgeAccessor",
        "A.1e4aa0b87d10b141.FlowEVMBridgeConfig",
        "A.1e4aa0b87d10b141.FlowEVMBridgeCustomAssociations",
        "A.1e4aa0b87d10b141.FlowEVMBridgeCustomAssociationTypes",
        "A.1e4aa0b87d10b141.FlowEVMBridgeNFTEscrow",
        "A.1e4aa0b87d10b141.FlowEVMBridgeUtils",
        "A.1e4aa0b87d10b141.IFlowEVMNFTBridge",
        "A.255e789705fa8064.BridgedAccountContract",
        "A.262cf58c0b9fbcff.PrizeVaultV2",
        "A.262cf58c0b9fbcff.PrizeVaultV3",
        "A.321d8fcde05f6e8c.Seussibles",
        "A.3eebe1cb4a1126b2.CrossVMMetadataViews",
        "A.45c0949f83851642.Marbles",
        "A.481914259cb9174e.Aggretsuko",
        "A.4f7ff543c936072b.OneShots",
        "A.79f5b5b0f95a160b.AgentManager2",
        "A.79f5b5b0f95a160b.AgentManager3",
        "A.79f5b5b0f95a160b.AgentManager4",
        "A.79f5b5b0f95a160b.BridgeConfig",
        "A.79f5b5b0f95a160b.BridgeConfigV2",
        "A.848d8db862439fc6.FraggleRock",
        "A.9696e9c94f6fa80e.BridgedAccountContract",
        "A.a7825d405ac89518.EVMAbiHelpers",
        "A.a7825d405ac89518.UniswapV3SwapConnectors",
        "A.aa56464d998070e8.OracleArbHandler",
        "A.b13b21a06b75536d.SwapKeepAliveHandler",
        "A.b13b21a06b75536d.SwapKeepAliveHandlerV2",
        "A.b1d63873c3cc9f79.FlowVaultsStrategies",
        "A.b1d63873c3cc9f79.FlowYieldVaultsStrategies",
        "A.b1d63873c3cc9f79.PMStrategies",
        "A.b1d63873c3cc9f79.PMStrategiesV1",
        "A.b9973a32e6c52813.OracleArbHandler",
        "A.b9973a32e6c52813.RebalanceHandler",
        "A.ca7ee55e4fc3251a.DCAControllerUnified",
        "A.ca7ee55e4fc3251a.DCAControllerV3",
        "A.ca7ee55e4fc3251a.DCAServiceEVM",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMLoop",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMMinimal",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerEVMSimple",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerUnified",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerUnifiedSimple",
        "A.ca7ee55e4fc3251a.DCATransactionHandlerV3",
        "A.ca7ee55e4fc3251a.EVMTokenRegistry",
        "A.ca7ee55e4fc3251a.UniswapV3SwapperConnector",
        "A.ca7ee55e4fc3251a.UniswapV3SwapperConnectorV3",
        "A.cc15a0c9c656b648.EVMNativeFLOWConnectors",
        "A.cc15a0c9c656b648.EVMTokenConnectors",
        "A.efc9bea2fda54f34.HotspotOperatorNFT",
        "A.f09dea4ced653196.FuggClub",
        "A.f94f371678513b2b.UniswapV2SwapConnectors"
      ],
      "imported_count": 88,
      "import_count": 3,
      "tags": null
    },
    {
      "name": "NodeVersionBeacon",
      "address": "0xe467b9dd11fa00df",
      "parent_contract_id": "A.e467b9dd11fa00df.NodeVersionBeacon/85981134",
      "id": "A.e467b9dd11fa00df.NodeVersionBeacon/108628380",
      "identifier": "A.e467b9dd11fa00df.NodeVersionBeacon",
      "transaction_hash": "36492fbd75b49c1415c7f4f719831b6487076a76fc710e3752c93c1e3feff683",
      "status": "ok",
      "diff": "--- crescendo-migration.85981134\n+++ 36492fbd75b49c1415c7f4f719831b6487076a76fc710e3752c93c1e3feff683.108628380\n@@ -18,6 +18,10 @@\n /// The contract itself can be used to query the current version and the next upcoming version.\n access(all) contract NodeVersionBeacon {\n \n+    /// =========================\n+    /// Execution State Versioning\n+    /// =========================\n+\n     /// Struct representing software version as Semantic Version\n     /// along with helper functions\n     /// For reference, see https://semver.org/\n@@ -134,10 +138,11 @@\n         )\n     }\n \n-    /// Event emitted when the version table is updated.\n-    /// It contains the current version and all the upcoming versions\n-    /// sorted by block height.\n-    /// The sequence increases by one each time an event is emitted.\n+    /// A service event emitted when the version table is updated.\n+    /// The version is the software version which must be used for executing a height range of blocks.\n+    /// The version pertains to Execution and Verification Nodes.\n+    /// The table contains the current version and all the upcoming versions sorted by block height.\n+    /// The sequence increases by one each time an event is emitted. \n     /// It can be used to verify no events were missed.\n     access(all) event VersionBeacon(\n         versionBoundaries: [VersionBoundary],\n@@ -280,6 +285,18 @@\n \n             emit NodeVersionBoundaryFreezePeriodChanged(freezePeriod: newFreezePeriod)\n         }\n+\n+        /// Emits the given protocol state version upgrade event.\n+        /// If the version and active view are valid, this will cause the Protocol State\n+        /// to upgrade its model version when the event is incorporated.\n+        /// If either the version or active view are invalid, the service event will be\n+        /// ignored and will have no effect. All validation is performed when the service\n+        /// event is incorporated by the Protocol State.\n+        /// It is safe to emit the same ProtocolStateVersionUpgrade event multiple times,\n+        /// as only version upgrade will occur.\n+        access(all) fun emitProtocolStateVersionUpgrade(newProtocolVersion: UInt64, activeView: UInt64) {\n+            emit ProtocolStateVersionUpgrade(newProtocolVersion: newProtocolVersion, activeView: activeView)\n+        }\n     }\n \n     /// Heartbeat resource that emits the version beacon event and keeps track of upcoming versions.\n@@ -495,6 +512,17 @@\n         return self.versionBoundaryBlockList[0]\n     }\n \n+    /// =========================\n+    /// Protocol State Versioning\n+    /// =========================\n+\n+    /// A service event which is emitted to indicate that the Protocol State version is being upgraded.\n+    /// This acts as a signal to begin using the upgraded Protocol State version \n+    /// after this service event is sealed, and after view `activeView` is entered.\n+    /// Nodes running a software version which does not support `newProtocolVersion`\n+    /// will stop processing new blocks when they reach view `activeAtView`.\n+    access(all) event ProtocolStateVersionUpgrade(newProtocolVersion: UInt64, activeView: UInt64)\n+\n     init(versionUpdateFreezePeriod: UInt64) {\n         self.AdminStoragePath = /storage/NodeVersionBeaconAdmin\n         self.HeartbeatStoragePath = /storage/NodeVersionBeaconHeartbeat\n",
      "body": "/// The NodeVersionBeacon contract holds the past and future protocol versions.\n/// that should be used to execute/handle blocks at aa given block height.\n///\n/// The service account holds the NodeVersionBeacon.Heartbeat resource\n/// which is responsible for emitting the VersionBeacon event.\n/// The event contains the current version and all the upcoming versions.\n/// The event is emitted every time the version table is updated\n/// or a version boundary is reached.\n///\n/// The NodeVersionBeacon.Admin resource is used to add new version boundaries\n/// or change existing future version boundaries. Future version boundaries can only be\n/// changed if they occur after the current block height + versionUpdateFreezePeriod.\n/// This is to ensure that nodes have enough time to react to version table changes.\n/// The versionUpdateFreezePeriod can also be changed by the admin resource, but only if\n/// there are no upcoming version boundaries within the current versionUpdateFreezePeriod or\n/// the new versionUpdateFreezePeriod.\n///\n/// The contract itself can be used to query the current version and the next upcoming version.\naccess(all) contract NodeVersionBeacon {\n\n    /// =========================\n    /// Execution State Versioning\n    /// =========================\n\n    /// Struct representing software version as Semantic Version\n    /// along with helper functions\n    /// For reference, see https://semver.org/\n    access(all) struct Semver {\n        /// Components defining a semantic version\n        access(all) let major: UInt8\n        access(all) let minor: UInt8\n        access(all) let patch: UInt8\n        access(all) let preRelease: String?\n\n        init(major: UInt8, minor: UInt8, patch: UInt8, preRelease: String?) {\n            self.major = major\n            self.minor = minor\n            self.patch = patch\n            self.preRelease = preRelease\n        }\n\n        /// Returns version in Semver format (e.g. v<major>.<minor>.<patch>-<preRelease>)\n        /// as a String\n        access(all) view fun toString(): String {\n            let semverCoreString = self.major.toString()\n                 .concat(\".\")\n                 .concat(\n                     self.minor.toString()\n                 ).concat(\".\")\n                 .concat(\n                     self.patch.toString()\n                 )\n            // Concat pre-release if it exists & return\n            if self.preRelease != nil {\n                return semverCoreString.concat(\"-\").concat(self.preRelease!)\n            }\n\n            return semverCoreString\n        }\n\n        /* Custom Comparators */\n\n        /// Returns true if Semver core is greater than\n        /// passed Semver core and false otherwise\n        access(all) view fun coreGreaterThan(_ other: Semver): Bool {\n            if (self.major != other.major) {\n                return self.major > other.major\n            }\n\n            if (self.minor != other.minor) {\n                return self.minor > other.minor\n            }\n\n            if (self.patch != other.patch) {\n                return self.patch > other.patch\n            }\n\n            return false\n        }\n\n        /// Returns true if Semver core is greater than or\n        /// equal to passed Semver core and false otherwise\n        access(all) view fun coreGreaterThanOrEqualTo(_ other: Semver): Bool {\n            return self.coreGreaterThan(other) || self.coreEqualTo(other)\n        }\n\n        /// Returns true if Semver core is less than\n        /// passed Semver core and false otherwise\n        access(all) view fun coreLessThan(_ other: Semver): Bool {\n            return !self.coreGreaterThanOrEqualTo(other)\n        }\n\n        /// Returns true if Semver core is less than or\n        /// equal to passed Semver core and false otherwise\n        access(all) view fun coreLessThanOrEqualTo(_ other: Semver): Bool {\n            return !self.coreGreaterThan(other)\n        }\n\n        /// Returns true if Semver is equal to passed\n        /// Semver core and false otherwise\n        access(all) view fun coreEqualTo(_ other: Semver): Bool {\n            return self.major == other.major && self.minor == other.minor && self.patch == other.patch\n        }\n\n        /// Returns true if Semver is *exactly* equal to passed\n        /// Semver and false otherwise\n        access(all) view fun strictEqualTo(_ other: Semver): Bool {\n            return self.coreEqualTo(other) && self.preRelease == other.preRelease\n        }\n    }\n\n    /// Returns the v0.0.0 version.\n    access(all) fun zeroSemver(): Semver {\n        return Semver(major: 0, minor: 0, patch: 0, preRelease: nil)\n    }\n\n    /// Struct for emitting the current and incoming versions along with their block\n    access(all) struct VersionBoundary {\n        access(all) let blockHeight: UInt64\n        access(all) let version: Semver\n\n        init(blockHeight: UInt64, version: Semver){\n            self.blockHeight = blockHeight\n            self.version = version\n        }\n    }\n\n    /// Returns the zero boundary. Used as a sentinel value\n    /// for versions before the version beacon contract.\n    /// Simplifies edge case code.\n    /// The zero boundary is at block height 0 and has version v0.0.0.\n    /// It is always the first element in the versionBoundaryBlockList.\n    access(all) fun zeroVersionBoundary(): VersionBoundary {\n        let zeroVersion = self.zeroSemver()\n        return VersionBoundary(\n            blockHeight: 0,\n            version: zeroVersion\n        )\n    }\n\n    /// A service event emitted when the version table is updated.\n    /// The version is the software version which must be used for executing a height range of blocks.\n    /// The version pertains to Execution and Verification Nodes.\n    /// The table contains the current version and all the upcoming versions sorted by block height.\n    /// The sequence increases by one each time an event is emitted. \n    /// It can be used to verify no events were missed.\n    access(all) event VersionBeacon(\n        versionBoundaries: [VersionBoundary],\n        sequence: UInt64\n    )\n\n    /// Event emitted any time the version boundary freeze period is updated.\n    /// freeze period is measured in blocks (from the current block).\n    access(all) event NodeVersionBoundaryFreezePeriodChanged(freezePeriod: UInt64)\n\n    /// Canonical storage path for the NodeVersionBeacon.Admin resource.\n    access(all) let AdminStoragePath: StoragePath\n\n    /// Canonical storage path for the NodeVersionBeacon.Heartbeat resource.\n    access(all) let HeartbeatStoragePath: StoragePath\n\n    /// Block height indexed version boundaries.\n    access(contract) let versionBoundary: {UInt64: VersionBoundary}\n\n    /// Sorted Array containing version boundary block heights.\n    access(contract) var versionBoundaryBlockList: [UInt64]\n\n    /// Index in the versionBoundaryBlockList of the next upcoming version boundary,\n    /// or nil if no upcoming version boundary.\n    access(contract) var firstUpcomingBoundary: UInt64?\n\n    /// versionUpdateFreezePeriod is the number of blocks (past the current one) for which version boundary\n    /// changes are not allowed. This is to ensure that nodes have enough time to react to\n    /// version table changes.\n    access(contract) var versionBoundaryFreezePeriod: UInt64\n\n    /// Boolean flag for keeping track if a VersionBeacon event needs to be emitted on next heartbeat.\n    access(contract) var emitEventOnNextHeartbeat: Bool\n\n    /// A counter that increases every time the Version beacon event is emitted.\n    access(contract) var nextVersionBeaconEventSequence: UInt64\n\n    /// Admin resource that manages version boundaries\n    /// maintained in this contract.\n    access(all) resource Admin {\n        /// Adds or updates a version boundary.\n        access(all) fun setVersionBoundary(versionBoundary: VersionBoundary) {\n            pre {\n                versionBoundary.blockHeight > getCurrentBlock().height + NodeVersionBeacon.versionBoundaryFreezePeriod\n                    : \"Cannot set/update a version boundary for past blocks or blocks in the near future.\"\n            }\n            // Set the flag to true so the event will be emitted next time emitChanges is called\n            NodeVersionBeacon.emitEventOnNextHeartbeat = true\n\n            let exists = NodeVersionBeacon.versionBoundary[versionBoundary.blockHeight] != nil\n            NodeVersionBeacon.versionBoundary[versionBoundary.blockHeight] = versionBoundary\n\n            if exists {\n                // this was an update so nothing else needs to be done\n                return\n            }\n\n            // We have to insert the block height into the ordered list.\n            // This is an inefficient algorithm, but it is not expected that the list of\n            // upcoming versions will be long.\n            var i = NodeVersionBeacon.versionBoundaryBlockList.length\n            while i > 1 && NodeVersionBeacon.versionBoundaryBlockList[i-1] > versionBoundary.blockHeight  {\n                i = i - 1\n            }\n            NodeVersionBeacon.versionBoundaryBlockList.insert(at: i, versionBoundary.blockHeight)\n\n            // no need to change the firstUpcomingBoundary unless it was nil\n            // case 1: index points to a lower block height then the one inserted\n            // => it should remain pointing at that index\n            // case 2: index points to the entry that was replaced by this insert\n            // => it should remain pointing at this new entry, since it is before the old one\n            // case 3: index was pointing to an entry later than the insert FixedPoint\n            // => this is illegal and cannot happen since there are entries with lower block heights.\n            if NodeVersionBeacon.firstUpcomingBoundary == nil {\n                NodeVersionBeacon.firstUpcomingBoundary = UInt64(NodeVersionBeacon.versionBoundaryBlockList.length - 1)\n            }\n        }\n\n        /// Deletes an upcoming version boundary.\n        access(all) fun deleteVersionBoundary(blockHeight: UInt64) {\n            pre {\n                blockHeight > getCurrentBlock().height + NodeVersionBeacon.versionBoundaryFreezePeriod\n                    : \"Cannot delete a version for past blocks or blocks in the near future.\"\n                NodeVersionBeacon.versionBoundary.containsKey(blockHeight): \"No boundary defined at that blockHeight.\"\n            }\n            // Set the flag to true so the event will be emitted next time emitChanges is called\n            NodeVersionBeacon.emitEventOnNextHeartbeat = true\n\n            // Remove the version mapping and upcomingBlockBoundaries\n            NodeVersionBeacon.versionBoundary.remove(key: blockHeight)\n\n            // We have to remove the block height from the ordered list.\n            // This is an inefficient algorithm, but it is not expected that the list of\n            // upcoming versions will be long.\n            var i = NodeVersionBeacon.versionBoundaryBlockList.length - 1\n            while i > 0 && NodeVersionBeacon.versionBoundaryBlockList[i] > blockHeight  {\n                i = i - 1\n            }\n            assert(NodeVersionBeacon.versionBoundaryBlockList[i] == blockHeight,\n             message: \"version boundary exists in map, so it should also exist in the ordered list\")\n\n            NodeVersionBeacon.versionBoundaryBlockList.remove(at: i)\n\n            // the index has to be fixed, but you cannot change records before the index\n            // so the only case to be addressed is that the index is pointing off the list,\n            // because the list is now shorter.\n            if NodeVersionBeacon.firstUpcomingBoundary != nil &&\n                NodeVersionBeacon.firstUpcomingBoundary! >= UInt64(NodeVersionBeacon.versionBoundaryBlockList.length) {\n                NodeVersionBeacon.firstUpcomingBoundary = nil\n            }\n\n        }\n\n        /// Updates the number of blocks in which version boundaries are frozen.\n        access(all) fun setVersionBoundaryFreezePeriod(newFreezePeriod: UInt64) {\n            post {\n                NodeVersionBeacon.versionBoundaryFreezePeriod == newFreezePeriod: \"Update buffer was not properly set!\"\n            }\n\n            // Get current block height.\n            let currentBlockHeight = getCurrentBlock().height\n\n            // No boundaries defined beyond current block, safe to make changes\n            if NodeVersionBeacon.firstUpcomingBoundary == nil {\n                NodeVersionBeacon.versionBoundaryFreezePeriod = newFreezePeriod\n                return\n            }\n\n            let nextBlockBoundary = NodeVersionBeacon.versionBoundaryBlockList[NodeVersionBeacon.firstUpcomingBoundary!]\n\n            // Ensure that the we're not currently within the old or new freeze period\n            // of the next block height boundary\n            assert(\n                currentBlockHeight + NodeVersionBeacon.versionBoundaryFreezePeriod < nextBlockBoundary &&\n                currentBlockHeight + newFreezePeriod < nextBlockBoundary,\n                message: \"Updating buffer now breaks version boundary update expectations. Try updating buffer after next version boundary.\"\n            )\n\n            NodeVersionBeacon.versionBoundaryFreezePeriod = newFreezePeriod\n\n            emit NodeVersionBoundaryFreezePeriodChanged(freezePeriod: newFreezePeriod)\n        }\n\n        /// Emits the given protocol state version upgrade event.\n        /// If the version and active view are valid, this will cause the Protocol State\n        /// to upgrade its model version when the event is incorporated.\n        /// If either the version or active view are invalid, the service event will be\n        /// ignored and will have no effect. All validation is performed when the service\n        /// event is incorporated by the Protocol State.\n        /// It is safe to emit the same ProtocolStateVersionUpgrade event multiple times,\n        /// as only version upgrade will occur.\n        access(all) fun emitProtocolStateVersionUpgrade(newProtocolVersion: UInt64, activeView: UInt64) {\n            emit ProtocolStateVersionUpgrade(newProtocolVersion: newProtocolVersion, activeView: activeView)\n        }\n    }\n\n    /// Heartbeat resource that emits the version beacon event and keeps track of upcoming versions.\n    /// This resource should always be held only by the service account,\n    /// because the service account should be the only one emitting the event,\n    /// and only during the system transaction\n    access(all) resource Heartbeat {\n        // heartbeat is called during the system transaction every block.\n        access(all) fun heartbeat() {\n            self.checkFirstUpcomingBoundary()\n\n            if (!NodeVersionBeacon.emitEventOnNextHeartbeat) {\n                return\n            }\n            NodeVersionBeacon.emitEventOnNextHeartbeat = false\n\n            self.emitVersionBeaconEvent(versionBoundaries: NodeVersionBeacon.getCurrentVersionBoundaries())\n        }\n\n        access(self) fun emitVersionBeaconEvent(versionBoundaries : [VersionBoundary]) {\n\n            emit VersionBeacon(versionBoundaries: versionBoundaries,\n                sequence: NodeVersionBeacon.nextVersionBeaconEventSequence)\n            // After emitting the event increase the event sequence number and set the flag to false\n            // so the event won't be emitted on the next block if there isn't any changes to the table\n            NodeVersionBeacon.nextVersionBeaconEventSequence = NodeVersionBeacon.nextVersionBeaconEventSequence + 1\n\n        }\n\n        /// Check if the index pointing to the next version boundary needs to be moved.\n        access(self) fun checkFirstUpcomingBoundary() {\n            if NodeVersionBeacon.firstUpcomingBoundary == nil {\n                return\n            }\n\n            let currentBlockHeight = getCurrentBlock().height\n            var boundaryIndex =  NodeVersionBeacon.firstUpcomingBoundary!\n            while boundaryIndex < UInt64(NodeVersionBeacon.versionBoundaryBlockList.length)\n              && NodeVersionBeacon.versionBoundaryBlockList[boundaryIndex] <= currentBlockHeight {\n                boundaryIndex = boundaryIndex + 1\n            }\n\n            if boundaryIndex == NodeVersionBeacon.firstUpcomingBoundary! {\n                // no change\n                return\n            }\n\n            if boundaryIndex >= UInt64(NodeVersionBeacon.versionBoundaryBlockList.length) {\n                NodeVersionBeacon.firstUpcomingBoundary = nil\n            } else {\n                NodeVersionBeacon.firstUpcomingBoundary = boundaryIndex\n            }\n\n            // If we passed a boundary re-emit the VersionBeacon event\n            NodeVersionBeacon.emitEventOnNextHeartbeat = true\n        }\n    }\n\n    /// getCurrentVersionBoundaries returns the current version boundaries.\n    /// this is the same list as the one emitted by the VersionBeacon event.\n    access(all) fun getCurrentVersionBoundaries(): [VersionBoundary] {\n            let tableUpdates: [VersionBoundary] = []\n\n            if NodeVersionBeacon.firstUpcomingBoundary == nil {\n                // no future boundaries. Just return the last one.\n                // this is safe, there is at least one record in the versionBoundaryBlockList\n                tableUpdates.append(NodeVersionBeacon.versionBoundary[\n                    NodeVersionBeacon.versionBoundaryBlockList[NodeVersionBeacon.versionBoundaryBlockList.length - 1]\n                ]!)\n                return tableUpdates\n            }\n\n            // -1 to include the version the node should currently be on\n            var start = (NodeVersionBeacon.firstUpcomingBoundary ?? UInt64(NodeVersionBeacon.versionBoundaryBlockList.length)) - 1\n            let end = UInt64(NodeVersionBeacon.versionBoundaryBlockList.length)\n\n            if start < 0 {\n                // this is the case when the current index is at 0\n                start = 0\n            }\n\n            var i = start\n\n            while i < end {\n                let block = NodeVersionBeacon.versionBoundaryBlockList[i]\n                tableUpdates.append(NodeVersionBeacon.versionBoundary[block]!)\n                i = i + 1\n            }\n\n            return tableUpdates\n    }\n\n    /// Returns the versionBoundaryFreezePeriod\n    access(all) view fun getVersionBoundaryFreezePeriod(): UInt64 {\n        return NodeVersionBeacon.versionBoundaryFreezePeriod\n    }\n\n    /// Returns the sequence number of the next version beacon event\n    /// This can be used to verify that no version beacon events were missed.\n    access(all) view fun getNextVersionBeaconSequence(): UInt64 {\n        return self.nextVersionBeaconEventSequence\n    }\n\n    /// Function that returns the version that was defined at the most\n    /// recent block height boundary. May return zero boundary.\n    access(all) fun getCurrentVersionBoundary(): VersionBoundary {\n        var current: UInt64 = 0\n\n        // index is never 0 since version 0 is always in the past\n        if let index = NodeVersionBeacon.firstUpcomingBoundary {\n            assert(index > 0, message: \"index should never be 0 since version 0 is always in the past\")\n            current = self.versionBoundaryBlockList[index-1]\n        } else {\n            current = UInt64(NodeVersionBeacon.versionBoundaryBlockList.length - 1)\n        }\n\n        let block = self.versionBoundaryBlockList[current]\n\n        // Return the version mapped to the last historical block height boundary\n        return self.versionBoundary[block]!\n    }\n\n    access(all) fun getNextVersionBoundary() : VersionBoundary? {\n        if let index = NodeVersionBeacon.firstUpcomingBoundary {\n            let block = self.versionBoundaryBlockList[index]\n            return self.versionBoundary[block]\n        } else {\n            return nil\n        }\n    }\n\n    /// Checks whether given version was compatible at the given historical block height\n    access(all) view fun getVersionBoundary(effectiveAtBlockHeight: UInt64): VersionBoundary {\n        let block = self.searchForClosestHistoricalBlockBoundary(blockHeight: effectiveAtBlockHeight)\n\n        return self.versionBoundary[block]!\n    }\n\n    access(all) struct VersionBoundaryPage {\n        access(all) let page: Int\n        access(all) let perPage: Int\n        access(all) let totalLength: Int\n        access(all) let values : [VersionBoundary]\n\n        view init(page: Int, perPage: Int, totalLength: Int, values: [VersionBoundary]) {\n            self.page = page\n            self.perPage = perPage\n            self.totalLength = totalLength\n            self.values = values\n        }\n\n    }\n\n    /// Returns a page of version boundaries\n    /// page is zero based\n    /// results are sorted by block height\n    access(all) fun getVersionBoundariesPage(page: Int, perPage: Int) : VersionBoundaryPage {\n        pre {\n            page >= 0: \"page must be greater than or equal to 0\"\n            perPage > 0: \"perPage must be greater than 0\"\n        }\n\n        let totalLength = NodeVersionBeacon.versionBoundaryBlockList.length\n        var startIndex = page * perPage\n        if startIndex > totalLength {\n            startIndex = totalLength\n        }\n        var endIndex = startIndex + perPage\n        if endIndex > totalLength {\n            endIndex = totalLength\n        }\n        let values: [VersionBoundary] = []\n        if startIndex == endIndex {\n            return VersionBoundaryPage(page: page, perPage: perPage, totalLength: totalLength, values: values)\n        }\n        for block in self.versionBoundaryBlockList.slice(from: startIndex, upTo: endIndex) {\n            values.append(NodeVersionBeacon.versionBoundary[block]!)\n        }\n        return VersionBoundaryPage(page: page, perPage: perPage, totalLength: totalLength, values: values)\n    }\n\n\n    /// Binary search algorithm to find closest value key in versionTable that is <= target value\n    access(contract) view fun searchForClosestHistoricalBlockBoundary(blockHeight: UInt64): UInt64 {\n        // Return last block boundary if target is beyond\n        let length = self.versionBoundaryBlockList.length\n        if blockHeight >= self.versionBoundaryBlockList[length - 1] {\n            return self.versionBoundaryBlockList[length - 1]\n        }\n\n        // Define search bounds\n        var left = 0\n        var right = length\n        // Loop until search pointers cross\n        while left < right {\n            var mid = (left + right) / 2\n            if self.versionBoundaryBlockList[mid] == blockHeight {\n                return self.versionBoundaryBlockList[mid]\n            }\n            if blockHeight < self.versionBoundaryBlockList[mid] {\n                if mid > 0 && blockHeight > self.versionBoundaryBlockList[mid -1] {\n                    return self.versionBoundaryBlockList[mid - 1]\n                }\n                right = mid\n            } else {\n                if mid < (length - 1) && blockHeight < self.versionBoundaryBlockList[mid + 1] {\n                    return self.versionBoundaryBlockList[mid]\n                }\n                left = mid + 1\n            }\n        }\n        // Return zero version if nothing found\n        return self.versionBoundaryBlockList[0]\n    }\n\n    /// =========================\n    /// Protocol State Versioning\n    /// =========================\n\n    /// A service event which is emitted to indicate that the Protocol State version is being upgraded.\n    /// This acts as a signal to begin using the upgraded Protocol State version \n    /// after this service event is sealed, and after view `activeView` is entered.\n    /// Nodes running a software version which does not support `newProtocolVersion`\n    /// will stop processing new blocks when they reach view `activeAtView`.\n    access(all) event ProtocolStateVersionUpgrade(newProtocolVersion: UInt64, activeView: UInt64)\n\n    init(versionUpdateFreezePeriod: UInt64) {\n        self.AdminStoragePath = /storage/NodeVersionBeaconAdmin\n        self.HeartbeatStoragePath = /storage/NodeVersionBeaconHeartbeat\n\n        // insert a zero-th version to make the API simpler and more robust\n        let zero = NodeVersionBeacon.zeroVersionBoundary()\n\n        self.versionBoundary = {zero.blockHeight:zero}\n        self.versionBoundaryBlockList = [zero.blockHeight]\n        self.versionBoundaryFreezePeriod = versionUpdateFreezePeriod\n        self.firstUpcomingBoundary = nil\n        self.nextVersionBeaconEventSequence = 0\n\n        // emit the event on the first heartbeat to send the zero version\n        self.emitEventOnNextHeartbeat = true\n\n        self.account.storage.save(<-create Admin(), to: self.AdminStoragePath)\n        self.account.storage.save(<-create Heartbeat(), to: self.HeartbeatStoragePath)\n    }\n}\n",
      "valid_from": 108628380,
      "valid_to": null,
      "created_at": "2025-04-03T15:06:12.861397Z",
      "deployments": 3,
      "imported_by": [],
      "imported_count": 0,
      "import_count": 0,
      "tags": null
    }
  ],
  "_links": {
    "next": "/flow/v1/contract?address=0xe467b9dd11fa00df&limit=20&offset=20&valid_from=138787575",
    "self": "/flow/v1/contract?address=0xe467b9dd11fa00df&limit=20&valid_from=138787575"
  }
}